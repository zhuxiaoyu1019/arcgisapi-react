/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{isSome as t}from"../../../core/maybe.js";import{c as e}from"../../../chunks/mat3f64.js";import{t as r,n}from"../../../chunks/vec3.js";import{c as o}from"../../../chunks/vec3f64.js";import s from"../MeshComponent.js";import a from"../MeshVertexAttributes.js";import{georeferenceByTransform as i}from"./georeference.js";function l(){const{faceDescriptions:t,faceVertexOffsets:e,uvScales:r}=x,n=4*t.length,o=new Float64Array(3*n),s=new Float32Array(3*n),a=new Float32Array(2*n),i=new Uint32Array(2*t.length*3);let l=0,c=0,f=0,u=0;for(let h=0;h<t.length;h++){const n=t[h],m=l/3;for(const t of e)i[u++]=m+t;const p=n.corners;for(let t=0;t<4;t++){const e=p[t];let i=0;a[f++]=.25*r[t][0]+n.uvOrigin[0],a[f++]=n.uvOrigin[1]-.25*r[t][1];for(let t=0;t<3;t++)0!==n.axis[t]?(o[l++]=.5*n.axis[t],s[c++]=n.axis[t]):(o[l++]=.5*e[i++],s[c++]=0)}}return{position:o,normal:s,uv:a,faces:i}}function c(e,r){const n=e.components[0],o=n.faces,a=M[r],i=6*a,l=new Uint32Array(6),c=new Uint32Array(o.length-6);let f=0,u=0;for(let t=0;t<o.length;t++)t>=i&&t<i+6?l[f++]=o[t]:c[u++]=o[t];if(t(e.vertexAttributes.uv)){const t=new Float32Array(e.vertexAttributes.uv),r=4*a*2,n=[0,1,1,1,1,0,0,0];for(let e=0;e<n.length;e++)t[r+e]=n[e];e.vertexAttributes.uv=t}return e.components=[new s({faces:l,material:n.material}),new s({faces:c})],e}function f(t=0){const e=Math.round(8*2**t),r=2*e,n=(e-1)*(r+1)+2*r,o=new Float64Array(3*n),s=new Float32Array(3*n),a=new Float32Array(2*n),i=new Uint32Array(3*((e-1)*r*2));let l=0,c=0,f=0,u=0;for(let h=0;h<=e;h++){const t=h/e*Math.PI+.5*Math.PI,n=Math.cos(t),m=Math.sin(t);F[2]=m;const p=0===h||h===e,w=p?r-1:r;for(let v=0;v<=w;v++){const t=v/w*2*Math.PI;F[0]=-Math.sin(t)*n,F[1]=Math.cos(t)*n;for(let e=0;e<3;e++)o[l]=.5*F[e],s[l]=F[e],++l;a[c++]=(v+(p?.5:0))/r,a[c++]=h/e,0!==h&&v!==r&&(h!==e&&(i[f++]=u,i[f++]=u+1,i[f++]=u-r),1!==h&&(i[f++]=u,i[f++]=u-r,i[f++]=u-r-1)),u++}}return{position:o,normal:s,uv:a,faces:i}}function u(t=0){const e=5,r=Math.round(16*2**t),n=(e-1)*(r+1)+2*r,o=new Float64Array(3*n),s=new Float32Array(3*n),a=new Float32Array(2*n),i=new Uint32Array(3*(4*r));let l=0,c=0,f=0,u=0,h=0;for(let m=0;m<=e;m++){const t=0===m||m===e,n=m<=1||m>=e-1,p=2===m||4===m,w=t?r-1:r;for(let v=0;v<=w;v++){const A=v/w*2*Math.PI,g=t?0:.5;F[0]=g*Math.sin(A),F[1]=g*-Math.cos(A),F[2]=m<=2?.5:-.5;for(let t=0;t<3;t++)o[l++]=F[t],s[c++]=n?2===t?m<=1?1:-1:0:2===t?0:F[t]/g;a[f++]=(v+(t?.5:0))/r,a[f++]=m<=1?1*m/3:m<=3?1*(m-2)/3+1/3:1*(m-4)/3+2/3,p||0===m||v===r||(m!==e&&(i[u++]=h,i[u++]=h+1,i[u++]=h-r),1!==m&&(i[u++]=h,i[u++]=h-r,i[u++]=h-r-1)),h++}}return{position:o,normal:s,uv:a,faces:i}}function h(t){const e=v.facingAxisOrderSwap[t],r=v.position,n=v.normal,o=new Float64Array(r.length),s=new Float32Array(n.length);let a=0;for(let i=0;i<4;i++){const t=a;for(let i=0;i<3;i++){const l=e[i],c=Math.abs(l)-1,f=l>=0?1:-1;o[a]=r[t+c]*f,s[a]=n[t+c]*f,a++}}return{position:o,normal:s,uv:new Float32Array(v.uv),faces:new Uint32Array(v.faces)}}const m=1,p=2,w=3,v={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[w,m,p],west:[-w,-m,p],north:[-m,w,p],south:[m,-w,p],up:[m,p,w],down:[m,-p,-w]}};function A(t,e,r){g(t),y(t,r&&r.size);const{vertexAttributes:n,transform:o}=i(t,e,r);return{vertexAttributes:new a({...n,uv:t.uv}),transform:o,components:[new s({faces:t.faces,material:r&&r.material||null})],spatialReference:e.spatialReference}}function g(t){for(let e=0;e<t.position.length;e+=3)t.position[e+2]+=.5}function y(t,e){if(null==e)return;const o="number"==typeof e?[e,e,e]:[null!=e.width?e.width:1,null!=e.depth?e.depth:1,null!=e.height?e.height:1];O[0]=o[0],O[4]=o[1],O[8]=o[2];for(let n=0;n<t.position.length;n+=3){for(let e=0;e<3;e++)F[e]=t.position[n+e];r(F,F,O);for(let e=0;e<3;e++)t.position[n+e]=F[e]}if(o[0]!==o[1]||o[1]!==o[2]){O[0]=1/o[0],O[4]=1/o[1],O[8]=1/o[2];for(let e=0;e<t.normal.length;e+=3){for(let r=0;r<3;r++)F[r]=t.normal[e+r];r(F,F,O),n(F,F);for(let r=0;r<3;r++)t.normal[e+r]=F[r]}}}const x={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},M={south:0,east:1,north:2,west:3,up:4,down:5},F=o(),O=e();export{M as boxFaceOrder,A as convertUnitGeometry,l as createUnitSizeBox,u as createUnitSizeCylinder,h as createUnitSizePlane,f as createUnitSizeSphere,c as extractSingleFaceOfBox};
