/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{isSome as t}from"../../../../../core/maybe.js";import{j as e}from"../../../../../chunks/quat.js";import{I as s,b as r}from"../../../../../chunks/quatf64.js";import{k as i}from"../../../../../chunks/vec3.js";import{Z as a,a as o,O as n}from"../../../../../chunks/vec3f64.js";import l from"../../../MeshMaterialMetallicRoughness.js";import{ungeoreferenceByTransform as c}from"../../georeference.js";import{Buffer as h}from"./buffer.js";import{computeOrigin as u,smoothNormalsMesh as f}from"./geometry.js";import{BufferOutputType as d,ImageOutputType as m,AttributeType as p,TargetBuffer as g,AlphaMode as x}from"./types.js";import{imageToArrayBuffer as b,imageToDataURI as A}from"./imageutils.js";class v{constructor(t,e,s){this.params={},this.materialMap=new Array,this.gltf={asset:{version:"2.0",copyright:t.copyright,generator:t.generator},extras:{options:e,binChunkBuffer:null,promises:[]}},s&&(this.params=s),this.addScenes(t)}addScenes(t){this.gltf.scene=t.defaultScene;const e=this.gltf.extras.options.bufferOutputType===d.GLB||this.gltf.extras.options.imageOutputType===m.GLB;e&&(this.gltf.extras.binChunkBuffer=new h(this.gltf)),t.forEachScene((t=>{this.addScene(t)})),e&&this.gltf.extras.binChunkBuffer.finalize()}addScene(t){this.gltf.scenes||(this.gltf.scenes=[]);const e={};t.name&&(e.name=t.name),t.forEachNode((t=>{e.nodes||(e.nodes=[]);const s=this.addNode(t);e.nodes.push(s)})),this.gltf.scenes.push(e)}addNode(t){this.gltf.nodes||(this.gltf.nodes=[]);const l={};t.name&&(l.name=t.name);const c=t.translation;i(c,a)||(l.translation=o(c));const h=t.rotation;e(h,s)||(l.rotation=r(h));const u=t.scale;i(u,n)||(l.scale=o(u)),t.mesh&&t.mesh.vertexAttributes.position?l.mesh=this.addMesh(t.mesh):t.forEachNode((t=>{l.children||(l.children=[]);const e=this.addNode(t);l.children.push(e)}));const f=this.gltf.nodes.length;return this.gltf.nodes.push(l),f}addMesh(e){this.gltf.meshes||(this.gltf.meshes=[]);const s={primitives:[]},r=this.gltf.extras.options.bufferOutputType===d.GLB;let i;i=r?this.gltf.extras.binChunkBuffer:new h(this.gltf);const a=e.clone();this.params.origin||(this.params.origin=u(a)),a.rotate(-90,0,0,{origin:this.params.origin}),f(a);const o=c(a.vertexAttributes,a.transform,this.params.origin,{geographic:this.params.geographic,unit:"meters"});a.vertexAttributes.position=o.position,a.vertexAttributes.normal=o.normal,a.vertexAttributes.tangent=o.tangent;const n=i.addBufferView(5126,p.VEC3,g.ARRAY_BUFFER);let l,m,x,b;a.vertexAttributes.normal&&(l=i.addBufferView(5126,p.VEC3,g.ARRAY_BUFFER)),a.vertexAttributes.uv&&(m=i.addBufferView(5126,p.VEC2,g.ARRAY_BUFFER)),a.vertexAttributes.tangent&&(x=i.addBufferView(5126,p.VEC4,g.ARRAY_BUFFER)),a.vertexAttributes.color&&(b=i.addBufferView(5121,p.VEC4,g.ARRAY_BUFFER)),n.startAccessor("POSITION"),l&&l.startAccessor("NORMAL"),m&&m.startAccessor("TEXCOORD_0"),x&&x.startAccessor("TANGENT"),b&&b.startAccessor("COLOR_0");const A=a.vertexAttributes.position.length/3;for(let c=0;c<A;++c)n.push(a.vertexAttributes.position[3*c+0]),n.push(a.vertexAttributes.position[3*c+1]),n.push(a.vertexAttributes.position[3*c+2]),l&&t(a.vertexAttributes.normal)&&(l.push(a.vertexAttributes.normal[3*c+0]),l.push(a.vertexAttributes.normal[3*c+1]),l.push(a.vertexAttributes.normal[3*c+2])),m&&t(a.vertexAttributes.uv)&&(m.push(a.vertexAttributes.uv[2*c+0]),m.push(a.vertexAttributes.uv[2*c+1])),x&&t(a.vertexAttributes.tangent)&&(x.push(a.vertexAttributes.tangent[4*c+0]),x.push(a.vertexAttributes.tangent[4*c+1]),x.push(a.vertexAttributes.tangent[4*c+2]),x.push(a.vertexAttributes.tangent[4*c+3])),b&&t(a.vertexAttributes.color)&&(b.push(a.vertexAttributes.color[4*c+0]),b.push(a.vertexAttributes.color[4*c+1]),b.push(a.vertexAttributes.color[4*c+2]),b.push(a.vertexAttributes.color[4*c+3]));const v=n.endAccessor(),R=this.addAccessor(n.index,v);let T,M,O,C,E;if(l){const t=l.endAccessor();T=this.addAccessor(l.index,t)}if(m){const t=m.endAccessor();M=this.addAccessor(m.index,t)}if(x){const t=x.endAccessor();O=this.addAccessor(x.index,t)}if(b){const t=b.endAccessor();C=this.addAccessor(b.index,t)}a.components&&a.components.length>0&&a.components[0].faces?(E=i.addBufferView(5125,p.SCALAR,g.ELEMENT_ARRAY_BUFFER),this.addMeshVertexIndexed(E,a.components,s,R,T,M,O,C)):this.addMeshVertexNonIndexed(a.components,s,R,T,M,O,C),n.finalize(),l&&l.finalize(),m&&m.finalize(),x&&x.finalize(),E&&E.finalize(),b&&b.finalize(),r||i.finalize();const w=this.gltf.meshes.length;return this.gltf.meshes.push(s),w}addMaterial(e){if(null===e)return;const s=this.materialMap.indexOf(e);if(-1!==s)return s;this.gltf.materials||(this.gltf.materials=[]);const r={};switch(e.alphaMode){case"mask":r.alphaMode=x.MASK;break;case"auto":case"blend":r.alphaMode=x.BLEND}.5!==e.alphaCutoff&&(r.alphaCutoff=e.alphaCutoff),e.doubleSided&&(r.doubleSided=e.doubleSided),r.pbrMetallicRoughness={};const i=t=>t**2.1,a=t=>{const e=t.toRgba();return e[0]=i(e[0]/255),e[1]=i(e[1]/255),e[2]=i(e[2]/255),e};if(t(e.color)&&(r.pbrMetallicRoughness.baseColorFactor=a(e.color)),t(e.colorTexture)&&(r.pbrMetallicRoughness.baseColorTexture={index:this.addTexture(e.colorTexture)}),t(e.normalTexture)&&(r.normalTexture={index:this.addTexture(e.normalTexture)}),e instanceof l){if(t(e.emissiveTexture)&&(r.emissiveTexture={index:this.addTexture(e.emissiveTexture)}),t(e.emissiveColor)){const t=a(e.emissiveColor);r.emissiveFactor=[t[0],t[1],t[2]]}t(e.occlusionTexture)&&(r.occlusionTexture={index:this.addTexture(e.occlusionTexture)}),t(e.metallicRoughnessTexture)&&(r.pbrMetallicRoughness.metallicRoughnessTexture={index:this.addTexture(e.metallicRoughnessTexture)}),r.pbrMetallicRoughness.metallicFactor=e.metallic,r.pbrMetallicRoughness.roughnessFactor=e.roughness}else r.pbrMetallicRoughness.metallicFactor=1,r.pbrMetallicRoughness.roughnessFactor=1;const o=this.gltf.materials.length;return this.gltf.materials.push(r),this.materialMap.push(e),o}addTexture(t){this.gltf.textures||(this.gltf.textures=[]);const e={sampler:this.addSampler(t),source:this.addImage(t)},s=this.gltf.textures.length;return this.gltf.textures.push(e),s}addImage(t){this.gltf.images||(this.gltf.images=[]);const e={};if(t.url)e.uri=t.url;else{e.extras=t.data;for(let e=0;e<this.gltf.images.length;++e)if(t.data===this.gltf.images[e].extras)return e;switch(this.gltf.extras.options.imageOutputType){case m.GLB:{const s=this.gltf.extras.binChunkBuffer.addBufferView(5121,p.SCALAR);s.writeAsync(b(t.data)).then((()=>{s.finalize()})),e.bufferView=s.index,e.mimeType="image/png";break}case m.DataURI:e.uri=A(t.data);break;default:this.gltf.extras.promises.push(b(t.data).then((t=>{e.uri=t})))}}const s=this.gltf.images.length;return this.gltf.images.push(e),s}addSampler(t){this.gltf.samplers||(this.gltf.samplers=[]);let e=10497,s=10497;if("string"==typeof t.wrap)switch(t.wrap){case"clamp":e=33071,s=33071;break;case"mirror":e=33648,s=33648}else{switch(t.wrap.vertical){case"clamp":s=33071;break;case"mirror":s=33648}switch(t.wrap.horizontal){case"clamp":e=33071;break;case"mirror":e=33648}}const r={wrapS:e,wrapT:s};for(let a=0;a<this.gltf.samplers.length;++a)if(JSON.stringify(r)===JSON.stringify(this.gltf.samplers[a]))return a;const i=this.gltf.samplers.length;return this.gltf.samplers.push(r),i}addAccessor(t,e){this.gltf.accessors||(this.gltf.accessors=[]);const s={bufferView:t,byteOffset:e.byteOffset,componentType:e.componentType,count:e.count,type:e.type,min:e.min,max:e.max,name:e.name};e.normalized&&(s.normalized=!0);const r=this.gltf.accessors.length;return this.gltf.accessors.push(s),r}addMeshVertexIndexed(t,e,s,r,i,a,o,n){for(const l of e){t.startAccessor("INDICES");for(let s=0;s<l.faces.length;++s)t.push(l.faces[s]);const e=t.endAccessor(),c={attributes:{POSITION:r},indices:this.addAccessor(t.index,e),material:this.addMaterial(l.material)};i&&"flat"!==l.shading&&(c.attributes.NORMAL=i),a&&(c.attributes.TEXCOORD_0=a),o&&"flat"!==l.shading&&(c.attributes.TANGENT=o),n&&(c.attributes.COLOR_0=n),s.primitives.push(c)}}addMeshVertexNonIndexed(t,e,s,r,i,a,o){const n={attributes:{POSITION:s}};r&&(n.attributes.NORMAL=r),i&&(n.attributes.TEXCOORD_0=i),a&&(n.attributes.TANGENT=a),o&&(n.attributes.COLOR_0=o),t&&(n.material=this.addMaterial(t[0].material)),e.primitives.push(n)}}export{v as GLTF};
