/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import"../../../../../geometry.js";import{isNaN as t}from"../../../../../core/mathUtils.js";import{isNone as e,isSome as r}from"../../../../../core/maybe.js";import{s as o,f as s,c as i,n}from"../../../../../chunks/vec3.js";import{c as a}from"../../../../../chunks/vec3f64.js";import m from"../../../../Point.js";function x(t){if(t.components){for(const e of t.components)"smooth"===e.shading&&e.faces&&u(t,e);t.vertexAttributesChanged()}}function u(r,a){e(r.vertexAttributes.normal)&&(r.vertexAttributes.normal=new Float32Array(r.vertexAttributes.position.length));const m=a.faces.length/3;for(let e=0;e<m;++e){const n=a.faces[3*e+0],m=a.faces[3*e+1],x=a.faces[3*e+2],u=o(b,r.vertexAttributes.position[3*n+0],r.vertexAttributes.position[3*n+1],r.vertexAttributes.position[3*n+2]),v=o(A,r.vertexAttributes.position[3*m+0],r.vertexAttributes.position[3*m+1],r.vertexAttributes.position[3*m+2]),c=o(l,r.vertexAttributes.position[3*x+0],r.vertexAttributes.position[3*x+1],r.vertexAttributes.position[3*x+2]),f=s(v,v,u),p=s(c,c,u),h=i(f,f,p);t(r.vertexAttributes.normal[3*n+0])&&(r.vertexAttributes.normal[3*n+0]=0),t(r.vertexAttributes.normal[3*n+1])&&(r.vertexAttributes.normal[3*n+1]=0),t(r.vertexAttributes.normal[3*n+2])&&(r.vertexAttributes.normal[3*n+2]=0),t(r.vertexAttributes.normal[3*m+0])&&(r.vertexAttributes.normal[3*m+0]=0),t(r.vertexAttributes.normal[3*m+1])&&(r.vertexAttributes.normal[3*m+1]=0),t(r.vertexAttributes.normal[3*m+2])&&(r.vertexAttributes.normal[3*m+2]=0),t(r.vertexAttributes.normal[3*x+0])&&(r.vertexAttributes.normal[3*x+0]=0),t(r.vertexAttributes.normal[3*x+1])&&(r.vertexAttributes.normal[3*x+1]=0),t(r.vertexAttributes.normal[3*x+2])&&(r.vertexAttributes.normal[3*x+2]=0),r.vertexAttributes.normal[3*n+0]+=h[0],r.vertexAttributes.normal[3*n+1]+=h[1],r.vertexAttributes.normal[3*n+2]+=h[2],r.vertexAttributes.normal[3*m+0]+=h[0],r.vertexAttributes.normal[3*m+1]+=h[1],r.vertexAttributes.normal[3*m+2]+=h[2],r.vertexAttributes.normal[3*x+0]+=h[0],r.vertexAttributes.normal[3*x+1]+=h[1],r.vertexAttributes.normal[3*x+2]+=h[2]}for(let t=0;t<r.vertexAttributes.normal.length;t+=3)o(c,r.vertexAttributes.normal[t],r.vertexAttributes.normal[t+1],r.vertexAttributes.normal[t+2]),n(c,c),r.vertexAttributes.normal[t+0]=c[0],r.vertexAttributes.normal[t+1]=c[1],r.vertexAttributes.normal[t+2]=c[2]}function v(t){if(r(t.transform))return t.transform.getOriginPoint(t.spatialReference);const e=t.extent.xmax-t.extent.width/2,o=t.extent.ymax-t.extent.height/2,s=t.extent.zmin;return new m({x:e,y:o,z:s,spatialReference:t.extent.spatialReference})}const b=a(),A=a(),l=a(),c=a();export{v as computeOrigin,x as smoothNormalsMesh};
