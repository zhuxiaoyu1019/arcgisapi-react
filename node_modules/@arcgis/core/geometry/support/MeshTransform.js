/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as r}from"../../chunks/tslib.es6.js";import{JSONSupport as o}from"../../core/JSONSupport.js";import{isSome as t}from"../../core/maybe.js";import{property as s}from"../../core/accessorSupport/decorators/property.js";import"../../core/has.js";import"../../core/accessorSupport/ensureType.js";import"../../core/Logger.js";import{subclass as e}from"../../core/accessorSupport/decorators/subclass.js";import{s as i,c as a,t as n,a as l,m as c,f as p,g as m}from"../../chunks/mat4.js";import{c as h,I as u}from"../../chunks/mat4f64.js";import{m as g,k as f}from"../../chunks/vec3.js";import{c as j,f as y,a as v}from"../../chunks/vec3f64.js";import x from"../Point.js";import{computeLinearTransformation as b,projectBuffer as d}from"../projection.js";import{getSphericalPCPFForEllipsoid as M,getReferenceEllipsoid as N}from"../projectionEllipsoid.js";import{create as w,axis as k,angleRad as I}from"./axisAngleDegrees.js";import{BufferViewVec3f64 as S}from"./buffer/BufferView.js";import{t as A}from"../../chunks/vec32.js";import{c as T}from"../../chunks/vec33.js";var L;let B=L=class extends o{constructor(r){super(r),this.origin=j(),this.translation=j(),this.rotation=w(),this.scale=y(1,1,1),this.geographic=!0}get localMatrix(){const r=h();return i(r,r,this.scale),a(r,r,I(this.rotation),k(this.rotation)),n(r,r,this.translation),r}get localMatrixInverse(){return l(h(),this.localMatrix)}applyLocal(r,o){return g(o,r,this.localMatrix)}applyLocalInverse(r,o){return g(o,r,this.localMatrixInverse)}project(r,o){const t=new Float64Array(r.length),s=S.fromTypedArray(t),e=S.fromTypedArray(r);if(this.geographic){const r=M(N(o)),i=h();return b(o,this.origin,i,r),c(i,i,this.localMatrix),A(s,e,i),d(t,r,0,t,o,0,t.length/3),t}const{localMatrix:i,origin:a}=this;p(i,u)?T(s,e):A(s,e,i);for(let n=0;n<t.length;n+=3)t[n+0]+=a[0],t[n+1]+=a[1],t[n+2]+=a[2];return t}getOriginPoint(r){const[o,t,s]=this.origin;return new x({x:o,y:t,z:s,spatialReference:r})}equals(r){return t(r)&&this.geographic===r.geographic&&f(this.origin,r.origin)&&m(this.localMatrix,r.localMatrix)}clone(){const r={origin:v(this.origin),translation:v(this.translation),rotation:w(this.rotation),scale:v(this.scale),geographic:this.geographic};return new L(r)}};r([s({type:[Number],nonNullable:!0,json:{write:!0}})],B.prototype,"origin",void 0),r([s({type:[Number],nonNullable:!0,json:{write:!0}})],B.prototype,"translation",void 0),r([s({type:[Number],nonNullable:!0,json:{write:!0}})],B.prototype,"rotation",void 0),r([s({type:[Number],nonNullable:!0,json:{write:!0}})],B.prototype,"scale",void 0),r([s({type:Boolean,nonNullable:!0,json:{write:!0}})],B.prototype,"geographic",void 0),r([s()],B.prototype,"localMatrix",null),r([s()],B.prototype,"localMatrixInverse",null),B=L=r([e("esri.geometry.support.MeshTransform")],B);var O=B;export default O;
