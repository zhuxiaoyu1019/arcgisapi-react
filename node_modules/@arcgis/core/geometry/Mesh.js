/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import t from"../core/Error.js";import o from"../core/Loadable.js";import r from"../core/Logger.js";import{isNone as n,isSome as s}from"../core/maybe.js";import{EsriPromiseMixin as i}from"../core/Promise.js";import{whenOrAbort as a}from"../core/promiseUtils.js";import{property as l}from"../core/accessorSupport/decorators/property.js";import"../core/has.js";import"../core/accessorSupport/ensureType.js";import{subclass as p}from"../core/accessorSupport/decorators/subclass.js";import{f as c,c as m}from"../chunks/vec3f64.js";import h from"./Extent.js";import u from"./Geometry.js";import f from"./Point.js";import d from"./Polygon.js";import{fromAxisAndAngle as x,compose as y,create as g}from"./support/axisAngleDegrees.js";import b from"./support/MeshComponent.js";import j from"./support/MeshTransform.js";import{MeshVertexAttributes as v}from"./support/MeshVertexAttributes.js";import{triangulate as w}from"./support/triangulationUtils.js";import{centerAt as M}from"./support/meshUtils/centerAt.js";import{loadExternal as P}from"./support/meshUtils/loadExternal.js";import{offset as R}from"./support/meshUtils/offset.js";import{convertUnitGeometry as A,createUnitSizeBox as F,extractSingleFaceOfBox as z,createUnitSizeSphere as C,createUnitSizeCylinder as O,createUnitSizePlane as L}from"./support/meshUtils/primitives.js";import{rotate as U}from"./support/meshUtils/rotate.js";import{scale as T}from"./support/meshUtils/scale.js";var E;const G=r.getLogger("esri.geometry.Mesh");let S=E=class extends(o.LoadableMixin(i(u))){constructor(e){super(e),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new v,this.type="mesh"}initialize(){(n(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded")}get hasExtent(){return!this.loaded&&s(this.external)&&s(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const e=this.vertexAttributes.position,t=this.spatialReference;if(0===e.length||this.components&&0===this.components.length)return{extent:new h({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t}),center:new f({x:0,y:0,z:0,spatialReference:t})};const o=s(this.transform)?this.transform.project(e,t):e;let r=1/0,n=1/0,i=1/0,a=-1/0,l=-1/0,p=-1/0,c=0,m=0,u=0;const d=o.length,x=1/(d/3);let y=0;for(;y<d;){const e=o[y++],t=o[y++],s=o[y++];r=Math.min(r,e),n=Math.min(n,t),i=Math.min(i,s),a=Math.max(a,e),l=Math.max(l,t),p=Math.max(p,s),c+=x*e,m+=x*t,u+=x*s}return{extent:new h({xmin:r,ymin:n,zmin:i,xmax:a,ymax:l,zmax:p,spatialReference:t}),center:new f({x:c,y:m,z:u,spatialReference:t})}}get anchor(){if(s(this.transform))return this.transform.getOriginPoint(this.spatialReference);const e=this.boundingInfo;return new f({x:e.center.x,y:e.center.y,z:e.extent.zmin,spatialReference:this.spatialReference})}get origin(){return s(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&s(this.external)&&s(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(e){this.loaded?(this.components||(this.components=[]),this.components.push(b.from(e)),this.notifyChange("components")):G.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(e){if(this.loaded){if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}G.error("removeComponent()","Provided component is not part of the list of components")}else G.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(e,t,o,r){return x(I.x,e,B),x(I.y,t,k),x(I.z,o,D),y(B,k,B),y(B,D,B),U(this,B,r),this}offset(e,t,o,r){return this.loaded?(W[0]=e,W[1]=t,W[2]=o,R(this,W,r),this):(G.error("offset()","Mesh must be loaded before applying operations"),this)}scale(e,t){return this.loaded?(T(this,e,t),this):(G.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(e,t){return this.loaded?(M(this,e,t),this):(G.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(e){return s(this.external)&&this.addResolvingPromise(P(this,this.external.source,e)),Promise.resolve(this)}clone(){const e=this.components?new Map:null,t=this.components?new Map:null,o={components:this.components?this.components.map((o=>o.cloneWithDeduplication(e,t))):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:s(this.transform)?this.transform.clone():null,external:s(this.external)?{source:this.external.source,extent:s(this.external.extent)?this.external.extent.clone():null}:null};return new E(o)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const{toBinaryGLTF:t}=await import("./support/meshUtils/exporters/gltf/gltfexport.js");return t(this,e)}static createBox(e,t){if(!(e instanceof f))return G.error(".createBox()","expected location to be a Point instance"),null;const o=new E(A(F(),e,t));return t&&t.imageFace&&"all"!==t.imageFace?z(o,t.imageFace):o}static createSphere(e,t){return e instanceof f?new E(A(C(t&&t.densificationFactor||0),e,t)):(G.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(e,t){return e instanceof f?new E(A(O(t&&t.densificationFactor||0),e,t)):(G.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(e,t){return e instanceof f?new E(A(L(t&&t.facing||"up"),e,t)):(G.error(".createPlane()","expected location to be a Point instance"),null)}static createFromPolygon(e,t){if(!(e instanceof d))return G.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const o=w(e);return new E({vertexAttributes:new v({position:o.position}),components:[new b({faces:o.faces,shading:"flat",material:t&&t.material||null})],spatialReference:e.spatialReference})}static async createFromGLTF(e,o,r){if(!(e instanceof f))throw G.error(".createfromGLTF()","expected location to be a Point instance"),new t("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:n}=await a(import("./support/meshUtils/loadGLTFMesh.js"),r);return new E(await n(e,o,r))}static createWithExternalSource(e,t,o){var r,n,s;const i=null!=(r=null==o?void 0:o.extent)?r:null,a=null!=(n=null==o?void 0:o.transform.clone())?n:new j;a.origin=[e.x,e.y,null!=(s=e.z)?s:0];const l=e.spatialReference;return new E({external:{source:t,extent:i},transform:a,spatialReference:l})}static createIncomplete(e,o){var r,n;const s=null!=(r=null==o?void 0:o.transform.clone())?r:new j;s.origin=[e.x,e.y,null!=(n=e.z)?n:0];const i=e.spatialReference,a=new E({transform:s,spatialReference:i});return a.addResolvingPromise(Promise.reject(new t("mesh-incomplete","Mesh resources are not complete"))),a}};e([l({type:[b],json:{write:!0}})],S.prototype,"components",void 0),e([l({type:j,json:{write:!0}})],S.prototype,"transform",void 0),e([l({constructOnly:!0})],S.prototype,"external",void 0),e([l({readOnly:!0})],S.prototype,"hasExtent",null),e([l({readOnly:!0})],S.prototype,"boundingInfo",null),e([l({readOnly:!0})],S.prototype,"anchor",null),e([l({readOnly:!0})],S.prototype,"origin",null),e([l({readOnly:!0,json:{read:!1}})],S.prototype,"extent",null),e([l({readOnly:!0,json:{read:!1,write:!0,default:!0}})],S.prototype,"hasZ",void 0),e([l({readOnly:!0,json:{read:!1,write:!0,default:!1}})],S.prototype,"hasM",void 0),e([l({type:v,nonNullable:!0,json:{write:!0}})],S.prototype,"vertexAttributes",void 0),S=E=e([p("esri.geometry.Mesh")],S);const I={x:c(1,0,0),y:c(0,1,0),z:c(0,0,1)},B=g(),k=g(),D=g(),W=m();var Z=S;export default Z;
