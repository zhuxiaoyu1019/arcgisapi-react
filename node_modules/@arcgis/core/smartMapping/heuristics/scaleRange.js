/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import{isSome as a}from"../../core/maybe.js";import{getScaleForResolution as t}from"../../geometry/support/scaleUtils.js";import n from"../statistics/spatialStatistics.js";import{createLayerAdapter as r,getLayerTypeLabels as s}from"../support/adapters/support/layerUtils.js";const i=500,l=1e8,o=1280,c=12,m=30,p=15;async function u(t){const{view:n,sampleSize:l}=t;if(!(t&&n&&t.layer))throw new e("scale-range:missing-parameters","'view' and 'layer' parameters are required");const o=[0,2,3,1,5],{layer:c,...m}=t,p=r(c,o),u={layerAdapter:p,...m};if(u.sampleSize=l||i,!p)throw new e("scale-range:invalid-parameters","'layer' must be one of these types: "+s(o).join(", "));await n.when();const f=a(u.signal)?{signal:u.signal}:null;return await p.load(f),u}function f(e,a){const t=c,n=o/4,r=m,s=o/4,i=p,l=o/2;let u=null,f=null,y=null,g=null;switch(e){case"point":case"multipoint":{const e=a;u=e.avgMinDistance,f=t,y=e.minDistance,g=n;break}case"polyline":{const e=a;u=e.avgLength,f=r,y=e.minLength,g=s;break}case"polygon":{const e=a;u=e.avgSize,f=i,y=e.minSize,g=l;break}}return{resolutionForMinScale:u>0?u/f:null,resolutionForMaxScale:y>0?y/g:null}}function y(e,a,n){const r=f(e.geometryType,a);return{minScale:t(r.resolutionForMinScale,n.spatialReference),maxScale:t(r.resolutionForMaxScale,n.spatialReference)}}function g(e,a,t=!0){if(e.constraints&&"effectiveLODs"in e.constraints){const n=e.constraints.effectiveLODs,r=t?n:n.slice(0).reverse();let s=null;for(const e of r)if(!(t?e.scale>a:e.scale<a)){s=e;break}return s}}function S(a,t,n,r){const{view:s,snapToLOD:i,layerAdapter:o}=a;if(i){const e=g(s,t),a=g(s,n,!1);t=e?e.scale:t,n=a?a.scale:n}if(t<n)throw new e("scale-range:invalid","calculated minScale is less than maxScale.");return n>t/2&&(n=Math.floor(n/2)),t>l&&(t=0),"polygon"!==o.geometryType&&(n=0),{minScale:Math.ceil(t),maxScale:Math.floor(n),spatialStatistics:r}}async function w(e){const a=await u(e),{view:t,sampleSize:r,layerAdapter:s,signal:i}=a,l=await s.getSampleFeatures({view:t,sampleSize:r,returnGeometry:!0,signal:i}),o=await n({features:l,geometryType:s.geometryType}),{minScale:c,maxScale:m}=y(s,o,t);return S(a,c,m,o)}export default w;
