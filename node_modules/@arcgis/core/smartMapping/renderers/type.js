/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import"../../renderers/PointCloudClassBreaksRenderer.js";import"../../renderers/PointCloudRenderer.js";import"../../renderers/PointCloudRGBRenderer.js";import"../../renderers/PointCloudStretchRenderer.js";import e from"../../renderers/PointCloudUniqueValueRenderer.js";import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import r from"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import s from"../../core/Error.js";import{clone as l}from"../../core/lang.js";import{isSome as o}from"../../core/maybe.js";import{fetchMessageBundle as i}from"../../intl/messages.js";import{LegendOptions as t}from"../../renderers/support/LegendOptions.js";import{createUniqueValueLabel as n,calculateDateFormatInterval as a}from"../../renderers/support/utils.js";import p from"../heuristics/outline.js";import u from"../heuristics/sizeRange.js";import{getPointSizeAlgorithm as m,verifyBasicFieldValidity as d,isValidPointSize as c,createColors as y,getSymbolSizeFromScheme as f,getSymbolOutlineFromScheme as b,createSymbol as h,getBasemapInfo as v}from"./support/utils.js";import g from"../statistics/uniqueValues.js";import{getFieldsList as w}from"../support/utils.js";import{createLayerAdapter as T,getLayerTypeLabels as E}from"../support/adapters/support/layerUtils.js";import{c as j,g as x}from"../../chunks/type.js";const I="date";async function V(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new s("type-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new s("type-renderer:missing-parameters","View is required when 'valueExpression' is specified");const r={...e};r.symbolType=r.symbolType||"2d",r.numTypes=null==r.numTypes?10:r.numTypes,r.defaultSymbolEnabled=null==r.defaultSymbolEnabled||r.defaultSymbolEnabled,r.sortBy=null==r.sortBy?"count":r.sortBy,r.sortEnabled=null==r.sortEnabled||r.sortEnabled,r.statistics=l(r.statistics);const i=[0,2,1,3,5],t=T(r.layer,i);if(r.layer=t,!t)throw new s("type-renderer:invalid-parameters","'layer' must be one of these types: "+E(i).join(", "));const n=o(r.signal)?{signal:r.signal}:null;await t.load(n);const a=t.geometryType;if(r.outlineOptimizationEnabled="polygon"===a&&r.outlineOptimizationEnabled,r.sizeOptimizationEnabled=("point"===a||"multipoint"===a||"polyline"===a)&&r.sizeOptimizationEnabled,"mesh"===a)r.symbolType="3d-volumetric",r.colorMixMode=r.colorMixMode||"replace",r.edgesType=r.edgesType||"none";else{if("3d-volumetric-uniform"===r.symbolType&&"point"!==a)throw new s("type-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(r.symbolType.indexOf("3d-volumetric")>-1&&(!r.view||"3d"!==r.view.type))throw new s("type-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const p=await w({field:r.field,valueExpression:r.valueExpression}),u=d(t,p,"type-renderer:invalid-parameters");if(u)throw u;return r}async function z(e){if(!(e&&e.layer&&e.field))throw new s("type-point-cloud-class-renderer:missing-parameters","'layer' and 'field' parameters are required");const r={...e};r.statistics=l(r.statistics);const i=[4],t=T(r.layer,i);if(r.layer=t,r.density=r.density||25,r.size=r.size||"100%",!c(r.size))throw new s("type-point-cloud-class-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");if(!t)throw new s("type-point-cloud-class-renderer:invalid-parameters","'layer' must be one of these types: "+E(i).join(", "));const n=o(r.signal)?{signal:r.signal}:null;await t.load(n);const a=await w({field:r.field}),p=d(t,a,"type-point-cloud-class-renderer:invalid-parameters");if(p)throw p;return r}async function M(e){let r=e.typeScheme,s=null,l=null;const i=await v(e.basemap,e.view);if(s=o(i.basemapId)?i.basemapId:null,l=o(i.basemapTheme)?i.basemapTheme:null,r)return{scheme:j(r),basemapId:s,basemapTheme:l};const t=x({basemap:s,basemapTheme:l,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return t&&(r=t.primaryScheme,s=t.basemapId,l=t.basemapTheme),{scheme:r,basemapId:s,basemapTheme:l}}function S(e,r){let s;return s=e.label<r.label?-1:e.label>r.label?1:0,s}function q(e,r){let s;return s=e.value<r.value?-1:e.value>r.value?1:0,s}function R(e,r){let s=r.count-e.count;return 0===s&&(s=S(e,r)),s}function O(e,r){let s=r.count-e.count;return 0===s&&(s=q(e,r)),s}function C(e,r,s){let l;"count"===r?(l=O,s&&s.codedValues&&(l=R)):"value"===r&&(l=q,s&&s.codedValues&&(l=S)),l&&e.sort(l)}async function B(e,s,l,o){const p=await i("esri/smartMapping/t9n/smartMapping"),u=e.uniqueValueInfos,m=s.layer,d=s.field,c=d?m.getField(d):null,v=c?m.getFieldDomain(c.name):null,g=-1===s.numTypes?u.length:s.numTypes,w=m.geometryType,T=await M({basemap:s.basemap,geometryType:w,typeScheme:s.typeScheme,worldScale:s.symbolType.indexOf("3d-volumetric")>-1,view:s.view}),E=T.scheme,x=new r({field:d});let V,z=-1;const S={value:null,domain:v,fieldInfo:c};if(u.forEach(((e,r)=>{S.value=e.value,e.label=n(S),null===e.value&&(z=r)})),z>-1&&(V=u.splice(z,1)[0]),!1!==s.sortEnabled&&C(u,s.sortBy,v),c&&c.type===I){const e=u.filter(((e,r)=>r<g)).map((e=>e.value));S.dateFormatInterval=a(e)}const q=l&&l.opacity;let R=y(E.colors,u.length);const O=f(E,w),B=b(E,w,q);u.forEach(((e,r)=>{S.value=e.value,e.label=n(S),e.symbol=h(w,{type:s.symbolType,color:R[r],size:O,outline:B,meshInfo:{colorMixMode:s.colorMixMode,edgesType:s.edgesType}})})),s.valueExpression&&(x.valueExpression=s.valueExpression,x.valueExpressionTitle=s.valueExpressionTitle),s.legendOptions&&(x.legendOptions=new t(s.legendOptions)),R=y(E.colors,g);for(let r=0;r<g;r++){const e=u[r];e&&x.addUniqueValueInfo({value:e.value,label:e.label,symbol:h(w,{type:s.symbolType,color:R[r],size:O,outline:B,meshInfo:{colorMixMode:s.colorMixMode,edgesType:s.edgesType}})})}s.defaultSymbolEnabled&&(x.defaultSymbol=h(w,{type:s.symbolType,color:E.noDataColor,size:O,outline:B,meshInfo:{colorMixMode:s.colorMixMode,edgesType:s.edgesType}}),x.defaultLabel=p.other),V&&(V.symbol=h(w,{type:s.symbolType,color:E.noDataColor,size:O,outline:B,meshInfo:{colorMixMode:s.colorMixMode,edgesType:s.edgesType}}),u.push(V));const P=[],U=x.uniqueValueInfos.length===u.length?-1:x.uniqueValueInfos.length;if(U>-1)for(let r=U;r<u.length;r++)P.push({...u[r]});return l&&l.visualVariables&&l.visualVariables.length&&(x.visualVariables=l.visualVariables.map((e=>e.clone()))),o&&o.minSize&&(x.visualVariables?x.visualVariables.push(o.minSize):x.visualVariables=[o.minSize]),{renderer:x,uniqueValueInfos:u,excludedUniqueValueInfos:P,typeScheme:j(E),basemapId:T.basemapId,basemapTheme:T.basemapTheme}}async function P(e,r){const s=e.uniqueValueInfos,l=await M({basemap:"gray",theme:"point-cloud-class",geometryType:"point",typeScheme:r}),o=l&&l.scheme,i="point-cloud-class"===o.theme,t=i?o.colors:y(o.colors,s.length);return C(s,"value"),s.map(((e,r)=>{const s=e.value;let l=null;return i?(l=t[s],l||(l=t[t.length-1])):l=t[r],{values:[s],color:l,label:e.label}}))}async function U(e){const r=await V(e),{layer:s,view:l,signal:o}=r,i={layer:s,field:r.field,valueExpression:r.valueExpression,returnAllCodedValues:r.returnAllCodedValues,view:l,signal:o},[t,n,a]=await Promise.all([null!=r.statistics?r.statistics:g(i),r.outlineOptimizationEnabled?p({layer:s,view:l,signal:o}):null,r.sizeOptimizationEnabled?u({layer:s,view:l,signal:o}):null]);return B(t,r,n,a)}async function D(r){const s=await z(r),l=null!=s.statistics?s.statistics:await g({layer:s.layer,field:s.field,signal:s.signal});return{renderer:new e({field:s.field,pointsPerInch:s.density,pointSizeAlgorithm:m(s.size),colorUniqueValueInfos:await P(l,s.typeScheme)})}}export{D as createPCClassRenderer,U as createRenderer};
