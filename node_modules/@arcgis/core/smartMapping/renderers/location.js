/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/Renderer.js";import e from"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import r from"../../core/Error.js";import{isSome as i}from"../../core/maybe.js";import o from"../heuristics/outline.js";import a from"../heuristics/sizeRange.js";import{createSymbol as s,getSymbolSizeFromScheme as n,getSymbolOutlineFromScheme as t,getBasemapInfo as l}from"./support/utils.js";import{createLayerAdapter as m,getLayerTypeLabels as p}from"../support/adapters/support/layerUtils.js";import{c as d,g as c}from"../../chunks/location.js";async function u(e){if(!e||!e.layer)throw new r("location-renderer:missing-parameters","'layer' parameter is required");const o={...e};o.symbolType=o.symbolType||"2d";const a=[0,2,1,3,5],s=m(o.layer,a);if(o.layer=s,!s)throw new r("location-renderer:invalid-parameters","'layer' must be one of these types: "+p(a).join(", "));const n=i(o.signal)?{signal:o.signal}:null;await s.load(n);const t=s.geometryType;if(o.outlineOptimizationEnabled="polygon"===t&&o.outlineOptimizationEnabled,o.sizeOptimizationEnabled=("point"===t||"multipoint"===t||"polyline"===t)&&o.sizeOptimizationEnabled,"mesh"===t)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else{if("3d-volumetric-uniform"===o.symbolType&&"point"!==t)throw new r("location-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.indexOf("3d-volumetric")>-1&&(!o.view||"3d"!==o.view.type))throw new r("location-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}return o}async function y(e,r){let o=e.locationScheme,a=null,s=null;const n=await l(e.basemap,e.view);if(a=i(n.basemapId)?n.basemapId:null,s=i(n.basemapTheme)?n.basemapTheme:null,o)return{scheme:d(o),basemapId:a,basemapTheme:s};const t=c({basemap:a,basemapTheme:s,geometryType:r,worldScale:e.symbolType.indexOf("3d-volumetric")>-1,view:e.view});return t&&(o=t.primaryScheme,a=t.basemapId,s=t.basemapTheme),{scheme:o,basemapId:a,basemapTheme:s}}async function b(i){const l=await u(i),m=l.layer.geometryType,p=await y(l,m),c=p.scheme;if(!c)throw new r("location-renderer:insufficient-info","Unable to find location scheme");const{view:b,layer:f,signal:h}=l,[w,v]=await Promise.all([l.outlineOptimizationEnabled?o({view:b,layer:f,signal:h}):null,l.sizeOptimizationEnabled?a({view:b,layer:f,signal:h}):null]),T=w&&w.opacity,g=new e({symbol:s(m,{type:l.symbolType,color:c.color,size:n(c,m),outline:t(c,m,T),meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}})});return w&&w.visualVariables&&w.visualVariables.length&&(g.visualVariables=w.visualVariables.map((e=>e.clone()))),v&&v.minSize&&(g.visualVariables?g.visualVariables.push(v.minSize):g.visualVariables=[v.minSize]),{renderer:g,locationScheme:d(c),basemapId:p.basemapId,basemapTheme:p.basemapTheme}}export{b as createRenderer};
