/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{splitIntoChunks as e}from"../../../core/arrayUtils.js";import{lerp as t}from"../../../core/mathUtils.js";import{isNone as r,none as o,forEachSome as n}from"../../../core/maybe.js";import{throwIfAborted as s,after as i,isAbortError as l,throwIfNotAbortError as a}from"../../../core/promiseUtils.js";import c from"../../../geometry/Multipoint.js";import{QueueProcessor as p}from"../../../views/support/QueueProcessor.js";import{TaskPriority as u}from"../../../views/support/Scheduler.js";import{DELAY_AFTER_PREVIEW_MILLIS as m,DEFAULT_ELEVATION_PROFILE_QUERY_OPTIONS as f,ERROR_RESULT as d}from"./constants.js";import{isValidInputPath as h,countPoints as y,densifyPath as w}from"./geometryUtils.js";import{ProfileGenerationError as g}from"./ProfileGenerationError.js";import{getStatistics as v}from"./statisticsUtils.js";import{breadthFirstBinaryPartitioning as P}from"../../support/traversalUtils.js";async function*Z(e,t){var l;const{view:a,geometry:c,elevationInfo:p,providers:u,options:f}=e;if(r(c)||!h(c))throw new g("invalid-geometry");const d=a.spatialReference,v=u.length;if(0===v)return o;const P=Math.round(f.maxTotalSamples/v);if(y(c)>P)throw new g("too-complex");const Z=await w(c,p,a,d,f,P,t);let R=0;const x=new Array(v),O=new Array(v);for(let r=0;r<v;r++){const o=A(Z);x[r]=o,R+=o.samples.length;const n={...e,provider:u[r],result:o,densificationResult:Z};O[r]=j(n,t)[Symbol.iterator]()}if(R>f.maxTotalSamples)throw new g("too-complex");const S=await Promise.all(O.map((e=>{const t=e.next();return!0===t.done?Promise.resolve(null):t.value})));s(t);for(let r=0;r<v;r++)x[r]=S[r];yield x,await i(null!=(l=e.delayAfterPreview)?l:m,null,t.signal);const q=[];try{let e;do{e=!1;for(let t=0;t<v;t++){const r=O[t].next();!1===r.done&&(q.push({resultPromise:r.value,index:t}),e=!0)}}while(e)}finally{O.forEach((e=>null==e.return?void 0:e.return()))}for(const{resultPromise:r,index:o}of q)x[o]=await r,s(t),yield x;n(x,(e=>{e.progress=1})),yield x}function*j(t,r){const{densificationResult:o}=t,n={...t,abortOptions:r,densificationResult:o},s=P(0,n.result.samples.length),i=s.slice(0,n.provider.numSamplesForPreview);yield R(n,i,!0);const l=e(s,n.provider.numSamplesPerChunk);for(const e of l)yield R(n,e,!1)}async function R({densificationResult:e,result:t,provider:r,queue:o,abortOptions:n,cache:s},i,a){const{densifiedPath:p,pathLength:u}=e,m=t.spatialReference,{samples:h}=t,y=new Array(i.length);for(let l=0;l<i.length;l++){const e=h[i[l]];y[l]=e.coordinate}try{return await o.push({geometry:new c({spatialReference:m,points:y,hasZ:p.hasZ}),provider:r,indices:i,preview:a,result:t,queryOptions:{...f,minDemResolution:a?Math.round(u/r.numSamplesForPreview):Math.round(u/h.length),cache:s}},n),{...t}}catch(w){return l(w)?null:d}}function x(e){return new p({priority:u.ELEVATION_PROFILE,concurrency:1,scheduler:e,process:async e=>{s(e.queryOptions);try{await O(e)}catch(t){a(t)}}})}async function O({geometry:e,provider:t,indices:r,preview:o,result:n,queryOptions:s}){if(0===r.length)return;const i=(await b(t,e,s)).geometry,{hasZ:l,points:a}=i,c=s.noDataValue,{samples:p}=n;for(let u=0;u<r.length;u++){const e=p[r[u]];if(e.isHole)continue;const t=l?a[u][2]:null;null===t||t===c?e.sampledZ=null:(n.hasZ=!0,e.sampledZ=t),e.sampled=!0}S(p),n.progress=o?0:n.progress+r.length/p.length,n.statistics=v(n.samples,n.spatialReference)}function S(e){const t=e.length-1;let r=0;for(let o=1;o<=t;o++){(e[o].sampled||o===t)&&(q(e,r,o),r=o)}}function q(e,o,n){if(n-o==1)return;const s=e[o],i=s.sampledZ,l=e[n],a=l.sampledZ;if(r(i)||r(a)){for(let t=o+1;t<n;t++)e[t].sampledZ=null;return}const c=s.distance,p=l.distance-c;for(let r=o+1;r<n;r++){const o=e[r],n=(o.distance-c)/p;o.sampledZ=t(i,a,n)}}function A({densifiedPath:e,distances:t}){const r=e.spatialReference,o=e.paths,n=o.length,s=2*(n-1),i=o.reduce(((e,t)=>e+t.length),0)+s,l=new Array(i);let a=0,c=null,p=0;const u=(e,t,r,o)=>{l[a++]=U(e,r),l[a++]=U(t,o)};for(let m=0;m<n;m++){const e=o[m],r=t[m];for(let t=0;t<e.length;t++){const o=e[t],n=r[t];c&&0===t&&u(c,o,p,n),l[a++]=E(o,n),c=o,p=n}}return{progress:0,samples:l,hasZ:!1,statistics:null,spatialReference:r}}function E(e,t){return{coordinate:e,distance:t,sampledZ:null,sampled:!1,isHole:!1}}function U(e,t){return{coordinate:e,distance:t,sampledZ:null,sampled:!0,isHole:!0}}async function b(e,t,r){try{return await e.queryElevation(t,r)}catch(o){throw new g("elevation-query-error")}}export{x as createProfileQueue,j as generateProfile,Z as generateProfiles,S as interpolateElevations};
