/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import t from"../../../request.js";import r from"../../../core/Error.js";import{JSONSupport as o}from"../../../core/JSONSupport.js";import n from"../../../core/Logger.js";import{isSome as i,unwrap as s}from"../../../core/maybe.js";import{EsriPromiseMixin as a}from"../../../core/Promise.js";import{createAbortController as l,onAbort as c}from"../../../core/promiseUtils.js";import{property as f}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as u}from"../../../core/accessorSupport/decorators/subclass.js";import{sanitizeUrl as m}from"../arcgisLayerUrl.js";import{url as h}from"../commonProperties.js";import d from"../RasterStorageInfo.js";import p from"../TileInfo.js";import{getRasterId as g,getBlock as x,putBlock as y,deleteBlock as I,decreaseRefCount as w}from"./RawBlockCache.js";import{decode as k}from"../rasterFormats/RasterCodec.js";import{mosaic as v,approximateTransform as R}from"../rasterFunctions/pixelUtils.js";import{load as b,projectPoint as C,snapPyramid as M,snapExtent as T,getWorldWrapCount as P,projectResolution as B,projectExtent as S,getProjectionOffsetGrid as j,getRasterDatasetAlignmentInfo as F}from"../rasterFunctions/rasterProjectionHelper.js";import L from"../../../geometry/Point.js";import D from"../../../geometry/Extent.js";let H=class extends(a(o)){constructor(){super(...arguments),this.rasterJobHandler=null,this.datasetName=null,this.datasetFormat=null,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const e=b();this.addResolvingPromise(e),await this.when()}normalizeCtorArgs(e){return e&&e.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:p.create(),...e.ioConfig}}),e}set url(e){this._set("url",m(e,n.getLogger(this.declaredClass)))}async open(e){throw new r("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(e,t,r,o={}){var n;const{tileInfo:s}=o,a=s.lodAt(e),l=this.getTileExtent({x:a.resolution,y:a.resolution},t,r,s.origin,s.spatialReference,s.size);return null!=(n=o.multidimensionalDefinition)&&n.length&&i(this.rasterInfo.multidimensionalInfo)&&null==o.sliceId&&(o={...o,sliceId:this.getSliceIndex(o.multidimensionalDefinition)||0}),this.fetchPixels(l,s.size[0],s.size[1],o)}async identify(e,t={}){const{spatialReference:r,extent:o}=this.rasterInfo,{datumTransformation:n}=t;let s=C(e,r,n);if(!o.intersects(s))return{location:s,value:null};if(i(this.rasterInfo.transform)){const e=this.rasterInfo.transform.inverseTransform(s);if(!this.rasterInfo.nativeExtent.intersects(e))return{location:e,value:null};s=e}let a=0;if(t.srcResolution){a=M(t.srcResolution,this.rasterInfo,this.ioConfig.sampling).pyramidLevel}else if(a=await this.computeBestPyramidLevelForLocation(e,t),null==a)return{location:s,value:null};const l=this.identifyPixelLocation(s,a,null);if(null===l)return{location:s,value:null};const{row:c,col:f,rowOffset:u,colOffset:m}=l,h=g(this.url,t.sliceId),d=`${a}/${c}/${f}`;let p=x(h,null,d);i(p)||(p=this.fetchRawTile(a,c,f,t),y(h,null,d,p));const I=await p;if(!(I&&I.pixels&&I.pixels.length>0))return{location:s,value:null};const w=u*this.rasterInfo.storageInfo.blockHeight+m;return{location:s,value:!I.mask||I.mask[w]?I.pixels.map((e=>e[w])):null,pyramidLevel:a}}async fetchPixels(e,t,r,o={}){e=T(e);const n=P(e),i=this.rasterInfo.spatialReference,a=!e.spatialReference.equals(i),{datumTransformation:l}=o,c=new L({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/r,spatialReference:e.spatialReference}),f=o.srcResolution||(a?B(c,i,e,l):c);if(!f)return null;const{pyramidLevel:u,pyramidResolution:m,excessiveReading:h}=M(f,this.rasterInfo,this.ioConfig.sampling);if(h)return null;const d=this.rasterInfo.storageInfo;let p=a?S(e,i,l):e;const g=s(this.rasterInfo.transform);if(g&&(p=g.inverseTransform(p)),null==p)return null;const x={x:Math.floor((p.xmin-d.origin.x)/m.x+.1),y:Math.floor((d.origin.y-p.ymax)/m.y+.1)},y=Math.ceil((p.xmax-p.xmin)/m.x-.1),I=Math.ceil((p.ymax-p.ymin)/m.y-.1);if(y/t>8||I/r>8||n>=2)return null;const w=await this.fetchRawPixels(u,x,{width:y,height:I,wrapCount:n},o);if(!w)return null;const k=u>0?d.pyramidBlockWidth:d.blockWidth,b=u>0?d.pyramidBlockHeight:d.blockHeight;if(!a&&1===w.pixelBlocks.length&&k===t&&b===r&&f.x===c.x&&f.y===c.y)return{extent:e,srcExtent:p,pixelBlock:w.pixelBlocks[0]};const C=j(e,w.extent,c,l,g,n>0);let F;const D=!o.requestRawData,H={rows:C.spacing[0],cols:C.spacing[1]},_=s(this._getRasterTileAlignmentInfo(u,w.extent.xmin)),{pixelBlocks:A,mosaicSize:W,isPartiallyFilled:z}=w;if(this.rasterJobHandler)F=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:A,srcMosaicSize:W,destDimension:D?{width:t,height:r}:null,coefs:D?C.coefficients:null,sampleSpacing:D?H:null,interpolation:o.interpolation,alignmentInfo:_},o);else{const e=v(A,W,null,null,_);F=D?R(e,{width:t,height:r},C.coefficients,H,o.interpolation):e}return o.requestRawData?{srcExtent:p,pixelBlock:F,transformGrid:C,extent:e,isPartiallyFilled:z}:{srcExtent:p,extent:e,pixelBlock:F}}async fetchRawPixels(e,t,r,o){const{origin:n,blockBoundary:i}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:l}=this.getBlockWidthHeight(e);let{x:c,y:f}=t,{width:u,height:m,wrapCount:h}=r;const d=s(this._getRasterTileAlignmentInfo(e,0));o.buffer&&(c-=o.buffer.cols,f-=o.buffer.rows,u+=2*o.buffer.cols,m+=2*o.buffer.rows);const p=Math.floor(c/a),g=Math.floor(f/l),x=Math.floor((c+u-1)/a),y=Math.floor((f+m-1)/l),I=i[e];if(!I)return null;const{minRow:w,minCol:k,maxCol:v,maxRow:R}=I;if(y<w||x<k||g>R||p>v)return null;const b=[];let C,M=!1;for(let s=g;s<=y;s++)for(let t=p;t<=x;t++){const r=0===h||null==d||t<d.worldColumnCountFromOrigin?t:t%d.worldColumnCountFromOrigin-d.originColumnOffset;s>=w&&r>=k&&R>=s&&v>=r?(C=this._fetchRawTile(e,s,r,o),this.ioConfig.allowPartialFill&&(C=new Promise((e=>{C.then((t=>e(t))).catch((()=>{M=!0,e(null)}))}))),b.push(C)):b.push(null)}if(0===b.length)return null;const T=await Promise.all(b),P={height:(y-g+1)*l,width:(x-p+1)*a},{spatialReference:B}=this.rasterInfo,S=this.getPyramidPixelSize(e),{x:j,y:F}=S;return{extent:new D({xmin:n.x+p*a*j,xmax:n.x+(x+1)*a*j,ymin:n.y-(y+1)*l*F,ymax:n.y-g*l*F,spatialReference:B}),pixelBlocks:T,mosaicSize:P,isPartiallyFilled:M}}async fetchRawTile(e,t,o,n){throw new r("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return S(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?k(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,r,o){var n,i;const{customFetchParameters:s}=this.ioConfig,{range:a,query:l,headers:c}=r;o=null!=(n=null!=(i=o)?i:r.retryCount)?n:this.ioConfig.retryCount;const f=a?{Range:`bytes=${a.from}-${a.to}`}:null;try{return await t(e,{...r,query:{...l,...s},headers:{...c,...f}})}catch(u){if(o>0)return o--,this.request(e,r,o);throw u}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;if(!i(t)||null==e||!e.length)return null;let r=0;const o=e[0].variableName;for(let n=0;n<t.variables.length;n++){const i=t.variables[n],s=i.dimensions;if(i.name!==o){r+=s.map((e=>this._getDimensionValuesCount(e))).reduce(((e,t)=>e+t));break}const a=s.map((e=>this._getDimensionValuesCount(e))),l=s.length;for(let t=0;t<l;t++){const o=e.filter((e=>e.dimensionName===s[t].name))[0];if(null==o)return null;const n=Array.isArray(o.values[0])?o.values[0][0]:o.values[0],i=this._getIndexFromDimensions(n,s[t]);if(-1===i)return null;a.shift(),r+=t===l-1?i:i*a.reduce(((e,t)=>e+t))}}return r}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:r,pixelSize:o}=this.rasterInfo;if(!e.tileInfo){const n=[],i=e.maximumPyramidLevel||0;let s=Math.max(o.x,o.y),a=1/.0254*96*s;for(let e=0;e<=i;e++)n.push({level:i-e,resolution:s,scale:a}),s*=2,a*=2;const l=new L({x:r.xmin,y:r.ymax,spatialReference:t});e.tileInfo=new p({origin:l,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:n}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,r=512,o){const{width:n,height:i,nativeExtent:s,pixelSize:a,spatialReference:l}=e,c=new L({x:s.xmin,y:s.ymax,spatialReference:l});null==o&&(o=Math.max(0,Math.round(Math.log(Math.max(n,i))/Math.LN2-8)));const f=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[a],o);e.storageInfo=new d({blockWidth:t,blockHeight:r,pyramidBlockWidth:t,pyramidBlockHeight:r,origin:c,firstPyramidLevel:1,maximumPyramidLevel:o,blockBoundary:f})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,r,o,n,i=0,s=2){if(1===n.length&&i>0){n=[...n];let{x:e,y:t}=n[0];for(let r=0;r<i;r++)e*=s,t*=s,n.push({x:e,y:t})}const a=[],{x:l,y:c}=o;for(let f=0;f<n.length;f++){const{x:o,y:i}=n[f];a.push({minCol:Math.floor((e.xmin-l+.1*o)/t/o),maxCol:Math.floor((e.xmax-l-.1*o)/t/o),minRow:Math.floor((c-e.ymax+.1*i)/r/i),maxRow:Math.floor((c-e.ymin-.1*i)/r/i)})}return a}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:o}=this.rasterInfo.storageInfo;if(0===e)return t;if(i(r)&&r.length)return r[e-1];const n=o**e;return{x:t.x*n,y:t.y*n}}identifyPixelLocation(e,t,r){const{spatialReference:o,nativeExtent:n}=this.rasterInfo,{blockWidth:i,blockHeight:s,maximumPyramidLevel:a,origin:l}=this.rasterInfo.storageInfo,c=C(e,o,r);if(!n.intersects(c))return null;if(t<0||t>a)return null;const f=this.getPyramidPixelSize(t),{x:u,y:m}=f,h=(l.y-c.y)/m/s,d=(c.x-l.x)/u/i,p=Math.min(s-1,Math.floor((h-Math.floor(h))*s)),g=Math.min(i-1,Math.floor((d-Math.floor(d))*i));return{pyramidLevel:t,row:Math.floor(h),col:Math.floor(d),rowOffset:p,colOffset:g,srcLocation:c}}getTileExtent(e,t,r,o,n,i){const[s,a]=i,l=o.x+r*s*e.x,c=l+s*e.x,f=o.y-t*a*e.y,u=f-a*e.y;return new D({xmin:l,xmax:c,ymin:u,ymax:f,spatialReference:n})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,r){const o=this.rasterInfo.storageInfo.blockBoundary[e];return!o||o.maxRow<t||o.maxCol<r||o.minRow>t||o.minCol>r}_fetchRawTile(e,t,r,o){const n=this.rasterInfo.storageInfo.blockBoundary[e];if(!n)return Promise.resolve(null);const{minRow:s,minCol:a,maxCol:f,maxRow:u}=n;if(t<s||r<a||t>u||r>f)return Promise.resolve(null);const m=g(this.url,o.sliceId),h=`${e}/${t}/${r}`;let d=x(m,o.registryId,h);if(!i(d)){const n=l();d=this.fetchRawTile(e,t,r,{...o,signal:n.signal}),y(m,o.registryId,h,d,n),d.catch((()=>{I(m,o.registryId,h)}))}return o.signal&&c(o,(()=>{w(m,o.registryId,h)})),d}_getIndexFromDimensions(e,t){const{extent:r,interval:o,unit:n,values:i}=t;if(null!=i&&i.length)return Array.isArray(i[0])?i.findIndex((t=>t[0]<=e&&t[1]>=e)):i.indexOf(e);if(e>r[1])return-1;const s=r[0];let a=-1;if("ISO8601"===n){var l;switch((null==(l=t.intervalUnit)?void 0:l.toLowerCase())||"seconds"){case"seconds":a=Math.round((e-s)/1e3/o);break;case"minutes":a=Math.round((e-s)/6e4/o);break;case"hours":a=Math.round((e-s)/36e5/o);break;case"days":a=Math.round((e-s)/864e5/o);break;case"years":a=Math.round((new Date(e).getUTCFullYear()-new Date(s).getUTCFullYear())/o);break;case"decades":a=Math.round((new Date(e).getUTCFullYear()-new Date(s).getUTCFullYear())/10/o)}return a}return Math.round((e-s)/o)}_getDimensionValuesCount(e){const{extent:t,interval:r,unit:o,values:n}=e;let i=(null==n?void 0:n.length)||0;if(i)return i;const s=t[0];if(0===i&&"ISO8601"===o){var a;switch((null==(a=e.intervalUnit)?void 0:a.toLowerCase())||"seconds"){case"seconds":i=Math.round((t[1]-t[0])/1e3/r);break;case"minutes":i=Math.round((t[1]-t[0])/6e4/r);break;case"hours":i=Math.round((t[1]-t[0])/36e5/r);break;case"days":i=Math.round((t[1]-t[0])/864e5/r);break;case"years":i=Math.round((new Date(t[1]).getUTCFullYear()-new Date(s).getUTCFullYear())/r);break;case"decades":i=Math.round((new Date(t[1]).getUTCFullYear()-new Date(s).getUTCFullYear())/10/r)}return i}return Math.round((t[1]-t[0])/r)}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=F(this.rasterInfo)),i(this._rasterTileAlighmentInfo.pyramidsInfo)?{startX:t,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[e]}:null}};e([f()],H.prototype,"_rasterTileAlighmentInfo",void 0),e([f(h)],H.prototype,"url",null),e([f({type:String,json:{write:!0}})],H.prototype,"datasetName",void 0),e([f({type:String,json:{write:!0}})],H.prototype,"datasetFormat",void 0),e([f()],H.prototype,"rasterInfo",void 0),e([f()],H.prototype,"ioConfig",void 0),e([f()],H.prototype,"sourceJSON",void 0),H=e([u("esri.layers.support.rasterDatasets.BaseRaster")],H);var _=H;export default _;
