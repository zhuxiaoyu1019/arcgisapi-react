/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import e from"../../../core/Error.js";import{unwrap as r,isSome as s}from"../../../core/maybe.js";import{property as o}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/Logger.js";import{subclass as i}from"../../../core/accessorSupport/decorators/subclass.js";import a from"../PixelBlock.js";import n from"../RasterInfo.js";import l from"../RasterStorageInfo.js";import f from"./BaseRaster.js";import{parseSpatialReference as c,parsePAMInfo as p}from"./pamParser.js";import{getElement as m,getElementValue as h}from"./xmlUtilities.js";import{isPlatformLittleEndian as u}from"../rasterFormats/utils.js";import{estimateStatisticsFromHistograms as g}from"../rasterFunctions/pixelUtils.js";import d from"../../../geometry/SpatialReference.js";import y from"../../../geometry/Extent.js";import x from"../../../geometry/Point.js";const w=new Map;w.set("Int8","s8"),w.set("UInt8","u8"),w.set("Int16","s16"),w.set("UInt16","u16"),w.set("Int32","s32"),w.set("UInt32","u32"),w.set("Float32","f32"),w.set("Float64","f32"),w.set("Double64","f32");const I=new Map;I.set("lerc",".lrc"),I.set("none",".til"),I.set("deflate",".pzp"),I.set("jpeg",".jzp");let b=class extends f{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async open(t){var e;await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const o=t?r(t.signal):null,i=await this.request(this.url,{responseType:"xml",signal:o}),{rasterInfo:a,files:n}=this._parseHeader(i.data);if(-1===(null==(e=this.ioConfig.skipExtensions)?void 0:e.indexOf("aux.xml"))){const e=await this._fetchAuxiliaryData(t);var l;if(null!=e)a.statistics=null!=(l=e.statistics)?l:a.statistics,a.histograms=e.histograms,e.histograms&&!s(a.statistics)&&(a.statistics=g(e.histograms))}this._set("rasterInfo",a),this._files=n;const f=await this.request(n.index,{responseType:"array-buffer",signal:o});this._storageIndex=this._parseIndex(f.data);let c,p,m=0,h=-1;const{blockWidth:u,blockHeight:d,compression:y}=this.rasterInfo.storageInfo,x=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:w,height:I,bandCount:b}=this.rasterInfo,A=[],R="none"===y?1:b;for(;m<this._storageIndex.length;)h++,c=Math.ceil(w/u/x**h),p=Math.ceil(I/d/x**h),m+=c*p*R*4,A.push({maxRow:p,maxCol:c,minCol:0,minRow:0});this.rasterInfo.storageInfo.blockBoundary=A,h>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=h),this.updateTileInfo()}async fetchRawTile(t,e,r,s={}){const{blockWidth:o,blockHeight:i,blockBoundary:n,compression:l}=this.rasterInfo.storageInfo,f=n[t];if(!f||f.maxRow<e||f.maxCol<r||f.minRow>e||f.minCol>r)return null;const{bandCount:c,pixelType:p}=this.rasterInfo,{ranges:m,actualTileWidth:h,actualTileHeight:u}=this._getTileLocation(t,e,r);if(!m||0===m.length)return null;if(0===m[0].from&&0===m[0].to){const t=new Uint8Array(o*i);return new a({width:o,height:i,pixels:null,mask:t,validPixelCount:0})}const{bandIds:g}=this.ioConfig,d="none"===l?1:c,y=[];let x=0;for(x=0;x<d;x++)(!g||g.indexOf[x]>-1)&&y.push(this.request(this._files.data,{range:{from:m[x].from,to:m[x].to},responseType:"array-buffer",signal:s.signal}));const w=await Promise.all(y),I=w.map((t=>t.data.byteLength)).reduce(((t,e)=>t+e)),b=new Uint8Array(I);let A=0;for(x=0;x<d;x++)b.set(new Uint8Array(w[x].data),A),A+=w[x].data.byteLength;const R="lerc"===this.rasterInfo.storageInfo.compression?"lerc":"bip",_=await this.decodePixelBlock(b.buffer,{width:o,height:i,format:R,pixelType:p});let j=0,F=0;if(h!==o||u!==i){let t=_.mask;if(t)for(x=0;x<i;x++)if(F=x*o,x<u)for(j=h;j<o;j++)t[F+j]=0;else for(j=0;j<o;j++)t[F+j]=0;else for(t=new Uint8Array(o*i),_.mask=t,x=0;x<u;x++)for(F=x*o,j=0;j<h;j++)t[F+j]=1}return _}_parseIndex(t){if(t.byteLength%16>0)throw"invalid array buffer must be multiples of 16";let e,r,s,o,i,a;if(u){for(r=new Uint8Array(t),o=new ArrayBuffer(t.byteLength),s=new Uint8Array(o),i=0;i<t.byteLength/4;i++)for(a=0;a<4;a++)s[4*i+a]=r[4*i+3-a];e=new Uint32Array(o)}else e=new Uint32Array(t);return e}_getTileLocation(t,e,r){const{blockWidth:s,blockHeight:o,pyramidScalingFactor:i,compression:a}=this.rasterInfo.storageInfo,{width:n,height:l,bandCount:f}=this.rasterInfo,c="none"===a?1:f;let p,m,h,u=0,g=0;for(h=0;h<t;h++)g=i**h,p=Math.ceil(n/s/g),m=Math.ceil(l/o/g),u+=p*m;g=i**t,p=Math.ceil(n/s/g),m=Math.ceil(l/o/g),u+=e*p+r,u*=4*c;const d=this._storageIndex.subarray(u,u+4*c);let y=0,x=0;const w=[];for(let I=0;I<c;I++)y=d[4*I+0]*2**32+d[4*I+1],x=y+d[4*I+2]*2**32+d[4*I+3],w.push({from:y,to:x});return{ranges:w,actualTileWidth:r<p-1?s:Math.ceil(n/g)-s*(p-1),actualTileHeight:e<m-1?o:Math.ceil(l/g)-o*(m-1)}}_parseHeader(t){const r=m(t,"MRF_META/Raster");if(!r)throw new e("mrf:open","not a valid MRF format");const s=m(r,"Size"),o=parseInt(s.getAttribute("x"),10),i=parseInt(s.getAttribute("y"),10),a=parseInt(s.getAttribute("c"),10),f=(h(r,"Compression")||"none").toLowerCase();if(!f||-1===["none","lerc"].indexOf(f))throw new e("mrf:open","currently does not support compression "+f);const p=h(r,"DataType")||"UInt8",u=w.get(p);if(null==u)throw new e("mrf:open","currently does not support pixel type "+p);const g=m(r,"PageSize"),b=parseInt(g.getAttribute("x"),10),A=parseInt(g.getAttribute("y"),10),R=m(r,"DataValues");let _,j;R&&(j=R.getAttribute("NoData"),null!=j&&(_=j.trim().split(" ").map((t=>parseFloat(t)))));if(m(t,"MRF_META/CachedSource"))throw new e("mrf:open","currently does not support MRF referencing other data files");const F=m(t,"MRF_META/GeoTags"),M=m(F,"BoundingBox");if(null==M)throw new e("mrf:open","missing node MRF_META/GeoTags/BoundingBox");const T=parseFloat(M.getAttribute("minx")),k=parseFloat(M.getAttribute("miny")),C=parseFloat(M.getAttribute("maxx")),L=parseFloat(M.getAttribute("maxy")),S=h(F,"Projection")||"",U=h(t,"datafile"),v=h(t,"IndexFile");let B;if("LOCAL_CS[]"!==S)if(S.toLowerCase().startsWith("epsg:")){const t=Number(S.slice(5));isNaN(t)||0===t||(B=new d({wkid:t}))}else B=c(S);const P=new y(T,k,C,L);P.spatialReference=B;const H=m(t,"MRF_META/Rsets"),E=parseInt(H&&H.getAttribute("scale")||"2",10),W=new l({origin:new x({x:P.xmin,y:P.ymax,spatialReference:B}),blockWidth:b,blockHeight:A,pyramidBlockWidth:b,pyramidBlockHeight:A,compression:f,pyramidScalingFactor:E}),D=new x({x:(C-T)/o,y:(L-k)/i,spatialReference:B});return{rasterInfo:new n({width:o,height:i,extent:P,spatialReference:B,bandCount:a,pixelType:u,pixelSize:D,noDataValue:_,storageInfo:W}),files:{mrf:this.url,index:v||this.url.replace(".mrf",".idx"),data:U||this.url.replace(".mrf",I.get(f))}}}async _fetchAuxiliaryData(t){try{const{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:null==t?void 0:t.signal});return p(e)}catch{return null}}};t([o()],b.prototype,"_files",void 0),t([o()],b.prototype,"_storageIndex",void 0),t([o({type:String,json:{write:!0}})],b.prototype,"datasetFormat",void 0),b=t([i("esri.layers.support.rasterIO.MRFRaster")],b);var A=b;export default A;
