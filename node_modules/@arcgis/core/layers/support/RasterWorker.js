/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import"../../geometry.js";import e from"./PixelBlock.js";import{decode as r}from"./rasterFormats/RasterCodec.js";import{estimateStatisticsHistograms as o,split as s,mosaic as t,approximateTransform as i}from"./rasterFunctions/pixelUtils.js";import l from"../../renderers/support/RasterSymbolizer.js";import m from"../../geometry/Extent.js";class n{async decode(e){const o=await r(e.data,e.options);return o&&o.toJSON()}symbolize(r){r.pixelBlock=e.fromJSON(r.pixelBlock),r.extent=r.extent?m.fromJSON(r.extent):null;const o=this.symbolizer.symbolize(r);return Promise.resolve(o&&o.toJSON())}async updateSymbolizer(e){var r;this.symbolizer=l.fromJSON(e.symbolizerJSON),e.histograms&&"rasterStretch"===(null==(r=this.symbolizer)?void 0:r.rendererJSON.type)&&(this.symbolizer.rendererJSON.histograms=e.histograms)}stretch(r){const o=this.symbolizer.simpleStretch(e.fromJSON(r.srcPixelBlock),r.stretchParams);return Promise.resolve(o&&o.toJSON())}estimateStatisticsHistograms(r){const s=o(e.fromJSON(r.srcPixelBlock));return Promise.resolve(s)}split(r){const o=s(e.fromJSON(r.srcPixelBlock),r.tileSize,r.maximumPyramidLevel);return o&&o.forEach(((e,r)=>{o.set(r,null==e?void 0:e.toJSON())})),Promise.resolve(o)}async mosaicAndTransform(r){const o=r.srcPixelBlocks.map((r=>r?new e(r):null)),s=t(o,r.srcMosaicSize,null,null,r.alignmentInfo);if(!r.coefs)return s&&s.toJSON();const l=i(s,r.destDimension,r.coefs,r.sampleSpacing,r.interpolation);return l&&l.toJSON()}}export default n;
