/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import"../../../../../geometry.js";import e from"../../../../../core/Evented.js";import t from"../../../../../core/has.js";import{isNone as s,isSome as r,andThen as a}from"../../../../../core/maybe.js";import{diff as i,hasDiff as o}from"../../../../../core/accessorSupport/diffUtils.js";import{GeohashTree as h}from"../../../../../geohash/GeohashTree.js";import{setGeohashBuf as l,setGeohashXY as n}from"../../../../../geohash/geohashUtils.js";import{earth as u}from"../../../../../geometry/support/Ellipsoid.js";import{getInfo as c}from"../../../../../geometry/support/spatialReferenceUtils.js";import{quantizeX as g,quantizeY as d}from"../../../../../layers/graphics/featureConversionUtils.js";import p from"../../../../../layers/graphics/OptimizedFeature.js";import f from"../../../../../layers/graphics/OptimizedGeometry.js";import{checkProjectionSupport as _,project as m}from"../../../../../layers/graphics/data/projectionSupport.js";import{TILE_SIZE as y}from"../../../engine/webgl/definitions.js";import{Store2D as I}from"../Store2D.js";import{FeatureSetReaderJSON as b}from"./FeatureSetReaderJSON.js";import v from"../../../../../geometry/SpatialReference.js";const R=12,C=1;class M extends p{constructor(e,t,s,r,a){super(new f([],[t,s]),r,null,e),this.geohashBoundsInfo=a}get count(){return this.attributes.cluster_count}static create(e,t,s,r,a,i,o,h){const l=new M(t,s,r,i,o);return l.displayId=e.createDisplayId(!0),l.referenceId=h,l.tileLevel=a,l}update(e,t,s,r,a,i){return this.geometry.coords[0]=e,this.geometry.coords[1]=t,this.tileLevel=s,this.attributes=r,this.geohashBoundsInfo=a,this.referenceId=null,this.referenceId=i,this}toJSON(){return{objectId:this.objectId,referenceId:1===this.attributes.cluster_count?this.referenceId:null,attributes:{...this.attributes,clusterId:this.objectId},geometry:{x:this.geometry.coords[0],y:this.geometry.coords[1]}}}}function x(e){return 57.29577951308232*e}class L extends I{constructor(t,s,r){super(t,r),this.events=new e,this._geohashLevel=0,this._aggregateValueRanges={},this._aggregateValueRangesChanged=!1,this._geohashBuf=[],this._clusters=new Map,this._tiles=new Map,this.geometryInfo=t.geometryInfo,this._spatialReference=s,this._projectionSupportCheck=_(s,v.WGS84),this._bitsets.geohash=r.getBitset(r.createBitset()),this._bitsets.inserted=r.getBitset(r.createBitset())}async updateSchema(e,r){const a=this._schema;try{await super.updateSchema(e,r),await this._projectionSupportCheck}catch(n){}const l=i(a,r);r&&(!s(l)||e.source||e.storage.filters)?((o(l,"params.fields")||!this._tree||e.source)&&(this._tree=new h(this._statisticFields),this._rebuildTree(),t("esri-2d-update-debug")&&console.debug("Aggregate mesh needs update due to tree changing")),t("esri-2d-update-debug")&&console.debug("Applying Update - ClusterStore:",l),e.targets[r.name]=!0,e.mesh=!1,this._aggregateValueRanges={}):a&&(e.mesh=!0)}sweepFeatures(e,t){this._bitsets.inserted.forEachSet((s=>{if(!e.has(s)){const e=t.lookupByDisplayIdUnsafe(s);this._remove(e)}}))}sweepClusters(e,t,s){this._clusters.forEach(((r,a)=>{r&&r.tileLevel!==s&&(e.releaseDisplayId(r.displayId),t.unsetAttributeData(r.displayId),this._clusters.delete(a))}))}onTileData(e,t,r,a,i=!0){if(!this._schema||s(t.addOrUpdate))return t;const o=this._tree,h=this._getTransforms(e,this._spatialReference);{const e=t.addOrUpdate.getCursor();for(;e.next();)this._update(e,a,o)}if(t.status.mesh||!i)return t;const l=new Array,n=this._schema.params.clusterRadius;this._getClustersForTile(l,e,n,r,o,h),t.addOrUpdate=b.fromOptimizedFeatures(l,"esriGeometryPoint"),t.addOrUpdate.attachStorage(r),t.end=!0;{const s=t.addOrUpdate.getCursor();for(;s.next();){const t=s.getDisplayId();this._bitsets.computed.unset(t),this.setComputedAttributes(r,s,t,e.scale)}}return this._aggregateValueRangesChanged&&t.end&&(this.events.emit("valueRangesChanged",{valueRanges:this._aggregateValueRanges}),this._aggregateValueRangesChanged=!1),t}onTileUpdate({added:e,removed:t}){if(e.length){const t=e[0].level;this._setGeohashLevel(t)}if(!this._schema)return;const s=this._schema.params.clusterRadius;t.forEach((e=>{this._tiles.delete(e.key.id),this._markTileClustersForDeletion(e,s)}))}getAggregate(e){let t=null;return this._clusters.forEach((s=>{s&&s.displayId===e&&(t=s.toJSON())})),t}getDisplayId(e){const t=this._clusters.get(e);return t?t.displayId:null}getFeatureDisplayIdsForAggregate(e){const t=this._clusters.get(e);if(!t)return[];const s=t.geohashBoundsInfo;return this._tree.getRegionDisplayIds(s.xLL,s.yLL,s.xTR,s.yTR,s.level)}getDisplayIdForReferenceId(e){let t;return this._clusters.forEach((s=>{s&&s.referenceId===e&&(t=s.displayId)})),t}getAggregateValueRanges(){return this._aggregateValueRanges}forEach(e){this._clusters.forEach(((t,s)=>{t&&e(t,s)}))}size(){let e=0;return this.forEach((t=>e++)),e}_rebuildTree(){this._bitsets.computed.clear(),this._bitsets.inserted.clear(),this._tree&&this._tree.clear()}_remove(e){const t=e.getDisplayId(),s=e.getXHydrate(),r=e.getYHydrate(),a=this._geohashBuf[2*t],i=this._geohashBuf[2*t+1];this._bitsets.inserted.has(t)&&(this._bitsets.inserted.unset(t),this._tree.removeCursor(e,s,r,a,i,this._geohashLevel))}_update(e,t,s){const r=e.getDisplayId(),a=this._bitsets.inserted,i=t.isVisible(r);if(i===a.has(r))return;if(!i)return void this._remove(e);const o=e.getXHydrate(),h=e.getYHydrate();if(!this._setGeohash(r,o,h))return;const l=this._geohashBuf[2*r],n=this._geohashBuf[2*r+1];s.insertCursor(e,r,o,h,l,n,this._geohashLevel),a.set(r)}_setGeohash(e,t,s){if(this._bitsets.geohash.has(e))return!0;const r=this._geohashBuf;if(this._spatialReference.isWebMercator){const a=x(t/u.radius),i=a-360*Math.floor((a+180)/360),o=x(Math.PI/2-2*Math.atan(Math.exp(-1*s/u.radius)));l(r,e,o,i,R)}else{const a=m({x:t,y:s},this._spatialReference,v.WGS84);if(!a)return!1;l(r,e,a.y,a.x,R)}return this._bitsets.geohash.set(e),!0}_getClustersForTile(e,t,i,o,h,l,n=!0){const u=this._schema.params.clusterPixelBuffer,c=2*i,f=this._getGeohashLevel(t.key.level),_=Math.ceil(2**t.key.level*y/c),m=Math.ceil(u/c)+0,I=Math.ceil(y/c),{row:b,col:v}=t.key,R=v*y,C=b*y,M=Math.floor(R/c)-m,x=Math.floor(C/c)-m,L=M+I+2*m,j=x+I+2*m,w=t.tileInfoView.getLODInfoAt(t.key.level);for(let y=M;y<=L;y++)for(let i=x;i<=j;i++){let u=y;w.wrap&&(u=y<0?y+_:y%_);const c=w.wrap&&y<0,m=w.wrap&&y%_!==y,I=this._lookupCluster(o,w,t.key.level,u,i,f,h);if(r(I)){const t=a(l,(e=>c?e.left:m?e.right:e.tile));if(n&&s(t))continue;if(!I.count)continue;if(r(t)&&n){const s=I.geometry.clone();let a=I.attributes;s.coords[0]=g(t,s.coords[0]),s.coords[1]=d(t,s.coords[1]),1===I.count&&r(I.referenceId)&&(a={...I.attributes,referenceId:I.referenceId});const i=new p(s,a);i.displayId=I.displayId,e.push(i)}}}}_getGeohashLevel(e){return Math.min(Math.ceil(e/2+2),R)}_setGeohashLevel(e){const t=this._getGeohashLevel(e),s=(Math.floor(t/C)+1)*C-1;if(this._geohashLevel!==s)return this._geohashLevel=s,this._rebuildTree(),void this._bitsets.geohash.clear()}_getTransforms(e,t){const s={originPosition:"upperLeft",scale:[e.resolution,e.resolution],translate:[e.bounds[0],e.bounds[3]]},r=c(t);if(!r)return{tile:s,left:null,right:null};const[a,i]=r.valid;return{tile:s,left:{...s,translate:[i,e.bounds[3]]},right:{...s,translate:[a-i+e.bounds[0],e.bounds[3]]}}}_getClusterId(e,t,s){return(15&e)<<28|(16383&t)<<14|16383&s}_markForDeletion(e,t,s){const r=this._getClusterId(e,t,s);this._clusters.delete(r)}_getClusterBounds(e,t,s){const r=this._schema.params.clusterRadius,a=2*r;let i=s%2?t*a:t*a-r;const o=s*a;let h=i+a;const l=o-a,n=2**e.level*y;e.wrap&&i<0&&(i=0),e.wrap&&h>n&&(h=n);const u=i/y,c=o/y,g=h/y,d=l/y;return[e.getXForColumn(u),e.getYForRow(c),e.getXForColumn(g),e.getYForRow(d)]}_lookupCluster(e,t,s,a,i,o,h){const l=this._getClusterId(s,a,i),c=this._clusters.get(l),[g,d,p,f]=this._getClusterBounds(t,a,i),_={x:g,y:d},y={x:p,y:f};let I=0,b=0,R=0,C=0;if(this._spatialReference.isWebMercator){{const e=x(_.x/u.radius);I=e-360*Math.floor((e+180)/360),b=x(Math.PI/2-2*Math.atan(Math.exp(-1*_.y/u.radius)))}{const e=x(y.x/u.radius);R=e-360*Math.floor((e+180)/360),C=x(Math.PI/2-2*Math.atan(Math.exp(-1*y.y/u.radius)))}}else{const e=m(_,this._spatialReference,v.WGS84),t=m(y,this._spatialReference,v.WGS84);if(!e||!t)return null;I=e.x,b=e.y,R=t.x,C=t.y}const L={geohashX:0,geohashY:0},j={geohashX:0,geohashY:0};n(L,b,I,o),n(j,C,R,o);const w=L.geohashX,V=L.geohashY,F=j.geohashX,S=j.geohashY,D={xLL:w,yLL:V,xTR:F,yTR:S,level:o},T=h.getRegionStatistics(w,V,F,S,o),{count:k,xTotal:B,yTotal:G,referenceId:O}=T,U=k?B/k:0,A=k?G/k:0;if(0===k)return this._clusters.set(l,null),null;const E={cluster_count:k,...T.attributes},X=r(c)?c.update(U,A,s,E,D,O):M.create(e,l,U,A,s,E,D,O);return 0===k&&(X.geometry.coords[0]=(g+p)/2,X.geometry.coords[1]=(d+f)/2),this._clusters.set(l,X),this._updateAggregateValueRangeForCluster(X,X.tileLevel),X}_updateAggregateValueRangeForCluster(e,t){const s=this._aggregateValueRanges[t]||{minValue:1/0,maxValue:0},r=s.minValue,a=s.maxValue;s.minValue=Math.min(r,e.count),s.maxValue=Math.max(a,e.count),this._aggregateValueRanges[t]=s,r===s.minValue&&a===s.maxValue||(this._aggregateValueRangesChanged=!0)}_markTileClustersForDeletion(e,t){const s=2*t,r=Math.ceil(y/s),{row:a,col:i}=e.key,o=i*y,h=a*y,l=Math.floor(o/s),n=Math.floor(h/s);for(let u=l;u<l+r;u++)for(let t=n;t<n+r;t++)this._markForDeletion(e.key.level,u,t)}}export{M as ClusterInfo,L as ClusterStore};
