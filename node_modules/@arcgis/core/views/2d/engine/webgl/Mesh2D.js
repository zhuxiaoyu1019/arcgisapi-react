/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import t from"../../../../core/Logger.js";import{isSome as r}from"../../../../core/maybe.js";import{e as n}from"../../../../chunks/earcut.js";import{s as o}from"../../../../chunks/vec2.js";import{a as s}from"../../../../chunks/vec2f64.js";import{convertFromNestedArray as c,convertFromPolygon as i}from"../../../../layers/graphics/featureConversionUtils.js";import a from"../../../../layers/graphics/OptimizedGeometry.js";import{i1616to32 as f}from"./number.js";import h from"../../../webgl/BufferObject.js";const m=t.getLogger("esri.views.2d.engine.webgl.Mesh2D"),u=t=>{switch(t.BYTES_PER_ELEMENT){case 1:return 5121;case 2:return 5123;case 4:return 5125;default:throw new e("Cannot get DataType of array")}},y=(e,t,r,n)=>{let o=0;for(let s=1;s<r;s++){const r=e[2*(t+s-1)],n=e[2*(t+s-1)+1];o+=(e[2*(t+s)]-r)*(e[2*(t+s)+1]+n)}return n?o>0:o<0},x=({coords:e,lengths:t},r)=>{const o=[];for(let s=0,c=0;s<t.length;c+=t[s],s+=1){const i=c,a=[];for(;s<t.length-1&&y(e,c+t[s],t[s+1],r);s+=1,c+=t[s])a.push(c+t[s]-i);const f=e.slice(2*i,2*(c+t[s])),h=n(f,a,2);for(const e of h)o.push(e+i)}return o};class g{constructor(e,t,r,n=!1){this._cache={},this.vertices=e,this.indices=t,this.primitiveType=r,this.isMapSpace=n}static fromRect({x:e,y:t,width:r,height:n}){const o=e,s=t,c=o+r,i=s+n;return g.fromScreenExtent({xmin:o,ymin:s,xmax:c,ymax:i})}static fromPath(e){const t=c(new a,e.path,!1,!1),r=t.coords,n=new Uint32Array(x(t,!0)),o=new Uint32Array(r.length/2);for(let s=0;s<o.length;s++)o[s]=f(Math.floor(r[2*s]),Math.floor(r[2*s+1]));return new g({geometry:o},n,4)}static fromGeometry(t,r){const n=r.geometry.type;switch(n){case"polygon":return g.fromPolygon(t,r.geometry);case"extent":return g.fromMapExtent(t,r.geometry);default:return m.error(new e("mapview-bad-type",`Unable to create a mesh from type ${n}`,r)),g.fromRect({x:0,y:0,width:1,height:1})}}static fromPolygon(e,t){const r=i(new a,t,!1,!1),n=r.coords,c=new Uint32Array(x(r,!1)),h=new Uint32Array(n.length/2),m=s(),u=s();for(let s=0;s<h.length;s++)o(m,n[2*s],n[2*s+1]),e.toScreen(u,m),h[s]=f(Math.floor(u[0]),Math.floor(u[1]));return new g({geometry:h},c,4,!0)}static fromScreenExtent({xmin:e,xmax:t,ymin:r,ymax:n}){const o={geometry:new Uint32Array([f(e,r),f(t,r),f(e,n),f(e,n),f(t,r),f(t,n)])},s=new Uint32Array([0,1,2,3,4,5]);return new g(o,s,4)}static fromMapExtent(e,t){const[r,n]=e.toScreen([0,0],[t.xmin,t.ymin]),[o,s]=e.toScreen([0,0],[t.xmax,t.ymax]),c={geometry:new Uint32Array([f(r,n),f(o,n),f(r,s),f(r,s),f(o,n),f(o,s)])},i=new Uint32Array([0,1,2,3,4,5]);return new g(c,i,4)}destroy(){r(this._cache.indexBuffer)&&this._cache.indexBuffer.dispose();for(const e in this._cache.vertexBuffers)r(this._cache.vertexBuffers[e])&&this._cache.vertexBuffers[e].dispose()}get elementType(){return u(this.indices)}getIndexBuffer(e,t=35044){return this._cache.indexBuffer||(this._cache.indexBuffer=h.createIndex(e,t,this.indices)),this._cache.indexBuffer}getVertexBuffers(e,t=35044){return this._cache.vertexBuffers||(this._cache.vertexBuffers=Object.keys(this.vertices).reduce(((r,n)=>({...r,[n]:h.createVertex(e,t,this.vertices[n])})),{})),this._cache.vertexBuffers}}export default g;
