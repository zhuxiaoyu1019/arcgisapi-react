/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import"../../../geometry.js";import{equals as e}from"../../../core/arrayUtils.js";import{clone as t}from"../../../core/lang.js";import{isSome as o,filterNones as n,isNone as r}from"../../../core/maybe.js";import{getMetersPerUnitForSR as a}from"../../../core/unitUtils.js";import s from"../../../geometry/Circle.js";import{simplify as i,distance as l}from"../../../geometry/geometryEngine.js";import{unnormalizeGeometryOnDatelineCrossing as y,isClockwise as c,unnormalizeVerticesOnDatelineCrossing as p}from"../../../geometry/support/coordsUtils.js";import{isValid as x}from"../../../geometry/support/spatialReferenceUtils.js";import{makeSurfacePoint as m}from"./surfaceCoordinateSystems.js";import u from"../../../geometry/Point.js";import f from"../../../geometry/Multipoint.js";import h from"../../../geometry/Polyline.js";import M from"../../../geometry/Polygon.js";function g(e,t,n=null){return o(n)?[e,t,n]:[e,t]}function d(e,t){const o=new u({x:e[0],y:e[1],spatialReference:t});return e.length>2&&(o.z=e[2]),o}function R(e,t){return new f({points:e,spatialReference:t})}function j(e,t,o){const n=new h({paths:e,spatialReference:t});return o&&y(n),n}function b(o,n,r,a=!0){const s=t(o);s.forEach((t=>{const o=t[0],n=t[t.length-1];e(o,n)&&1!==t.length||t.push(t[0])}));let l=new M({rings:s,spatialReference:n});return l.rings.forEach((e=>{c(e,!1,!1)||e.reverse()})),r&&y(l),a&&l.isSelfIntersecting&&x(n)&&(l=i(l)),l}function T(e,t,o){const r=t.mapToLocalMultiple(e),a=[],s={x:r[0].x,y:r[0].y},i={x:r[1].x,y:r[1].y},l=Math.round(i.x-s.x),y=Math.round(i.y-s.y),c=Math.max(Math.abs(l),Math.abs(y));if(o){const e={x:s.x+c,y:s.y+c},t={x:s.x-c,y:s.y-c};a.push(m(e.x,t.y),m(t.x,t.y),m(t.x,e.y),m(e.x,e.y))}else{const e={x:l>0?s.x+c:s.x-c,y:y>0?s.y+c:s.y-c};a.push(m(s.x,s.y),m(e.x,s.y),m(e.x,e.y),m(s.x,e.y))}return b([n(a.map((e=>t.localToMap(e))))],t.spatialReference,t.doUnnormalization,!0)}function U(e,t,o){let r=t.mapToLocalMultiple(e);if(1===r.length){const e=48,t=r[0];r=[m(t.x-e,t.y+e),m(t.x+e,t.y-e),m(t.x+e,t.y-e),m(t.x-e,t.y+e)]}const a=[],s={x:r[0].x,y:r[0].y},i={x:r[1].x,y:r[1].y};if(o){const e=Math.round(i.x-s.x),t=Math.round(i.y-s.y);a.push(m(s.x-e,s.y-t),m(i.x,s.y-t),m(i.x,i.y),m(s.x-e,i.y))}else a.push(m(s.x,s.y),m(i.x,s.y),m(i.x,i.y),m(s.x,i.y));return b([n(a.map((e=>t.localToMap(e))))],t.spatialReference,t.doUnnormalization,!0)}function w(e,t,o,n){const i=t.mapToLocalMultiple(e);let y=null,c=null;if(o)y=i[0],c=i[1];else{const e=i[0],t=i[1],o=Math.round(t.x-e.x),n=Math.round(t.y-e.y),r=Math.max(Math.abs(o),Math.abs(n));y=m(o>0?e.x+r/2:e.x-r/2,n>0?e.y+r/2:e.y-r/2),c=m(Math.abs(o)>Math.abs(n)?y.x-r/2:y.x,Math.abs(o)>Math.abs(n)?y.y:y.y-r/2)}const u=t.localToMap(y),f=t.localToMap(c);if(r(u)||r(f))return null;t.doUnnormalization&&p([[u,f]],t.spatialReference);const h=d(u,t.spatialReference),M=d(f,t.spatialReference),g=a(t.spatialReference);let R=0;if(x(t.spatialReference))R=g*l(h,M,null);else{const e=y.x-c.x,t=y.y-c.y;R=g*Math.sqrt(e*e+t*t)*(n||1)}const j=new s({center:h,radius:R,radiusUnit:"meters",spatialReference:t.spatialReference});return b(j.rings,j.spatialReference,!1)}function z(e,t,o){const r=t.mapToLocalMultiple(e),a=r[0],s=r[1],i=Math.round(s.x-a.x),l=Math.round(s.y-a.y),y=m(o?a.x:a.x+i/2,o?a.y:a.y+l/2),c=o?i:i/2,p=o?l:l/2,x=60,u=[],f=2*Math.PI/x;for(let n=0;n<x;n++){const e=Math.cos(n*f),t=Math.sin(n*f),o=m(c*e+y.x,p*t+y.y);u.push(o)}return u.push(u[0]),b([n(u.map((e=>t.localToMap(e))))],t.spatialReference,t.doUnnormalization,!1)}export{w as createCircle,z as createEllipse,R as createMultipoint,d as createPoint,b as createPolygon,j as createPolyline,U as createRectangle,T as createSquare,g as makeMapPoint};
