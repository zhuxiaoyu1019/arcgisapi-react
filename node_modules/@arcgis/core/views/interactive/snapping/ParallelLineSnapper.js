/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{unwrap as e}from"../../../core/maybe.js";import{j as t}from"../../../chunks/vec2.js";import{a as r}from"../../../chunks/vec2f64.js";import{defaults as o}from"./Settings.js";import{SnappingAlgorithm as i}from"./SnappingAlgorithm.js";import{anyMapPointToScreenPoint as s,squareDistance as n}from"./snappingUtils.js";import{ParallelLineSnappingCandidate as l}from"./candidates/ParallelLineSnappingCandidate.js";import{projectPointToLine as a}from"../../support/geometry2dUtils.js";class c extends i{constructor(){super(...arguments),this._tmpProjection=r()}snapNewVertex(e,t){const r=t.geometry.editGeometry.components[0],o=r.edges.length,i=r.vertices.length,n=[];if(o<2)return n;const l=s(e,t.coordinateHelper,t.elevationInfo,this.view),a=r.vertices[i-1],c=r.vertices[0],h=r.edges[o-1];let p=h;do{this.edgeExceedsShortLineThreshold(p,t)&&(this._checkEdgeForParalleLines(p,a.pos,e,l,t,n),this._checkEdgeForParalleLines(p,c.pos,e,l,t,n)),p=p.left.left}while(p&&p!==h);return n}snapExistingVertex(t,r){const o=[],i=e(r.vertexHandle),n=i.component;if(n.edges.length<3)return o;const l=s(t,r.coordinateHelper,r.elevationInfo,this.view),a=i.left,c=i.right,h=n.vertices[0],p=n.vertices.length,d=n.vertices[p-1],g=n.edges[0];let m=g;do{m!==a&&m!==c&&this.edgeExceedsShortLineThreshold(m,r)&&(a&&this._checkEdgeForParalleLines(m,a.left.pos,t,l,r,o),c&&this._checkEdgeForParalleLines(m,c.right.pos,t,l,r,o),i===h?this._checkEdgeForParalleLines(m,d.pos,t,l,r,o):i===d&&this._checkEdgeForParalleLines(m,h.pos,t,l,r,o)),m=m.right.right}while(m&&m!==g);return o}_checkEdgeForParalleLines(e,r,i,c,h,p){const d=e.left.pos,g=e.right.pos;if(a(this._tmpProjection,r,d,g),t(this._tmpProjection,r)<o.parallelLineThreshold)return;a(this._tmpProjection,i,d,g,r);const m=h.coordinateHelper,f=m.fromXYZ(this._tmpProjection,m.getZ(i,0));if(n(c,s(f,m,h.elevationInfo,this.view))<this.squaredProximityTreshold(h.pointer)){if(this.parallelToPreviousCandidate(e,p))return;p.push(new l({coordinateHelper:m,referenceLine:e,lineStart:r,targetPoint:f}))}}parallelToPreviousCandidate(e,r){const i=e.left.pos,s=e.right.pos;for(const n of r)if(a(this._tmpProjection,s,n.constraint.start,n.constraint.end,i),t(this._tmpProjection,s)<o.parallelLineThreshold)return n.addReferenceLine(e),!0;return!1}}export{c as ParallelLineSnapper};
