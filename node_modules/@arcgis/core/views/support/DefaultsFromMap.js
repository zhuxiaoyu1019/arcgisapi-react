/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import t from"../../core/Accessor.js";import{intersect as i}from"../../core/arrayUtils.js";import s from"../../core/Handles.js";import o from"../../core/Logger.js";import{createAbortController as n}from"../../core/promiseUtils.js";import{on as a,when as l}from"../../core/watchUtils.js";import{property as r}from"../../core/accessorSupport/decorators/property.js";import"../../core/has.js";import"../../core/accessorSupport/ensureType.js";import{subclass as d}from"../../core/accessorSupport/decorators/subclass.js";import{mayHaveHeightModelInfo as h,deriveHeightModelInfoFromLayer as c}from"../../geometry/support/heightModelInfoUtils.js";import{canProject as p,project as u}from"../../geometry/support/webMercatorUtils.js";var f;const g=o.getLogger("esri.views.support.DefaultsFromMap"),_=10;let m=f=class extends t{constructor(){super(...arguments),this._handles=new s,this._waitTask=null,this._extentProjectController=null,this._spatialReferenceCandidates=null,this._extentCandidates=null,this.logDebugInformation=!1,this.isSpatialReferenceDone=!1,this.isTileInfoDone=!1,this.isHeightModelInfoSearching=!1,this.spatialReference=null,this.extent=null,this.heightModelInfo=null,this.vcsWkid=null,this.latestVcsWkid=null,this.mapCollectionPaths=f.DefaultMapCollectionPaths.slice(),this.tileInfo=null}initialize(){this.watch("mapCollectionPaths",(()=>{this._running&&(this.reset(),this.start())}))}destroy(){this._set("view",null),this._handles&&(this._handles.destroy(),this._handles=null),this._cancelLoading()}get _running(){return!!(this._handles&&this._handles.size>0)}reset(){this._handles.removeAll(),this._set("isSpatialReferenceDone",!1),this._set("isTileInfoDone",!1),this._set("isHeightModelInfoSearching",!1),this._set("spatialReference",null),this._set("extent",null),this._set("heightModelInfo",null),this._set("vcsWkid",null),this._set("latestVcsWkid",null),this._set("tileInfo",null),this._spatialReferenceCandidates=null,this._extentCandidates=null}start(){this._handles.removeAll();const e=this._updateLayerChange.bind(this);for(const t of this.mapCollectionPaths)this._handles.add(a(this.view,`map.${t}`,"change",e,e,e,!0));this._handles.add(l(this,"isSpatialReferenceDone",(()=>this._updateTileInfo()),!0))}_ownerNameFromCollectionName(e){const t=e.lastIndexOf(".");return-1===t?"view":"view."+e.slice(0,t)}_ensureLoadedOwnersFromCollectionName(e){const t=this._ownerNameFromCollectionName(e).split(".");let i;for(let s=0;s<t.length&&(i=this.get(t.slice(0,s+1).join(".")),i);s++)if(i.load&&!i.isFulfilled())return{collectionName:e,owner:null,loading:i.load().catch((()=>{}))};return{collectionName:e,owner:i}}_cancelLoading(){this._waitTask=null,this._extentProjectController&&(this._extentProjectController.abort(),this._extentProjectController=null)}_updateWhen(e){let t=!0,i=!1;const s=e.catch((()=>{})).then((()=>{t?i=!0:s===this._waitTask&&this._update()}));return t=!1,i||(this._waitTask=s),i}_updateLayerChange(){this.isSpatialReferenceDone&&!this.spatialReference&&this._set("isSpatialReferenceDone",!1),this._update()}_update(){if(this._cancelLoading(),this.view){if(!this.isSpatialReferenceDone){this._debugLog("Starting search for spatial reference...");const e=this._processMapCollections((e=>this._processSpatialReferenceSource(e)));if(this._debugLog(`Search ended with status '${y(e)}'`),0!==e){let e=null,t=this._spatialReferenceCandidates;if(!t||t.length<1?(e=this.defaultSpatialReference,this._debugLog(`No spatial reference found, locking to default (${S(e)})`)):(this.defaultSpatialReference&&t.length>1&&t.findIndex((e=>e.equals(this.defaultSpatialReference)))>-1&&(t=[this.defaultSpatialReference]),e=t[0],this._debugLog(`Locking to ${S(e)}`)),this._set("spatialReference",e),e)if(this.extent)this._set("isSpatialReferenceDone",!0);else{const t=this.logDebugInformation;this.logDebugInformation=!1,this._processMapCollections((t=>this._findExtent(t,e))),this.logDebugInformation=t,this._projectExtentCandidate().catch((()=>{})).then((()=>this._set("isSpatialReferenceDone",!0)))}else this._set("isSpatialReferenceDone",!0)}}if(null==this.heightModelInfo&&this.view.isHeightModelInfoRequired){this._debugLog("Starting search for height model info...");const e=this._processMapCollections((e=>this._processHeightModelInfoSource(e)),(e=>h(e)));this._debugLog(`Search ended with status ${y(e)}`),this._set("isHeightModelInfoSearching",0===e)}this._updateTileInfo()}}_processMapCollections(e,t){this._preloadMapCollections(t);let i=2;return this._forAllMapCollectionSources((e=>{if(2!==i)return!1;const{collectionName:t}=e;return this._debugLog(`Processing collection ${t}...`),!(e.loading&&!this._updateWhen(e.loading))||(this._debugLog(`Collection ${e.collectionName} owner is loading -> wait`),i=0,!1)}),(s=>{if(2!==i)return!1;return null!=t&&!t(s)?(this._debugLog(`Source ${s.id} is skipped due to predicate`),!1):!s.load||s.isFulfilled()||this._updateWhen(s.load())?!((!s.load||s.isResolved())&&e(s))||(i=1,!1):(this._debugLog(`Source ${s.id} is loading -> wait`),i=0,!1)})),i}_preloadMapCollections(e){let t=_;const i=this.logDebugInformation;this.logDebugInformation=!1,this._forAllMapCollectionSources((()=>!0),(s=>{if(0===t)return!1;return!(null!=e&&!e(s))&&(s.load&&!s.isFulfilled()&&(this.logDebugInformation=i,this._debugLog(`Pre-loading source ${s.id}`),this.logDebugInformation=!1,s.load().catch((()=>{})),t--),!0)})),this.logDebugInformation=i}_forAllMapCollectionSources(e,t){for(const i of this.mapCollectionPaths){const s=`map.${i}`,o=this._ensureLoadedOwnersFromCollectionName(s);if(!1===e(o))continue;const n=o.owner;if(!n||n.isRejected&&n.isRejected()){this._debugLog(`Collection ${s} owner is invalid or rejected -> skip`);continue}const a=this.view.get(s);a?this._forEachSource(a,t):this._debugLog(`Collection ${s} does not exist -> skip`)}}_forEachSource(e,t){for(const i of e.items)!1!==t(i)&&"layers"in i&&i.layers&&this._forEachSource(i.layers,t)}_processSpatialReferenceSource(e){let t=this._getSupportedSpatialReferences(e);return 0!==t.length&&(this._spatialReferenceCandidates?(t=i(t,this._spatialReferenceCandidates,((e,t)=>e.equals(t))),t.length>0?this._spatialReferenceCandidates=t:this._debugLog(`Layer ${e.id} is ignored because its supported spatial\n          references are not compatible with the previous candidates`)):this._spatialReferenceCandidates=t,1===this._spatialReferenceCandidates.length)}_findExtent(e,t){const i="fullExtents"in e&&e.fullExtents||(e.fullExtent?[e.fullExtent]:[]),s=i.find((e=>e.spatialReference.equals(t)));if(s)return this._set("extent",s),!0;if(this._getSupportedSpatialReferences(e).length>0){const t=i.map((t=>({extent:t,layer:e}))),s=this._extentCandidates||[];this._extentCandidates=s.concat(t)}return!1}async _projectExtentCandidate(){if(!this._extentCandidates||!this._extentCandidates.length)return;const e=this.spatialReference,t=this._extentCandidates.find((t=>p(t.extent.spatialReference,e)));if(t)this._set("extent",u(t.extent,e));else{const t=this._extentCandidates[0];this._extentProjectController=n();const i=await import("../../portal/support/geometryServiceUtils.js");try{const s=await i.projectGeometry(t.extent,e,t.layer.portalItem,this._extentProjectController.signal);this._set("extent",s)}catch{}this._extentProjectController=null}}_getSupportedSpatialReferences(e){const t="supportedSpatialReferences"in e&&e.supportedSpatialReferences||(e.spatialReference?[e.spatialReference]:[]);if(0===t.length)return this._debugLog(`Layer ${e.id} is ignored because it does not have any spatial references`),[];const i=t.filter((t=>this.view.isSpatialReferenceSupported(t,e,(e=>this._debugLog(e)))));return 0===i.length?this._debugLog(`Layer ${e.id} has spatial references but none of them are supported (or layer doesn't require locking)`):this._debugLog(`Layer ${e.id} has spatial references. Resulting candidate set: ${i.map(S).join(", ")}`),i}_processHeightModelInfoSource(e){const t=c(e);return!!t&&(this._set("heightModelInfo",t),this._set("isHeightModelInfoSearching",!1),e.spatialReference&&(this._set("vcsWkid",e.spatialReference.vcsWkid),this._set("latestVcsWkid",e.spatialReference.latestVcsWkid)),!0)}_updateTileInfo(){if(null!=this.tileInfo)return;if(!this.view.isTileInfoRequired())return void this._set("isTileInfoDone",!0);if(!this.isSpatialReferenceDone)return;const e=this.get("view.map");if(!e)return void this._debugLog("updateTileInfo: no map");const t=e.basemap,i=e.get("layers.0");let s=null;if(t&&"failed"!==t.loadStatus){if(!t.loaded)return this._updateWhen(t.load()),void this._debugLog("updateTileInfo: basemap still loading");const e=t&&t.get("baseLayers.0");if(e&&"failed"!==e.loadStatus){if(!e.loaded)return this._updateWhen(e.load()),void this._debugLog("updateTileInfo: first basemap layer still loading");s="tileInfo"in e&&e.tileInfo}else{if(!i||"failed"===i.loadStatus)return this._debugLog("updateTileInfo: no tileInfo"),void this._set("isTileInfoDone",!0);if(!i.loaded)return this._updateWhen(i.load()),void this._debugLog("updateTileInfo: first operational layer still loading");s="tileInfo"in i&&i.tileInfo}}else if(i&&"failed"!==i.loadStatus){if(!i.loaded)return this._updateWhen(i.load()),void this._debugLog("updateTileInfo: first operational layer still loading");s="tileInfo"in i&&i.tileInfo}s&&!s.spatialReference.equals(this.spatialReference)&&(s=null),this._debugLog(`updateTileInfo: setting ${s}`),this._set("tileInfo",s),this._set("isTileInfoDone",!0)}_debugLog(e){this.logDebugInformation&&g.info(e)}};function S(e){return e?JSON.stringify(e.toJSON()):"undefined"}function y(e){switch(e){case 0:return"Waiting";case 1:return"Found";case 2:return"Exhausted"}}m.DefaultMapCollectionPaths=["basemap.baseLayers","layers","ground.layers","basemap.referenceLayers"],e([r()],m.prototype,"logDebugInformation",void 0),e([r({readOnly:!0})],m.prototype,"isSpatialReferenceDone",void 0),e([r({readOnly:!0})],m.prototype,"isTileInfoDone",void 0),e([r({readOnly:!0})],m.prototype,"isHeightModelInfoSearching",void 0),e([r({constructOnly:!0})],m.prototype,"view",void 0),e([r({readOnly:!0})],m.prototype,"spatialReference",void 0),e([r({readOnly:!0})],m.prototype,"extent",void 0),e([r({readOnly:!0})],m.prototype,"heightModelInfo",void 0),e([r({readOnly:!0})],m.prototype,"vcsWkid",void 0),e([r({readOnly:!0})],m.prototype,"latestVcsWkid",void 0),e([r()],m.prototype,"mapCollectionPaths",void 0),e([r()],m.prototype,"defaultSpatialReference",void 0),e([r({readOnly:!0})],m.prototype,"tileInfo",void 0),m=f=e([d("esri.views.support.DefaultsFromMap")],m);var I=m;export default I;
