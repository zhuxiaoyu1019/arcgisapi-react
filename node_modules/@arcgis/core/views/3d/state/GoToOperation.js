/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import t from"../../../Camera.js";import i from"../../../Viewpoint.js";import e from"../../../core/Error.js";import{isSome as a,isNone as n}from"../../../core/maybe.js";import{createAbortController as o,onAbort as r,createAbortError as s}from"../../../core/promiseUtils.js";import{whenOnce as l}from"../../../core/watchUtils.js";import{applyAll as c}from"../camera/constraintUtils.js";import{State as h}from"./controllers/CameraController.js";import{PointToPointAnimationController as m}from"./controllers/PointToPointAnimationController.js";import{SurfaceCollisionCorrectionController as w}from"./controllers/SurfaceCollisionCorrectionController.js";import{externalToInternal as p}from"../support/cameraUtils.js";import{create as f}from"../support/viewpointUtils.js";import{applySurfaceCollisionConstraint as v}from"../camera/constraintUtils/surfaceCollision.js";class C{constructor(t,i,e){this.target=t,this.options=i,this.view=e,this.state="pending",this.abortController=null,this.animationController=null,this.promise=new Promise(((t,i)=>{this.resolveCallback=t,this.rejectCallback=i;const e=o();a(this.options.signal)&&r(this.options.signal,(()=>{this.abort()})),this.abortController=e,this.waitForReady()}))}then(t,i){return this.promise.then(t,i)}catch(t){return this.promise.catch(t)}resolve(t){return this.state="finished",this.resolveCallback(t)}reject(t){return this.state="finished",this.rejectCallback(t)}abort(t=!1){switch(this.state){case"pending":case"wait-for-ready":case"wait-for-viewpoint":this.reject(s());break;case"wait-for-animation-finish":!t&&a(this.animationController)&&this.view.state.cameraController===this.animationController&&this.animationController.active&&this.animationController.stopController(),this.reject(s())}}waitForReady(){this.state="wait-for-ready",this.view.ready?this.createViewPoint():l(this.view,"ready",this.abortController.signal).then((()=>{this.createViewPoint()}),(t=>{this.reject(t)}))}createViewPoint(){"finished"!==this.state&&(this.state="wait-for-viewpoint",this.animationController=this.options.animate?this.getAnimationController():null,f(this.view,this.target,this.abortController.signal).then((t=>{if("finished"===this.state)return;const i=this.getCameraFromViewpoint(t);if(!n(i))if(this.options.animate){if(n(this.animationController))return;this.startAnimation(i,this.animationController)}else this.view.stateManager.setStateCamera(i.camera,{applyConstraints:!i.isFullySpecified,positionAndOrientationOnly:!0,doNotCancelGoToOperation:!0}),this.resolve()}),(t=>{this.reject(t)})))}getCameraFromViewpoint(a){const o=!!(this.target instanceof i&&this.target.camera||this.target instanceof t),r=a.camera;if(n(r))return null;if(!this.view.stateManager.isCompatible(r)){const t=r.position,i=t&&t.spatialReference,a=i?i.wkid:"none",n=this.view.spatialReference.wkid;return this.reject(new e("GotoAnimation:incompatible-spatialreference",`Resulting camera has an incompatible spatial reference (camera: ${a}, view: ${n})`,{camera:r})),null}const s=p(this.view,r);return n(s)?(this.reject(new e("GotoAnimation:invalid-camera","Resulting camera is invalid")),null):{viewpoint:a,camera:s,isFullySpecified:o}}startAnimation(t,i){this.state="wait-for-animation-finish";const o=i.viewAnimation;if(n(o))return void this.reject(new e("GotoAnimation:missing-animation","Unreachable code in view.stateManager"));if(o.update(t.viewpoint,"running"),!i.active||n(i.viewAnimation)||i.viewAnimation.target!==t.viewpoint||this.view.state.cameraController!==i)return this.abort();let r;t.isFullySpecified?(r=new w({view:this.view,desiredCamera:t.camera}),v(this.view,t.camera,1)):c(this.view,t.camera),i.begin(t.camera,this.options);const s=()=>{const e=this.view.state.cameraController;r&&(e&&e.active?e instanceof m&&a(e.viewAnimation)&&e.viewAnimation.target===t.viewpoint&&(this.view.state.cameraController=r):a(i.viewAnimation)&&i.viewAnimation.target===t.viewpoint&&"finished"===i.state&&(this.view.state.cameraController=r))},l=t=>{if(!n(this.view.state))switch(i.state){case h.Finished:switch(this.state){case"pending":case"wait-for-ready":case"wait-for-viewpoint":case"wait-for-animation-finish":this.resolve()}break;case h.Ready:case h.Rejected:case h.Running:case h.Stopped:switch(this.state){case"pending":case"wait-for-ready":case"wait-for-viewpoint":case"wait-for-animation-finish":this.reject(t)}}};o.when(s,(t=>l(t))),i.asyncResult={resolve:()=>l(),reject:t=>l(t)}}getAnimationController(){let t,i=null;const n=this.view.state.cameraController;return n instanceof m&&(n.updateStateFromViewAnimation(),n.active&&(t=n,i=t.viewAnimation)),null!=t||(t=new m({view:this.view,mode:"animation"}),i=t.viewAnimation,this.view.state.switchCameraController(t))?t:(a(i)&&i.stop(),this.reject(new e("GotoAnimation:goto-cannot-interrupt","Cannot start an animation while interacting")),null)}}export{C as GoToOperation};
