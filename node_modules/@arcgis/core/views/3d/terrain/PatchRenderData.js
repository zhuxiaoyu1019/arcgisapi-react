/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{equals as e}from"../../../core/arrayUtils.js";import{clamp as t}from"../../../core/mathUtils.js";import{isSome as r,isNone as i}from"../../../core/maybe.js";import{empty as s}from"../../../geometry/support/aaBoundingBox.js";import{glLayout as a}from"../support/buffer/glUtil.js";import{PatchGeometry as o,releaseGeometry as l}from"./PatchGeometryFactory.js";import{ELEVATION_DESIRED_RESOLUTION_LEVEL as n}from"./TerrainConst.js";import u from"./TextureFader.js";import m from"./TileOverlayData.js";import{fallsWithinLayer as h}from"./tileUtils.js";import{Default3D as c}from"../webgl-engine/lib/DefaultVertexAttributeLocations.js";import f from"../../webgl/BufferObject.js";import p from"../../webgl/VertexArrayObject.js";class g{constructor(){this.geometryInfo=new o,this._textureRef=new u((()=>this.tile.surface.textureFadeDuration)),this.overlay=new m}init(e){this.tile=e,this.clear();const t=this.geometryInfo;t.indices=null,t.vertexAttributes=null,s(t.boundingBox),t.numSurfaceIndices=0,t.numSkirtIndices=0,t.numWithoutSkirtIndices=0,t.numVertsPerRow=0,this.geometryState={numVertsPerRow:0,samplerData:null,clippingArea:null,wireframe:!1},this.opacity=1,this.localOrigin=null,this.overlay.clear()}clear(){this.releaseGeometry(),this.releaseTexture(),this._textureRef.clear()}updateGeometry(e,t){return!!this._updateGeometryState(t)&&(this._releaseGeometry(),this._createGeometry(e),!0)}releaseGeometry(){return!!this._releaseGeometry()&&(this.geometryState={numVertsPerRow:0,samplerData:null,clippingArea:null,wireframe:!1},!0)}ensureTexture(e,t){return r(this._texture)&&this._texture.descriptor.width!==e&&this.releaseTexture(),i(this._texture)&&(this._texture=t(),this.tile.setMemoryDirty()),this._texture}releaseTexture(){r(this._texture)&&(this._texture.release(),this._texture=null,this.tile.setMemoryDirty())}_updateGeometryState(r){const i=this._getElevationInfo(),s=this.tile.level;let a=s<8?this.tile.numSubdivisionsAtLevel[s]+1:2;if(i.samplerData){const e=this.tile.vlevel-s,r=Math.max(s-i.maxTileLevel,n-e),o=this.tile.maxTesselation;a=t(1+(o>>r),2,o+1)}let o=this.tile.clippingArea;this.tile.intersectsClippingArea&&!this.tile.isWithinClippingArea||(o=null);const l=this.geometryState;let u=!1;return l.numVertsPerRow!==a&&(l.numVertsPerRow=a,u=!0),i.changed&&(l.samplerData=i.samplerData,u=!0),e(l.clippingArea,o)||(l.clippingArea=o,u=!0),l.wireframe!==r&&(l.wireframe=r,u=!0),u}_createGeometry(e){this.tile.createGeometry(this.geometryState,this.localOrigin);const t=this.geometryInfo.vertexAttributes,r=this.geometryInfo.indices,i=e.gl;this._vao=new p(e,c,{geometry:a(t.layout)},{geometry:f.createVertex(e,i.STATIC_DRAW,t.buffer)},f.createIndex(e,i.STATIC_DRAW,r))}_releaseGeometry(){return!!this._vao&&(this._vao.dispose(),this._vao=null,l(this.geometryInfo),!0)}get vao(){return this._vao}setTextureReference(e,t,r,i,s=0){e!==this._texture&&this.releaseTexture(),this._textureRef.push(e,t,r,i,s)}get textureReference(){return this._textureRef.current}get nextTextureReference(){return this._textureRef.next}get textureFadeFactor(){return this._textureRef.fadeFactor}get textureIsFading(){return this._textureRef.isFading}_getElevationInfo(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[0],r=t.length;let i=new Array(r),s=0,a=0,o=!1;for(let l=0;l<r;l++){const r=t[l];if(r.upsampleInfo){const t=r.upsampleInfo.tile,n=t.layerInfo[0][l].data,u=n&&n.samplerData;e&&e[s]===u||(o=!0),i[s++]=u,a=Math.max(a,t.lij[0])}else if(r.data){const t=this.tile.surface.layerViewByIndex(l,0);if(h(this.tile,t.layer,!1)){const t=r.data;e&&e[s]===t.samplerData||(o=!0),i[s++]=t.samplerData,a=this.tile.lij[0]}}}return e&&e.length!==s&&(o=!0),s>0?i.length=s:i=null,{changed:o,samplerData:i,maxTileLevel:a}}get estimatedGeometryMemoryUsage(){return this.geometryInfo.indices.byteLength+this.geometryInfo.vertexAttributes.byteLength}get textureDescriptor(){return r(this._texture)?this._texture.descriptor:null}get test(){return{hasTexture:null!=this._texture}}}export{g as PatchRenderData};
