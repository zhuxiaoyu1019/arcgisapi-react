/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{handlesGroup as e,destroyHandle as t,refHandle as n}from"../../../../core/handleUtils.js";import{deg2rad as o}from"../../../../core/mathUtils.js";import{isNone as i,isSome as a}from"../../../../core/maybe.js";import{init as s}from"../../../../core/watchUtils.js";import{s as r}from"../../../../chunks/vec3.js";import{c as l}from"../../../../chunks/vec3f64.js";import{projectVectorToVector as p,projectPointToVector as c}from"../../../../geometry/projection.js";import{create as m,empty as h,getMin as u}from"../../../../geometry/support/aaBoundingBox.js";import{containsXY as d}from"../../../../geometry/support/aaBoundingRect.js";import{getGraphicEffectiveElevationInfo as f}from"../../../../support/elevationInfoUtils.js";import{ManipulatorState as g}from"./ManipulatorState.js";import{settings as v}from"./settings.js";import{ExtendedLineVisualElement as y}from"../visualElements/ExtendedLineVisualElement.js";import{LaserlineVisualElement as E}from"../visualElements/LaserlineVisualElement.js";import{PointVisualElement as w}from"../visualElements/PointVisualElement.js";import{evaluateElevationAlignmentAtPoint as j}from"../../layers/graphics/elevationAlignmentUtils.js";import{ElevationContext as b}from"../../layers/graphics/ElevationContext.js";import{GraphicState as x}from"../../layers/graphics/GraphicState.js";function S(t){const{view:n,graphic:o}=t,i=new x({graphic:o}),a=[],s=P(t,i,a);return L(t,i,a,s),a.push(n.trackGraphicState(i)),{visualElement:s,remove(){e(a).remove()}}}function L(e,n,s,l){const{view:c,graphic:m}=e,d=new y({view:c,extensionType:v.visualElements.zVerticalLine.extensionType,innerWidth:1,attached:!1,writeDepthEnabled:!1,renderOccluded:4});v.visualElements.zVerticalLine.apply(d);const w=new E({view:c,intersectsLineInfinite:!0,attached:!1});v.visualElements.pointGraphics.shadowStyle.apply(w);const x=o(v.visualElements.heightPlaneAngleCutoff),S=new E({view:c,attached:!1,angleCutoff:x});v.visualElements.heightPlane.apply(S);const L=f(e.graphic),P=b.fromElevationInfo(L),C="on-the-ground"===L.mode||!L.offset&&"absolute-height"!==L.mode,M=new g;let R=1,G=1;const V=()=>{M.update(e);const t=A(m),o=C&&(n.isDraped||i(t)||!t.hasZ);let s=!0;if(!o&&a(t)){const e=j(t,c.elevationProvider,P,c.renderCoordsHelper);r(U,t.x,t.y,e),p(U,t.spatialReference,U,c.renderCoordsHelper.spatialReference),d.setStartEndFromWorldDownAtLocation(U),w.intersectsWorldUpAtLocation=U}else s=!1;const f=2&M.grabbingState?v.visualElements.laserlineAlphaMultiplier:1;f!==R&&(R=f,v.visualElements.heightPlane.apply(S,f));const g=h(D);!o&&n.displaying&&l.calculateMapBounds(g)&&p(u(g,U),c.spatialReference,U,c.renderCoordsHelper.spatialReference)?(S.heightManifoldTarget=U,S.attached=!0):S.attached=!1;const y=4&M.grabbingState?v.visualElements.laserlineAlphaMultiplier:1;y!==G&&(G=y,v.visualElements.pointGraphics.shadowStyle.apply(w,y));const E=s&&n.displaying&&!o;w.attached=E,d.attached=E};s.push(n.watch(["displaying","isDraped"],V),n.on("changed",V)),e.forEachManipulator((e=>{s.push(e.events.on("grab-changed",V))})),s.push(t(w)),s.push(t(d)),s.push(t(S)),V()}function P(e,n,o){const{view:i,graphic:a}=e,s=new w({view:i,geometry:A(a),elevationInfo:f(a),attached:!1});return C(e,s,n,o),o.push(t(s)),s}function A(e){const t=e.geometry;return i(t)?null:"point"===t.type?t:"mesh"===t.type?t.anchor.clone():null}function C(e,t,n,o){const i=()=>t.attached=n.displaying;M(e,t,n,o),v.visualElements.pointGraphics.outline.apply(t),o.push(s(n,"displaying",i))}function M(e,t,o,i){const{view:s,graphic:r}=e;let l=null;const p=e=>{a(l)&&(l.remove(),l=null),o.isDraped&&a(e)&&(l=R(s,e,(()=>{t.geometry=e})))},c=()=>{const e=A(r);p(e),t.geometry=e};i.push(o.on("changed",c),n((()=>l))),c()}function R(e,t,n){const o=e.elevationProvider.spatialReference;c(t,U,o);const i=U[0],a=U[1];return e.elevationProvider.on("elevation-change",(e=>{d(e.extent,i,a)&&n()}))}const U=l(),D=m();export{S as createVisualElements};
