/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import t from"../../../../../core/Evented.js";import e from"../../../../../core/Handles.js";import{clamp as a,rad2deg as i}from"../../../../../core/mathUtils.js";import{isSome as r}from"../../../../../core/maybe.js";import{addFrameTask as o}from"../../../../../core/scheduling.js";import{createScreenPointArray as s}from"../../../../../core/screenUtils.js";import{init as n}from"../../../../../core/watchUtils.js";import{i as l,c,v as h,m as d,s as g}from"../../../../../chunks/mat4.js";import{c as p}from"../../../../../chunks/mat4f64.js";import{s as u,f as m,l as f,h as M,c as D,b as S}from"../../../../../chunks/vec3.js";import{a as y,f as v}from"../../../../../chunks/vec3f64.js";import{fromPositionAndNormal as R,create as b,normal as k}from"../../../../../geometry/support/plane.js";import{wrap as _,distance2 as j}from"../../../../../geometry/support/ray.js";import{sv3d as A,sm4d as w}from"../../../../../geometry/support/vectorStacks.js";import{getGraphicEffectiveElevationInfo as F}from"../../../../../support/elevationInfoUtils.js";import{Manipulator3D as I}from"../../Manipulator3D.js";import{calculateInputRotationTransform as E}from"../../manipulatorUtils.js";import{screenToRenderPlane as P}from"../dragEventPipeline3D.js";import{ROTATE_INDICATOR_DIRECTION_BUFFER as U,SCALE_INDICATOR_DIRECTION_BUFFER as T,RING_HEIGHT as x,ROTATE_INDICATOR_ARROW_TIP_LENGTH as L,ROTATE_INDICATOR_ARROW_TIP_RADIUS as O,RING_THICKNESS as C,DRAG_THRESHOLD_PX as G,RING_INDICATOR_DELAY_MS as H,INDICATOR_THICKNESS as q,ROTATE_INDICATOR_ARROW_PLACEMENT_PERCENTAGE as z,HANDLE_COLOR as B,RING_RESET_ANIMATION_SPEED_FACTOR as J,RING_RADIUS as K,ROTATE_INDICATOR_ARC_LENGTH as N,INNER_INDICATOR_RADIUS as Q,OUTER_INDICATOR_RADIUS as V,SCALE_INDICATOR_OFFSET1 as W,SCALE_INDICATOR_OFFSET2 as X,GEOMETRY_SEGMENTS as Y,SCALE_INDICATOR_ARC_LENGTH as Z}from"../manipulations/config.js";import{cyclicalPI as $}from"../../../support/mathUtils.js";import tt from"../../../webgl-engine/lib/GeometryUtil.js";import{ColorMaterial as et}from"../../../webgl-engine/materials/ColorMaterial.js";import{createManipulatorDragEventPipeline as at}from"../../../../interactive/dragEventPipeline.js";var it;!function(t){t.ScaleIn=32,t.ScaleOut=64,t.RotateLeft=128,t.RotateRight=256,t.Unlocked=1024,t.DelayedFocused=2048,t.TouchInput=32768}(it||(it={}));class rt{constructor(a){this.mode=null,this._handles=new e,this._scaleRotateDragData=null,this._activeAnimation=null,this.events=new t,this.getFocused=()=>this.ringManipulator.focused,this.getScale=()=>r(this._scaleRotateDragData)&&"scale"===this._scaleRotateDragData.mode?this.adapter.scale:1,this.tool=a.tool,this.mode=a.mode,this.adapter=a.adapter,this.createManipulator(),this.updateDragState(),this.updateManipulatorTransform()}get angle(){return this.adapter.angle}get scale(){return this.adapter.scale}set location(t){this.ringManipulator.location=t}set elevationAlignedLocation(t){this.ringManipulator.elevationAlignedLocation=t}get grabbing(){return this.ringManipulator.grabbing}set interactive(t){this.ringManipulator.interactive=t}destroy(){r(this._activeAnimation)&&(this._activeAnimation.frameTask.remove(),this._activeAnimation=null),this._handles.removeAll(),this.tool.manipulators.remove(this.ringManipulator),this.ringManipulator=null}startAnimation(t){this.cancelActiveAnimation(),t.start();const e=o({update:({deltaTime:e})=>{t.update(e)&&this.cancelActiveAnimation()}});this._activeAnimation={...t,frameTask:e}}cancelActiveAnimation(){r(this._activeAnimation)&&(this._activeAnimation.frameTask.remove(),this._activeAnimation.destroy(),this._activeAnimation=null)}forEachManipulator(t){t(this.ringManipulator,4)}createManipulator(){this.ringManipulator=this.createRingManipulator(),this.tool.manipulators.add(this.ringManipulator);const t=this.ringManipulator,e=this.tool.graphicState.graphic,o=at(t,((t,o,s)=>{this._scaleRotateDragData=null,this.adapter.restart();const n={mode:"none",origin:y(t.renderLocation),initialAngle:this.adapter.angle,angle:0,angleDir:0,scaleDir:0};this._scaleRotateDragData=n,this.updateDragState();const l=A.get();this.tool.view.renderCoordsHelper.worldUpAtPosition(t.renderLocation,l),o.next(P(this.tool.view,R(t.renderLocation,l,b()))).next((t=>{const o=k(t.plane),s=E(t.renderStart,t.renderEnd,n.origin,o),l=$.shortestSignedDiff(n.angle,s);n.angleDir=a(n.angleDir+l,-U,U),n.angle=s;const c=ot(n,t),h=c-this.adapter.scale;if(n.scaleDir=a(n.scaleDir+h,-T,T),this.onScaleChanged(),"none"===n.mode){const a=this.mode||st(t,t.plane,n.origin,this.tool.view.state.camera);if(r(a)){switch(a){case"rotate":this.tool.emit("graphic-rotate-start",{graphic:e,angle:0}),this.tool.emit("record-undo",{record:this.adapter.createUndoRecord()});break;case"scale":this.tool.emit("graphic-scale-start",{graphic:e,xScale:1,yScale:1}),this.tool.emit("record-undo",{record:this.adapter.createUndoRecord()})}n.mode=a}}switch(n.mode){case"rotate":this.adapter.angle=n.initialAngle+s;break;case"scale":this.adapter.scale=c,this.onScaleChanged()}switch(this.updateDragState(),this.updateManipulatorTransform(),t.action){case"start":case"update":switch(n.mode){case"rotate":this.tool.emit("graphic-rotate",{graphic:e,angle:i(n.angle)});break;case"scale":this.tool.emit("graphic-scale",{graphic:e,xScale:c,yScale:c})}break;case"end":switch(n.mode){case"rotate":this.tool.emit("graphic-rotate-stop",{graphic:e,angle:i(n.angle)});break;case"scale":this.tool.emit("graphic-scale-stop",{graphic:e,xScale:c,yScale:c});break;default:case"none":}}"end"===t.action&&(this.startAnimation(lt(this,(()=>this.onScaleChanged()))),this._scaleRotateDragData=null,this.updateDragState())})),s.next((()=>{if(this.adapter.cancel(),r(this._scaleRotateDragData)){switch(this._scaleRotateDragData.mode){case"none":break;case"rotate":this.tool.emit("graphic-rotate-stop",{graphic:e,angle:0});break;case"scale":this.tool.emit("graphic-scale-stop",{graphic:e,xScale:1,yScale:1})}this.startAnimation(lt(this,(()=>this.onScaleChanged()))),this._scaleRotateDragData=null,this.updateDragState()}}))}));this._handles.add(o),this._handles.add([this.ringManipulator.events.on("focus-changed",(t=>{"focus"===t.action?this.startAnimation(ct(this,(()=>this.updateDelayedFocusedState()))):this.updateDelayedFocusedState()})),this.ringManipulator.events.on("immediate-click",(t=>{t.stopPropagation()})),n(this.tool.graphicState,"displaying",(t=>this.ringManipulator.available=t))])}onScaleChanged(){this.events.emit("scale-changed"),this.updateManipulatorTransform()}updateDelayedFocusedState(){this.ringManipulator.updateStateEnabled(it.DelayedFocused,this.getFocused())}updateDragState(){if(this.ringManipulator.updateStateEnabled(it.Unlocked,!(r(this._scaleRotateDragData)&&"none"!==this._scaleRotateDragData.mode)),r(this._scaleRotateDragData))switch(this._scaleRotateDragData.mode){case"rotate":this.ringManipulator.updateStateEnabled(it.ScaleIn|it.ScaleOut,!1),this.ringManipulator.updateStateEnabled(it.RotateLeft,this._scaleRotateDragData.angleDir<0),this.ringManipulator.updateStateEnabled(it.RotateRight,this._scaleRotateDragData.angleDir>=0);break;case"scale":this.ringManipulator.updateStateEnabled(it.RotateLeft|it.RotateRight,!1),this.ringManipulator.updateStateEnabled(it.ScaleIn,this._scaleRotateDragData.scaleDir<0),this.ringManipulator.updateStateEnabled(it.ScaleOut,this._scaleRotateDragData.scaleDir>=0)}else this.ringManipulator.updateStateEnabled(it.ScaleIn|it.ScaleOut|it.RotateLeft|it.RotateRight,!1)}updateManipulatorTransform(){const t=l(w.get()),e=this.adapter.angle;c(t,t,e,v(0,0,1));const a=this.getScale(),i=h(w.get(),u(A.get(),a,a,a)),r=l(w.get());d(r,i,t),this.ringManipulator.modelTransform=r}createRingManipulator(){const t=(t,e,a)=>{const i=[],r=Math.ceil(Y*(e-t)/(2*Math.PI));for(let o=0;o<r+1;o++){const s=t+o*(e-t)/r;i.push(v(a*Math.cos(s),a*Math.sin(s),0))}return i},e=e=>t(0,2*Math.PI,e),a=t=>[[-t/2,0],[t/2,0],[t/2,x/2],[-t/2,x/2]],i=(t,e)=>tt.createPathExtrusionGeometry(a(e),t,[],[],!1),r=e(K),o=i(r,C),s={left:[],right:[]},n=[];for(let v=0;v<2;v++){const e=v*Math.PI-Math.PI/4,a=Math.PI/2-N,r=e+a,o=e+Math.PI/2-a,l=t(r,o,Q),h=i(l,q);n.push(l),n.push(t(r,o,V-C/2)),s.left.push(h),s.right.push(h);for(let t=0;t<2;t++){const e=0===t,a=p();if(e){g(a,a,[1,-1,1]),c(a,a,-r,[0,0,1]);const t=Math.round(z*(l.length-1));a[12]=l[t][0],a[13]=l[t][1],a[14]=l[t][2]}else{c(a,a,o,[0,0,1]);const t=Math.round((1-z)*(l.length-1));a[12]=l[t][0],a[13]=l[t][1],a[14]=l[t][2]}const i=tt.createExtrudedTriangle(L,0,O,x);tt.transformInPlace(i,a),(e?s.left:s.right).push(i)}}const l=[];for(let c=0;c<2;c++){const e=c*Math.PI-Math.PI/4,a=Math.PI/2-Z,r=e+a,o=e+Math.PI/2-a,s=t(r,o,V);l.push(i(s,q))}const h=e(K+W),d=e(K+X),u=i(h,q),m=i(d,q),f=e(K-W),M=e(K-X),D=i(f,q),S=i(M,q),y=this.createMaterial(),R=this.createMaterial(.66),b=this.createMaterial(.5),k=this.createMaterial(.33);let _=[{geometry:o,material:y,stateMask:it.DelayedFocused},{geometry:o,material:b,stateMask:0}];this.mode&&"scale"!==this.mode||(_=_.concat([{geometry:l,material:y,stateMask:it.DelayedFocused|it.Unlocked},{geometry:u,material:R,stateMask:it.DelayedFocused|it.ScaleIn},{geometry:m,material:k,stateMask:it.DelayedFocused|it.ScaleIn},{geometry:D,material:R,stateMask:it.DelayedFocused|it.ScaleOut},{geometry:S,material:k,stateMask:it.DelayedFocused|it.ScaleOut}])),this.mode&&"rotate"!==this.mode||(_=_.concat([{geometry:s.right,material:y,stateMask:it.DelayedFocused|it.Unlocked},{geometry:s.left,material:y,stateMask:it.DelayedFocused|it.RotateLeft},{geometry:s.right,material:y,stateMask:it.DelayedFocused|it.RotateRight}]));const j=[r,...n];return new I({view:this.tool.view,renderObjects:_,autoScaleRenderObjects:!1,worldOriented:!0,radius:C,focusMultiplier:1,touchMultiplier:1.5,elevationInfo:F(this.tool.graphicState.graphic),collisionType:{type:"ribbon",paths:j,direction:v(0,0,1)}})}createMaterial(t=1){const e=[...B,t];return new et({color:e,transparent:1!==t,cullFace:2,renderOccluded:2})}get test(){return{ringManipulator:this.ringManipulator}}}function ot(t,e){const a=m(A.get(),e.renderStart,t.origin),i=m(A.get(),e.renderEnd,t.origin),r=f(a),o=f(i);return 0===r?0:o/r}function st(t,e,a,i){const{renderStart:r,renderEnd:o}=t,s=nt(r,i,A.get()),n=nt(o,i,A.get());if(M(s,n)<G*G)return null;const l=m(A.get(),r,a),c=D(A.get(),l,k(e)),h=r,d=S(A.get(),h,c),g=nt(a,i,A.get()),p=s,u=nt(d,i,A.get()),f=m(A.get(),u,p),y=m(A.get(),s,g),v=_(p,f),R=_(g,y);return j(v,n)<j(R,n)?"rotate":"scale"}function nt(t,e,a){return e.projectToScreen(t,ht),u(a,ht[0],ht[1],0)}function lt(t,e){let a=null,i=1;const r=()=>i;return{start:()=>{i=t.getScale(),a=t.getScale,t.getScale=r,e()},update:t=>(i+=((i+1)/2-i)*Math.min(t*J,1),e(),Math.abs(i-1)<.01?1:0),destroy:()=>{t.getScale=a,e()}}}function ct(t,e){let a=0,i=null;const r=()=>!1;return{start:()=>{i=t.getFocused,t.getFocused=r,a=0,e()},update:t=>(a+=t,!i()||a>H?1:0),destroy:()=>{t.getFocused=i,e()}}}const ht=s();export{rt as GraphicScaleRotateTransform};
