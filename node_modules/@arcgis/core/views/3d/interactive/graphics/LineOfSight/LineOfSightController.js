/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import"../../../../../geometry.js";import t from"../../../../../core/Accessor.js";import s from"../../../../../core/Handles.js";import{handlesGroup as n,makeHandle as i}from"../../../../../core/handleUtils.js";import{isNone as o,isSome as r,abortMaybe as a,removeMaybe as l,none as c}from"../../../../../core/maybe.js";import{createTask as p,ignoreAbortErrors as d}from"../../../../../core/promiseUtils.js";import{property as h}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/Logger.js";import{subclass as g}from"../../../../../core/accessorSupport/decorators/subclass.js";import{reactionInit as u}from"../../../../../core/accessorSupport/trackingUtils.js";import{g as _,f as m,n as y,a as v,b,j as A,w as f}from"../../../../../chunks/vec3.js";import{c as C}from"../../../../../chunks/vec3f64.js";import{fromPoints as T,create as j}from"../../../../../geometry/support/ray.js";import{LineOfSightAnalysis as I}from"./LineOfSightAnalysis.js";import{Intersector as O}from"../../../webgl-engine/lib/Intersector.js";import{toGraphic as E}from"../../../webgl-engine/lib/intersectorUtilsConversions.js";import{ImmediateTask as L,TaskPriority as w}from"../../../../support/Scheduler.js";import P from"../../../../../geometry/Point.js";let S=class extends t{constructor(e){super(e),this._tasks=L,this._handles=new s,this._analysisHandles=new s}initialize(){var e;const t=null==(e=this.view.resourceController)?void 0:e.scheduler;t&&(this._tasks=t.registerTask(w.LINE_OF_SIGHT_TOOL));this._handles.add([u((()=>this.model.observer),(e=>this._onObserverChange(e))),this._connectAnalyses(),this._connectTargets()]),this._intersector=new O(this.view.state.viewingMode),this._intersector.options.hud=!1,this._intersector.options.store=0}destroy(){this._handles.destroy(),this._analysisHandles.destroy(),this._analyses.removeAll()}get updating(){return this._tasks.updating}get priority(){return this._tasks.priority}set priority(e){this._tasks.priority=e}get _viewData(){return this.model.viewData}get _analyses(){return this._viewData.analyses}get _observerEngineLocation(){return this._viewData.observerEngineLocation}set _observerEngineLocation(e){this._viewData.observerEngineLocation=e}get _screenPixelSize(){return this.view.state.camera.computeScreenPixelSizeAt(this._observerEngineLocation)}getLineOfSightComputationDependencies(e){const{inputPoints:t}=e;return{inputPoints:t}}computeAnalysis(e,t=!1){const{analysis:s}=e,{inputPoints:n,computationResult:i}=s,{observerAdjusted:o,targetAdjusted:r}=n,{start:a,end:l}=i;_(a,o),_(l,r);t||this._canComputeAnalysis(s)?this._computeAnalysisIntersection(e):this._interpolateAnalysisIntersection(e),s.updateComputationResults()}_adjustStartEndPositions(e){const t=this._screenPixelSize,s=this.view,{inputPoints:n}=e,{observer:i,target:o,observerAdjusted:r,targetAdjusted:a}=n,l=H;m(l,o,i);const c=t;y(l,l),v(l,l,Math.min(c,1)),b(r,i,l),m(l,i,o);const p=s.state.camera.computeScreenPixelSizeAt(o);y(l,l),v(l,l,Math.min(p,1)),b(a,o,l)}_computeAnalysisIntersection({analysis:e,interpolationInfo:t}){const{view:s}=this,{sceneIntersectionHelper:n,renderCoordsHelper:i}=s;if(o(n))return;const r=this._intersector,{computationResult:a,inputPoints:l}=e,{observer:c,target:p}=l,{start:d,end:h}=a,g=T(d,h,R);n.intersectToolIntersectorRay(g,r);const u=a.intersection,m=H,y=!!r.results.min&&r.results.min.getIntersectionPoint(u);let v=!0;if(y){_(t.originalIntersection,u),_(t.originalObserver,d),_(t.originalTarget,h),i.fromRenderCoords(u,m,s.spatialReference);const e=1-A(h,p)/A(d,p);v=A(c,u)>=e*A(c,p)}const b=new P(m,s.spatialReference);e.target.intersectedLocation=v?null:b,e.target.intersectedGraphic=v?null:E(r.results.min,s),e.target.visible=!!y&&v,a.isValid=l.isValid=!0,a.isTargetVisible=v}_interpolateAnalysisIntersection({analysis:e,interpolationInfo:t}){const{computationResult:s,inputPoints:n,target:i}=e,{start:o,end:r,intersection:a}=s,{originalIntersection:l,originalObserver:c,originalTarget:p}=t;if(_(a,l),n.isValid){const e=H,t=A(c,l)/A(c,p);f(e,o,c),v(e,e,1-t),b(a,a,e),f(e,r,p),v(e,e,t),b(a,a,e),s.isValid=!0}else i.intersectedLocation=null,i.intersectedGraphic=null,i.visible=void 0,s.isValid=!1,s.isTargetVisible=!1}_canComputeAnalysis(e){const t=this.model.observer,s=this.view.frustum;if(o(t)||o(e.target.location)||o(s))return!1;const{observerAdjusted:n,targetAdjusted:i}=e.inputPoints,r=s.intersectsPoint(n),a=s.intersectsPoint(i);return r&&a}_onObserverChange(e){if(o(e))return void this.model.targets.removeAll();const t=C();this.view.renderCoordsHelper.toRenderCoords(e,t),this._observerEngineLocation=t,this.priority=w.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onObserverChangeForAnalysis(e){e.inputPoints.isValid=!1}_onObserverEngineForAnalysis(e,t){const{inputPoints:s}=e;_(s.observer,t),this._adjustStartEndPositions(e),e.updateInputPoints(),this.priority=w.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onTargetLocationChange(e,t){const{inputPoints:s}=e;s.isValid=!1,this.view.renderCoordsHelper.toRenderCoords(t,s.target),this._adjustStartEndPositions(e),e.updateInputPoints(),this.priority=w.LINE_OF_SIGHT_TOOL_INTERACTIVE}_connectAnalysisToTarget(e){return u((()=>({analysis:e,targetLocation:e.target.location})),(({analysis:e,targetLocation:t})=>{r(t)&&this._onTargetLocationChange(e,t)}))}_connectAnalysisToObserver(e){return u((()=>({analysis:e,observer:this.model.observer})),(({analysis:e})=>{this._onObserverChangeForAnalysis(e)}))}_connectAnalysisToObserverEngine(e){return u((()=>({analysis:e,observer:this._observerEngineLocation})),(({analysis:e,observer:t})=>{this._onObserverEngineForAnalysis(e,t)}))}_connectAnalysisForCompute(e){let t=c;const s={analysis:e,interpolationInfo:{originalIntersection:C(),originalObserver:C(),originalTarget:C()}};return n([u((()=>this.getLineOfSightComputationDependencies(e)),(()=>{t=a(t),t=p((async e=>{await d(this._tasks.schedule((()=>this.computeAnalysis(s)),e))}))})),i((()=>t=a(t)))])}_connectAnalysis(e){const t=this._analysisHandles;t.has(e)||t.add([this._connectAnalysisToTarget(e),this._connectAnalysisToObserver(e),this._connectAnalysisToObserverEngine(e),this._connectAnalysisForCompute(e)])}_disconnectAnalysis(e){this._analysisHandles.remove(e)}_onAnalysesCollectionChange(e){e.added.forEach((e=>this._connectAnalysis(e))),e.removed.forEach((e=>this._disconnectAnalysis(e)))}_onTargetsChange(e){this._analyses.removeAll(),e.items.length>0&&this._onTargetCollectionChange({target:e,added:e.items,removed:[],moved:[]})}_onTargetCollectionChange(e){const t=this._analyses;e.added.forEach((e=>{t.some((t=>t.target===e))||t.add(new I({target:e}))})),e.removed.forEach((e=>{const s=t.find((t=>t.target===e));t.remove(s)}))}_connectAnalyses(){let e=null;return n([u((()=>this._analyses),(t=>{e=l(e),e=t.on("change",(e=>this._onAnalysesCollectionChange(e))),this._onAnalysesCollectionChange({target:t,added:t.items,removed:[],moved:[]})})),i((()=>e=l(e)))])}_connectTargets(){let e=null;return n([u((()=>this.model.targets),(t=>{e=l(e),e=t.on("change",(e=>this._onTargetCollectionChange(e))),this._onTargetsChange(t)})),i((()=>e=l(e)))])}};e([h()],S.prototype,"model",void 0),e([h()],S.prototype,"view",void 0),e([h()],S.prototype,"updating",null),e([h()],S.prototype,"priority",null),e([h()],S.prototype,"_viewData",null),e([h()],S.prototype,"_analyses",null),e([h()],S.prototype,"_observerEngineLocation",null),e([h()],S.prototype,"_screenPixelSize",null),e([h()],S.prototype,"_tasks",void 0),S=e([g("esri.views.3d.interactive.graphics.LineOfSight.LineOfSightController")],S);const H=C(),R=j();export{S as LineOfSightController};
