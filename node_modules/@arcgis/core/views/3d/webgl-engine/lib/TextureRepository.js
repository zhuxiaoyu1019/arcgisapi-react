/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import e from"../../../../core/Evented.js";import t from"../../../../core/Logger.js";import{isSome as r,isNone as a}from"../../../../core/maybe.js";import{isPromiseLike as s,isAbortError as i}from"../../../../core/promiseUtils.js";import{TextureTechnique as n,TextureTechniqueConfiguration as o}from"./TextureTechnique.js";import{assert as u}from"./Util.js";import{TaskPriority as l}from"../../../support/Scheduler.js";import h from"../../../webgl/Texture.js";const c=t.getLogger("esri.views.3d.webgl-engine.lib.TextureRepository"),T=8;class f{constructor(t,r,a){this._stage=t,this._rctx=a,this._idToRefCountedTexture=new Map,this._loadingCount=0,this._frameUpdates=new Map,this._fallbackTextureData=new Uint8Array(T*T*4),this._fallbackTextureTransparentData=new Uint8Array(T*T*4),this.events=new e,this._textureTechnique=r.acquire(n,new o);for(let e=0;e<this._fallbackTextureData.length;++e)this._fallbackTextureData[e]=255,this._fallbackTextureTransparentData[e]=(e+1)%4!=0?255:0;this._fallbackTextureDesc={target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728,width:T,height:T,maxAnisotropy:this._rctx.parameters.maxMaxAnisotropy},this._frameTask=t.resourceController.scheduler.registerTask(l.TEXTURE_UNLOAD)}dispose(){this._frameTask.remove(),r(this._fallbackTexture)&&(this._fallbackTexture.dispose(),this._fallbackTexture=null),r(this._fallbackTextureTransparent)&&(this._fallbackTextureTransparent.dispose(),this._fallbackTextureTransparent=null),this._stage.forEachOfType(4,(e=>e.unload()))}get updating(){return this.loadingCount>0||this._frameTask.updating}acquire(e,t=!1,r){const a=this._getOrCreateRef(e,t,r);return a.ref(),a}update(){let e=!1;this._frameUpdates.forEach((t=>{const r=t.texture.frameUpdate(this._rctx,this._textureTechnique,t.previousToken);r>=0&&r!==t.previousToken&&(t.previousToken=r,e=!0)})),e&&this.events.emit("changed",0)}_getOrCreateRef(e,t,r){const a=this._idToRefCountedTexture.get(e);return a||this._createNewRef(e,t,r)}_createNewRef(e,t,r){const a=this._stage.getObject(e);u(void 0!==a);const n=a.events.on("unloaded",(()=>{n.remove(),this._onTextureUnloaded(e)})),o=new _;this._idToRefCountedTexture.set(e,o);const l=a.load(this._rctx,this._textureTechnique);this._loadingCount++;const h=t=>(this._loadingCount--,this._updateGLTexture(o,t),r&&r(o),a.requiresFrameUpdates&&this._frameUpdates.set(e,{texture:a,previousToken:-1}),o),T=e=>{this._loadingCount--,i(e)||c.error(e)};return s(l)?(this._updateGLTexture(o,t?this.fallbackTextureTransparent:this.fallbackTexture),l.then(h,T)):h(l),o}_updateGLTexture(e,t){e.glTexture=t,this.events.emit("changed",1)}release(e){const t=this._idToRefCountedTexture.get(e);if(t&&(t.unref(),t.isUnreferenced)){const r=this._stage.getObject(e);this._frameTask.schedule((()=>{t.isUnreferenced&&r.unload()}))}}getTexture(e){return this._stage.getObject(e)}get loadingCount(){return this._loadingCount}_onTextureUnloaded(e){this._idToRefCountedTexture.delete(e),this._frameUpdates.delete(e)}get fallbackTexture(){return a(this._fallbackTexture)&&(this._fallbackTexture=new h(this._rctx,this._fallbackTextureDesc,this._fallbackTextureData)),this._fallbackTexture}get fallbackTextureTransparent(){return a(this._fallbackTextureTransparent)&&(this._fallbackTextureTransparent=new h(this._rctx,this._fallbackTextureDesc,this._fallbackTextureTransparentData)),this._fallbackTextureTransparent}}class _{constructor(){this._refCount=0,this.glTexture=null}get isUnreferenced(){return 0===this._refCount}ref(){++this._refCount}unref(){0!==this._refCount?--this._refCount:c.error("Cannot dereference texture that has no references!")}}export{_ as RefCountedTexture,f as TextureRepository};
