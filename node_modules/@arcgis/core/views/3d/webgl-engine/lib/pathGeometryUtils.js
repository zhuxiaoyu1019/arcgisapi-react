/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{sign as t,acosClamped as e,reciprocalClamped as i}from"../../../../core/mathUtils.js";import{s}from"../../../../chunks/mat2.js";import{c as r}from"../../../../chunks/mat2f64.js";import{t as o,i as h,c as n}from"../../../../chunks/mat4.js";import{c as a}from"../../../../chunks/mat4f64.js";import{s as l,h as u,o as p,a as f,b as c,i as x,f as d,l as v}from"../../../../chunks/vec2.js";import{a as m,b as g,f as V}from"../../../../chunks/vec2f64.js";import{d as b,g as A,b as C,n as D,a as I,f as N,c as R,o as S,s as U,l as P,m as _}from"../../../../chunks/vec3.js";import{c as y}from"../../../../chunks/vec3f64.js";import{create as T,fromPositionAndNormal as k,intersectRay as L}from"../../../../geometry/support/plane.js";import{wrap as B}from"../../../../geometry/support/ray.js";import F from"./GeometryUtil.js";import{intersectTriangles as M}from"../materials/internal/MaterialUtil.js";function w(){return{up:y(),right:y()}}function G(t,e,i){_(t.up,e.up,i),_(t.right,e.right,i)}function j(t,e,i){t[0]=i[0]*e.right[0]+i[1]*e.up[0],t[1]=i[0]*e.right[1]+i[1]*e.up[1],t[2]=i[0]*e.right[2]+i[1]*e.up[2]}function z(t,e,i){l(t,b(i,e.right),b(i,e.up))}class E{constructor(){this.pos=y(),this.posES=y(),this.posGS=y(),this.vRight=y(),this.vLeft=y(),this.frame=w(),this.rotationFrame=w(),this.rotationRight=m(),this.rotationAngle=0,this.miterStretch=r()}setFrameFromUpVector(t){A(this.frame.up,t),C(lt,this.vLeft,this.vRight),D(lt,lt),I(at,this.frame.up,b(lt,this.frame.up)),N(ft,lt,at),D(ft,ft),R(this.frame.right,ft,this.frame.up)}computeRotationAxisAndAngleFromUpVector(){A(this.rotationFrame.up,this.frame.up),A(this.rotationFrame.right,this.frame.right),l(this.rotationRight,1,0),I(at,this.frame.up,b(this.frame.up,this.vLeft)),N(at,this.vLeft,at),S(at,at),D(at,at),I(lt,this.frame.up,b(this.frame.up,this.vRight)),N(lt,this.vRight,lt),D(lt,lt),R(ut,this.rotationFrame.up,this.vLeft);const r=t(b(ut,this.vRight));if(this.rotationAngle=r*(Math.PI-e(b(at,lt))),Math.abs(this.rotationAngle)>0){const t=i(Math.cos(.5*this.rotationAngle));s(this.miterStretch,t-1+1,0,0,1)}const o=Math.PI-this.rotationAngle;this.maxStretchDistance=Math.abs(Math.min(this.vLeftLength,this.vRightLength)/Math.cos(.5*o))}}class O{constructor(){this.vertices=[],this.vertexIndices=[],this.vertexNormals=[],this.poles=[],this.poleIndices=[],this.uvs=null,this.uvIndices=null}addVertex(t,e){return this.vertices.push(g(t)),this.vertexNormals.push(g(e)),this.vertices.length-1}addUV(t){return this.uvs||(this.uvs=[],this.uvIndices=[]),this.uvs.push(t),this.uvs.length-1}addPole(t,e=null){return this.poles.push({position:g(t),normal:e?g(e):null}),this.poles.length-1}addSegment(t,e=null,i=null){this.vertexIndices.push(t.v0),this.vertexIndices.push(t.v1),e&&(this.uvIndices.push(e.v0),this.uvIndices.push(e.v1)),i&&(this.poleIndices.push(i.v0),this.poleIndices.push(i.v1))}get numSegments(){return this.vertexIndices.length/2}hasUV(){return null!=this.uvs}translate(t,e){for(const i of this.vertices)i[0]+=t,i[1]+=e;for(const i of this.poles)i.position[0]+=t,i.position[1]+=e}static circle(t=20){const e=.5,i=new O,s={v0:0,v1:0};i.addPole(V(0,0));for(let h=0;h<t;++h){const s=2*h*Math.PI/t,r=Math.cos(s),o=Math.sin(s),n=V(r*e,o*e),a=V(r,o);i.addVertex(n,a),i.addUV(h/t)}i.addUV(1);for(let h=0;h<t-1;++h){const t={v0:h,v1:h+1},e=t;i.addSegment(t,e,s)}const r={v0:t-1,v1:0},o={v0:t-1,v1:t};return i.addSegment(r,o,s),i}static rect(){const t=1,e=1,i=new O,s=V(.5*-t,.5*-e),r=V(.5*t,.5*-e),o=V(.5*t,.5*e),h=V(.5*-t,.5*e),n=V(0,-1),a=V(1,0),l=V(0,1),u=V(-1,0);i.addUV(0),i.addUV(1),i.addPole(V(0,.5*e),l),i.addPole(V(0,.5*e)),i.addPole(V(0,.5*-e)),i.addPole(V(0,.5*-e),n);const p={v0:0,v1:1};return i.addVertex(s,n),i.addVertex(r,n),i.addSegment({v0:0,v1:1},p,{v0:3,v1:3}),i.addVertex(r,a),i.addVertex(o,a),i.addSegment({v0:2,v1:3},p,{v0:2,v1:1}),i.addVertex(o,l),i.addVertex(h,l),i.addSegment({v0:4,v1:5},p,{v0:0,v1:0}),i.addVertex(h,u),i.addVertex(s,u),i.addSegment({v0:6,v1:7},p,{v0:1,v1:2}),i}}class J{constructor(t){this.vertices=[],this.offset=y(),this.xform=a(),this.vertices=t;const e=Math.floor((t.length-1)/2);A(this.offset,this.vertices[e].pos);for(const i of this.vertices)N(i.pos,i.pos,this.offset);o(this.xform,this.xform,this.offset),this.updatePathVertexInformation()}updatePathVertexInformation(){const t=this.vertices.length;let e=this.vertices[0];e.index=0,U(e.vLeft,0,0,0),e.vLeftLength=0,N(e.vRight,this.vertices[1].pos,e.pos),e.vRightLength=P(e.vRight),D(e.vRight,e.vRight);let i=e;for(let s=1;s<t;++s)e=this.vertices[s],e.index=s,A(e.vLeft,i.vRight),e.vLeftLength=i.vRightLength,s<t-1?(N(e.vRight,this.vertices[s+1].pos,e.pos),e.vRightLength=P(e.vRight),D(e.vRight,e.vRight)):(A(e.vRight,e.vLeft),e.vRightLength=e.vLeftLength),i=e}}function q(t,e){let i=null;const s=t.vertices.length,r=.99619469809,o=y(),h=y(),n=y(),a=y(),l=y(),u=y(),p=T();let f=t.vertices[0];A(h,e),U(o,0,1,0),F.makeOrthoBasisDirUpFallback(f.vRight,h,o,o,n,h,r),A(f.frame.up,h),A(f.frame.right,n),i=f;for(let c=1;c<s;++c){f=t.vertices[c],C(l,f.vLeft,f.vRight);let e=P(l);e>0?(e=1/Math.sqrt(e),l[0]=l[0]*e,l[1]=l[1]*e,l[2]=l[2]*e):(l[0]=f.vRight[0],l[1]=f.vRight[1],l[2]=f.vRight[2]),C(u,i.pos,i.frame.up),k(f.pos,l,p);L(p,B(u,f.vLeft),a)?(N(a,a,f.pos),D(h,a),R(n,l,h),D(n,n)):F.makeOrthoBasisDirUpFallback(l,i.frame.up,i.frame.right,o,n,h,r),A(f.frame.up,h),A(f.frame.right,n),i=f}}class H{}class K{numProfilesPerJoin(){return 1}extrude(t,e,i){for(let s=0;s<e.vertices.length;++s)i(t.index,t.frame,e.vertices[s],e.vertexNormals[s],!1)}}class Q{constructor(t=.8*Math.PI,e=1){this.cutoffAngle=t,this.numBendSubdivisions=e}numProfilesPerJoin(){return this.numBendSubdivisions+1}extrude(t,e,i){const s=ct;if(Math.abs(t.rotationAngle)>=this.cutoffAngle)for(let r=0;r<this.numBendSubdivisions+1;++r){h(xt),n(xt,xt,.5*-t.rotationAngle+r*t.rotationAngle/this.numBendSubdivisions,t.rotationFrame.up),G(s,t.frame,xt);for(let r=0;r<e.vertices.length;++r){u(e.vertices[r],t.rotationRight)*t.rotationAngle>=0?i(t.index,s,e.vertices[r],e.vertexNormals[r],!1):(p(ot,e.vertices[r],t.miterStretch),i(t.index,t.frame,ot,e.vertexNormals[r],!0))}}else for(let r=0;r<this.numBendSubdivisions+1;++r)for(let s=0;s<e.vertices.length;++s){const r=u(e.vertices[s],t.rotationRight)*t.rotationAngle>=0;p(ot,e.vertices[s],t.miterStretch),i(t.index,t.frame,ot,e.vertexNormals[s],!r)}}}const W={generateUV:!1};class X{rebuildConnectingProfileGeometry(t,e,i){for(let s=0;s<e.vertices.length;++s)i(t.index,t.frame,e.vertices[s],e.vertexNormals[s],0,0)}}class Y extends X{constructor(){super()}getNumVertices(){return 0}getNumIndices(){return 0}rebuildCapGeometry(){}buildTopology(){}}class Z extends X{constructor(t,e=0,i=!1){super(),this.profile=t,this.profilePlaneOffset=e,this.flip=i}getNumVertices(){return this.profile.vertices.length}getNumIndices(){return 3*this.profile.numSegments}rebuildConnectingProfileGeometry(t,e,i){for(let s=0;s<e.vertices.length;++s)i(t.index,t.frame,e.vertices[s],e.vertexNormals[s],this.profilePlaneOffset,0)}rebuildCapGeometry(t,e){const i=ht;l(i,0,0);const s=this.flip?1:-1;for(let r=0;r<this.profile.vertices.length;++r)e(t.index,t.frame,this.profile.vertices[r],i,this.profilePlaneOffset,s)}buildTopology(t,e){const i=this.vertexBufferStart+this.profile.vertexIndices[0];for(let s=1;s<this.profile.numSegments;++s){const t=this.profile.vertexIndices[2*s+0],r=this.profile.vertexIndices[2*s+1],o=this.vertexBufferStart+t,h=this.vertexBufferStart+r;this.flip?e(h,o,i):e(i,o,h)}}}class $ extends X{constructor(t){super(),this.flip=!1,this.sign=0,this.breakNormals=!1,this.numSegments=3,this.profile=t.profile,this.flip=t.flip,this.sign=this.flip?1:-1,this.breakNormals=t.breakNormals,this.numSegments=t.subdivisions}getNumVertices(){let t=0;return t=this.profile.vertices.length*(this.numSegments-1),this.breakNormals&&(t+=this.profile.vertices.length),t+=this.profile.poles.length,t}getNumIndices(){let t=0;t+=2*this.profile.numSegments*(this.numSegments-1);for(let e=0;e<this.profile.numSegments;++e){const i=this.profile.vertexIndices[2*e+0],s=this.profile.vertexIndices[2*e+1];this.profile.poleIndices[i]===this.profile.poleIndices[s]?t+=1:t+=2}return 3*t}rebuildCapGeometry(t,e){const i=t.frame,s=.5*this.sign,r=ot,o=ht;l(o,0,0);for(let h=0;h<this.profile.poles.length;++h){const r=this.profile.poles[h];r.normal?e(t.index,i,r.position,r.normal,s,0):e(t.index,i,r.position,o,s,this.sign)}if(this.breakNormals)for(let h=0;h<this.profile.vertices.length;++h)e(t.index,i,this.profile.vertices[h],this.profile.vertexNormals[h],0,0);for(let h=0;h<this.numSegments-1;++h){const n=(1-(h+1)/this.numSegments)*Math.PI*.5,a=Math.sin(n),l=Math.cos(n);for(let h=0;h<this.profile.vertices.length;++h){const n=this.profile.poles[this.profile.poleIndices[h]];f(r,this.profile.vertices[h],n.position),c(r,r,a),n.normal?(x(r,r,n.position),e(t.index,i,r,n.normal,s*l,0)):(d(o,r),c(o,o,a),x(r,r,n.position),e(t.index,i,r,o,s*l,this.sign*l))}}}buildTopology(t,e){const i=this.breakNormals?this.vertexBufferStart+this.profile.poles.length:this.firstProfileVertexIndex,s=this.breakNormals?this.vertexBufferStart+this.profile.poles.length+this.profile.vertices.length:this.vertexBufferStart+this.profile.poles.length;for(let r=0;r<this.profile.numSegments;++r){const t=this.profile.vertexIndices[2*r+0],o=this.profile.vertexIndices[2*r+1],h=this.vertexBufferStart+this.profile.poleIndices[t],n=this.vertexBufferStart+this.profile.poleIndices[o];let a=i+t,l=i+o;for(let i=0;i<this.numSegments-1;++i){const r=s+i*this.profile.vertices.length+t,h=s+i*this.profile.vertices.length+o;this.flip?(e(r,l,a),e(l,r,h)):(e(a,l,r),e(h,r,l)),a=r,l=h}this.flip?(e(h,l,a),h!==n&&e(h,n,l)):(e(a,l,h),h!==n&&e(l,n,h))}}}class tt{constructor(t,e,i,s,r,o=W){this.options=o,this._extrusionVertexCount=0,this._triangleCount=0,this.numExtrusionProfiles=0,this.numVerticesTotal=0,this.numNormalsTotal=0,this.numUVTotal=0,this.profile=e,this.path=t,this.extruder=i,this.startCap=s,this.endCap=r;const h=this.path.vertices.length-2;this.numExtrusionProfiles=i.numProfilesPerJoin()*h+2,this.numVerticesTotal=e.vertices.length*this.numExtrusionProfiles,this.numNormalsTotal=this.numVerticesTotal,this.startCap.vertexBufferStart=this.numVerticesTotal;const n=this.startCap.getNumVertices();this.numVerticesTotal+=n,this.numNormalsTotal+=n,this.endCap.vertexBufferStart=this.numVerticesTotal;const a=this.endCap.getNumVertices();this.numVerticesTotal+=a,this.numNormalsTotal+=a,this.pathVertexData=new Float32Array(1*this.numVerticesTotal),this.profileRightAxisData=new Float32Array(4*this.numVerticesTotal),this.profileUpAxisData=new Float32Array(4*this.numVerticesTotal),this.profileVertexAndNormalData=new Float32Array(4*this.numVerticesTotal),this.profile.hasUV()&&this.options.generateUV&&(this.numUVTotal=this.profile.uvs.length,this.uvData=new Float32Array(2*this.numUVTotal)),this.originData=new Float32Array(3*this.path.vertices.length),this.rebuildGeometry(),this.buildTopology()}emitVertex(t,e,i,s,r){if(this.profileRightAxisData[4*this._extrusionVertexCount+0]=e.right[0],this.profileRightAxisData[4*this._extrusionVertexCount+1]=e.right[1],this.profileRightAxisData[4*this._extrusionVertexCount+2]=e.right[2],this.profileUpAxisData[4*this._extrusionVertexCount+0]=e.up[0],this.profileUpAxisData[4*this._extrusionVertexCount+1]=e.up[1],this.profileUpAxisData[4*this._extrusionVertexCount+2]=e.up[2],this.profileVertexAndNormalData[4*this._extrusionVertexCount+0]=i[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+1]=i[1],this.profileVertexAndNormalData[4*this._extrusionVertexCount+2]=s[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+3]=s[1],this.pathVertexData[this._extrusionVertexCount]=t,r){const e=this.path.vertices[t];this.profileRightAxisData[4*this._extrusionVertexCount+3]=e.rotationRight[0]*e.maxStretchDistance,this.profileUpAxisData[4*this._extrusionVertexCount+3]=e.rotationRight[1]*e.maxStretchDistance}else this.profileRightAxisData[4*this._extrusionVertexCount+3]=0,this.profileUpAxisData[4*this._extrusionVertexCount+3]=0;++this._extrusionVertexCount}emitCapVertex(t,e,i,s,r,o){this.profileRightAxisData[4*this._extrusionVertexCount+0]=e.right[0],this.profileRightAxisData[4*this._extrusionVertexCount+1]=e.right[1],this.profileRightAxisData[4*this._extrusionVertexCount+2]=e.right[2],this.profileUpAxisData[4*this._extrusionVertexCount+0]=e.up[0],this.profileUpAxisData[4*this._extrusionVertexCount+1]=e.up[1],this.profileUpAxisData[4*this._extrusionVertexCount+2]=e.up[2],this.profileVertexAndNormalData[4*this._extrusionVertexCount+0]=i[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+1]=i[1],this.profileVertexAndNormalData[4*this._extrusionVertexCount+2]=s[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+3]=s[1],this.pathVertexData[this._extrusionVertexCount]=t,this.profileRightAxisData[4*this._extrusionVertexCount+3]=r,this.profileUpAxisData[4*this._extrusionVertexCount+3]=o,++this._extrusionVertexCount}emitTriangle(t,e,i){this.vertexIndices[3*this._triangleCount+0]=t,this.vertexIndices[3*this._triangleCount+1]=e,this.vertexIndices[3*this._triangleCount+2]=i,this.pathVertexIndices[3*this._triangleCount+0]=this.pathVertexData[t],this.pathVertexIndices[3*this._triangleCount+1]=this.pathVertexData[e],this.pathVertexIndices[3*this._triangleCount+2]=this.pathVertexData[i],this.normalIndices[3*this._triangleCount+0]=t,this.normalIndices[3*this._triangleCount+1]=e,this.normalIndices[3*this._triangleCount+2]=i,++this._triangleCount}rebuildGeometry(){const t=(t,e,i,s,r)=>this.emitVertex(t,e,i,s,r),e=(t,e,i,s,r,o)=>this.emitCapVertex(t,e,i,s,r,o);this._extrusionVertexCount=0;for(const i of this.path.vertices)this.originData[3*i.index+0]=i.pos[0],this.originData[3*i.index+1]=i.pos[1],this.originData[3*i.index+2]=i.pos[2];this.startCap.rebuildConnectingProfileGeometry(this.path.vertices[0],this.profile,e);for(let i=1;i<this.path.vertices.length-1;++i)this.extruder.extrude(this.path.vertices[i],this.profile,t);if(this.endCap.rebuildConnectingProfileGeometry(this.path.vertices[this.path.vertices.length-1],this.profile,e),this.startCap.rebuildCapGeometry(this.path.vertices[0],e),this.endCap.rebuildCapGeometry(this.path.vertices[this.path.vertices.length-1],e),this.profile.hasUV()&&this.options.generateUV)for(let i=0;i<this.profile.uvs.length;++i)this.uvData[2*i+0]=this.profile.uvs[i],this.uvData[2*i+1]=0}buildTopology(){const t=(t,e,i)=>this.emitTriangle(t,e,i);this._triangleCount=0;const e=this.profile.vertices.length,i=this.profile.numSegments,s=this.numExtrusionProfiles-1;let r=3*(2*(i*s));this.startCap.indexBufferStart=r,this.startCap.firstProfileVertexIndex=0,r+=this.startCap.getNumIndices(),this.endCap.indexBufferStart=r,this.endCap.firstProfileVertexIndex=e*(this.numExtrusionProfiles-1),r+=this.endCap.getNumIndices(),this.vertexIndices=new Uint32Array(r),this.normalIndices=new Uint32Array(r),this.pathVertexIndices=new Uint32Array(r),this.profile.hasUV()&&this.options.generateUV&&(this.uvIndices=new Uint32Array(r));for(let o=0;o<i;++o){const i=this.profile.vertexIndices[2*o],r=this.profile.vertexIndices[2*o+1];for(let o=0;o<s;++o){const s=o*e+i,h=(o+1)*e+r,n=o*e+r;t(s,(o+1)*e+i,h),t(s,h,n)}}this.startCap.buildTopology(this.path.vertices[0],t),this.endCap.buildTopology(this.path.vertices[this.path.vertices.length-1],t)}onPathChanged(){this.rebuildGeometry()}}class et{constructor(t){this.builder=t}get xform(){return this.builder.path.xform}onPathChanged(){this.builder.onPathChanged()}}class it extends et{constructor(t){super(t),this.vertexAttributePosition=null,this.vertexAttributeNormal=null,this.vertexAttributeColor=null,this.vertexAttributePosition=new Float32Array(3*this.builder.numVerticesTotal),this.vertexAttributeNormal=new Float32Array(3*this.builder.numNormalsTotal),this.vertexAttributeColor=new Uint8Array(4),this.vertexAttributeColor[0]=255,this.vertexAttributeColor[1]=255,this.vertexAttributeColor[2]=255,this.vertexAttributeColor[3]=255}bakeVertexColors(t){this.vertexAttributeColor[0]=255*t[0],this.vertexAttributeColor[1]=255*t[1],this.vertexAttributeColor[2]=255*t[2],this.vertexAttributeColor[3]=255*(t.length>3?t[3]:1)}bake(e){this.size=e;for(let i=0;i<this.builder.numVerticesTotal;++i){let s=this.builder.pathVertexData[i];const r=0===s||s===this.builder.path.vertices.length-1;s*=3;const o=rt;U(o,this.builder.originData[s++],this.builder.originData[s++],this.builder.originData[s]);const h=4*i,n=at,a=ot,p=lt,f=ut,m=pt;let g=0,V=0;if(U(f,this.builder.profileRightAxisData[h],this.builder.profileRightAxisData[h+1],this.builder.profileRightAxisData[h+2]),U(m,this.builder.profileUpAxisData[h],this.builder.profileUpAxisData[h+1],this.builder.profileUpAxisData[h+2]),l(a,this.builder.profileVertexAndNormalData[h]*e[0],this.builder.profileVertexAndNormalData[h+1]*e[1]),r)R(p,m,f),g=this.builder.profileRightAxisData[h+3]*e[0],V=this.builder.profileUpAxisData[h+3];else{const e=ht,i=nt;l(e,this.builder.profileRightAxisData[h+3],this.builder.profileUpAxisData[h+3]);const s=v(e);d(e,e);const r=u(a,e);if(Math.abs(r)>s){l(i,-e[1],e[0]);const o=u(a,i);c(e,e,s*t(r)),c(i,i,o),x(a,e,i)}U(p,0,0,0)}U(n,f[0]*a[0]+m[0]*a[1],f[1]*a[0]+m[1]*a[1],f[2]*a[0]+m[2]*a[1]),this.vertexAttributePosition[3*i+0]=o[0]+n[0]+p[0]*g,this.vertexAttributePosition[3*i+1]=o[1]+n[1]+p[1]*g,this.vertexAttributePosition[3*i+2]=o[2]+n[2]+p[2]*g;const b=ot;l(b,this.builder.profileVertexAndNormalData[h+2],this.builder.profileVertexAndNormalData[h+3]),this.vertexAttributeNormal[3*i+0]=f[0]*b[0]+m[0]*b[1]+p[0]*V,this.vertexAttributeNormal[3*i+1]=f[1]*b[0]+m[1]*b[1]+p[1]*V,this.vertexAttributeNormal[3*i+2]=f[2]*b[0]+m[2]*b[1]+p[2]*V}}createGeometryData(){const t=[["position",this.builder.vertexIndices],["normal",this.builder.normalIndices]],e=[["position",{size:3,data:this.vertexAttributePosition,exclusive:!0}],["normal",{size:3,data:this.vertexAttributeNormal,exclusive:!0}]];if(this.vertexAttributeColor){const i=this.builder.vertexIndices.length;t.push(["color",new Uint32Array(i)]),e.push(["color",{size:4,data:this.vertexAttributeColor}])}return{vertexAttributes:e,indices:t}}onPathChanged(){super.onPathChanged(),this.bake(this.size)}intersect(t,e,i){const s=this.builder.vertexIndices,r={size:3,data:this.vertexAttributePosition},o=s.length/3;M(t,e,0,o,s,r,void 0,void 0,i)}}class st extends et{constructor(t,e,i,s){super(t),this.sizeAttributeValue=e,this.colorAttributeValue=i,this.opacityAttributeValue=s,this.vvData=null,this.baked=new it(t),this.vvData=new Float32Array(4*this.builder.path.vertices.length);for(let r=0;r<this.builder.path.vertices.length;++r){this.vvData[4*r+0]=e,this.vvData[4*r+1]=i,this.vvData[4*r+2]=s;const t=0===r||r===this.builder.path.vertices.length-1;this.vvData[4*r+3]=t?1:0}}createGeometryData(){return{vertexAttributes:[["position",{size:3,data:this.builder.originData,exclusive:!0}],["profileRight",{size:4,data:this.builder.profileRightAxisData,exclusive:!0}],["profileUp",{size:4,data:this.builder.profileUpAxisData,exclusive:!0}],["profileVertexAndNormal",{size:4,data:this.builder.profileVertexAndNormalData,exclusive:!0}],["featureValue",{size:4,data:this.vvData,exclusive:!0}]],indices:[["position",this.builder.pathVertexIndices],["profileRight",this.builder.vertexIndices],["profileUp",this.builder.vertexIndices],["profileVertexAndNormal",this.builder.vertexIndices],["featureValue",this.builder.pathVertexIndices]]}}}const rt=y(),ot=m(),ht=m(),nt=m(),at=y(),lt=y(),ut=y(),pt=y(),ft=y(),ct=w(),xt=a();export{tt as Builder,X as CapBuilder,H as Extruder,st as FastUpdatePathGeometry,Q as MiterExtruder,Y as NoCapBuilder,J as Path,et as PathGeometryData,E as PathVertex,O as Profile,$ as RoundCapBuilder,K as SimpleExtruder,it as StaticPathGeometry,Z as TriangulationCapBuilder,q as computeMinimumRotationTangentFrame,w as makeFrame,j as profileSpaceToVertexSpace,z as vertexSpaceToProfileSpace};
