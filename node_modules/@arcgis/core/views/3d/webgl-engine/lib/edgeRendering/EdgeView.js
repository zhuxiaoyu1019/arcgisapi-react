/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import t from"../../../../../core/Accessor.js";import{equals as r}from"../../../../../core/arrayUtils.js";import s from"../../../../../core/Logger.js";import{clamp as o}from"../../../../../core/mathUtils.js";import{disposeMaybe as i,destroyMaybe as n,isNone as a,isSome as c}from"../../../../../core/maybe.js";import{createAbortController as d}from"../../../../../core/promiseUtils.js";import{isUint16Array as l}from"../../../../../core/typedArrayUtil.js";import{property as m}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import{subclass as g}from"../../../../../core/accessorSupport/decorators/subclass.js";import{f as u,t as h,e as p}from"../../../../../chunks/mat3.js";import{c as f}from"../../../../../chunks/mat3f64.js";import{d as b}from"../../../../../chunks/mat4.js";import{c as y}from"../../../../../chunks/mat4f64.js";import{s as j,g as v,i as w}from"../../../../../chunks/vec3.js";import{c as O}from"../../../../../chunks/vec3f64.js";import{g as E}from"../../../../../chunks/sphere.js";import{c as x}from"../../../../../chunks/vec33.js";import{VertexPosition as R}from"../../core/shaderLibrary/attributes/VertexPosition.glsl.js";import{TwoVectorPosition as M}from"../../core/util/TwoVectorPosition.js";import{GridLocalOriginFactory as T}from"../GridLocalOriginFactory.js";import{applyToModelMatrix as C}from"../localOriginHelper.js";import{LocalOriginManager as k}from"../LocalOriginManager.js";import{Object3D as P}from"../Object3D.js";import{VertexLayout as B,EdgeShaderAttributeLocations as D,glVertexLayout as L,EdgeInputBufferLayout as V}from"./bufferLayouts.js";import{RegularEdgeBufferWriter as A,SilhouetteEdgeBufferWriter as U}from"./edgeBufferWriters.js";import{EdgeRenderer as S,LINE_WIDTH_FRACTION_FACTOR as H,EXTENSION_LENGTH_OFFSET as I}from"./EdgeRenderer.js";import z from"./EdgeWorkerHandle.js";import{generateStrokesTexture as F}from"./strokes.js";import{determineRendererType as _,estimateLengthAtDistance as G,determineEdgeTransparency as K,determineObjectTransparency as q,fillComponenBufferIndices as N,computeEdgeCount as W}from"./util.js";import{BufferManager as Y}from"../TextureBackedBuffer/BufferManager.js";import{WatchUpdatingTracking as J}from"../../../../support/WatchUpdatingTracking.js";import Q from"../../../../webgl/BufferObject.js";import X from"../../../../webgl/VertexArrayObject.js";const Z=s.getLogger("esri.views.3d.webgl-engine.lib.edgeRendering.EdgeView");let $=class extends t{constructor(e){super(e),this.updatingHandles=new J,this.perObjectData=new Map,this.renderers=new Map,this.numberOfRenderedEdges=0,this.gpuMemoryUsage=0,this.workerAbort=d(),this.tmpModelPosition=O(),this.tmpCameraPosition=O(),this.localOrigins=new k(new T(e.renderSR))}initialize(){this.worker=new z(this.schedule),this.componentColorManager=new Y(this.rctx,2);const e=B.createBuffer(4);for(let t=0;t<4;t++)e.sideness.set(t,0,0===t||3===t?0:1),e.sideness.set(t,1,0===t||1===t?0:1);this.verticesBufferObject=Q.createVertex(this.rctx,35044,e.buffer)}destroy(){this.destroyed||(this.perObjectData.forEach((e=>this._discardObjectEntry(e))),this.perObjectData.clear(),this.strokesTexture=i(this.strokesTexture),this.componentColorManager=n(this.componentColorManager),this.workerAbort.abort(),this.worker.destroy(),this.verticesBufferObject=i(this.verticesBufferObject),this.renderers.clear(),this.updatingHandles.destroy())}get updating(){return this.updatingHandles.updating}get usedMemory(){return this.gpuMemoryUsage}get numberOfRenderedPrimitives(){return this.numberOfRenderedEdges}shouldRender(){return this.renderers.size>0}async addComponentObject(e,t,r,s,o,i,n,a){if(this.hasObject(e))return;let c;const d=new re(new Promise((e=>c=e)),r);this.perObjectData.set(e,d),await this.updatingHandles.addPromise(this.addComponentGeometry(t,d,s,o,i,n,a)),this.setNeedsRender(),c()}async addOrUpdateObject3D(e,t,r,s){if(this.destroyed)return void Z.warn("Attempt to add an object to a destroyed instance");const o=this.perObjectData.get(e);let i;const n=new re(new Promise((e=>i=e)));this.perObjectData.set(e,n);const a=new Array;if(r.mergeGeometries&&e.geometries.length>1&&te(e))a.push(this.addObjectMergedGeometries(e,n,t,r,s));else for(let c=0;c<e.geometries.length;c++){const o=e.geometries[c],i=e.geometryRecords[c];i.material.supportsEdges&&a.push(this.addGeometry(e,n,o,i,t[0],r,s))}await this.updatingHandles.addPromise(Promise.all(a)),this._discardObjectEntry(o),this.setNeedsRender(),i()}_discardObjectEntry(e){e&&(e.renderables.length&&(e.renderables.forEach((e=>this.removeRenderable(e))),this.setNeedsRender()),e.loaded=null)}hasObject(e){return this.perObjectData.has(e)}async updateAllComponentOpacities(e,t){const r=t instanceof Array?e=>t[e]:()=>t;(await this.updatingHandles.addPromise(this.getObjectEntry(e))).renderables.forEach((e=>{const t=e.components.meta.length;for(let s=0;s<t;s++){const t=r(s),o=e.components.meta[s],i=o.index;o.material.opacity=t,e.components.buffer.textureBuffer.setDataElement(i,1,3,255*t)}this.updateTransparency(e)})),this.setNeedsRender()}async updateAllComponentMaterials(e,t,r,s){const o=e instanceof P,i=!!r.slicePlaneEnabled,n=_(t),a=S.getKey(n,i,o);(await this.updatingHandles.addPromise(this.getObjectEntry(e))).renderables.forEach((e=>{if(a!==e.rendererKey){const t=this.renderers.get(e.rendererKey),r=this.acquireRenderer(n,i,o);t.removeRenderable(e),t.refCount.decrement(),e.rendererKey=a,r.addRenderable(e)}for(let r=0;r<t.length;r++)e.components.meta[r].material=t[r];s&&this.updateComponentBuffer(e.components),this.updateTransparency(e)})),this.setNeedsRender()}async updateObjectVisibility(e,t){(await this.updatingHandles.addPromise(this.getObjectEntry(e))).renderables.forEach((e=>e.visible=t)),this.setNeedsRender()}removeObject(e){const t=this.perObjectData.get(e);t&&(this.perObjectData.delete(e),this._discardObjectEntry(t))}async getObjectEntry(e){const t=this.perObjectData.get(e);if(!t)throw"no object";return await t.loaded,t}removeAll(){this.perObjectData.forEach(((e,t)=>this.removeObject(t)))}render(e,t){if(a(this.componentColorManager))return;this.localOrigins.updateViewMatrices(e.camera.viewMatrix);const r=e.camera.viewInverseTransposeMatrix,s=O(),o=new M,i=new R.ViewProjectionTransform,n=f();j(s,r[3],r[7],r[11]),o.set(s),v(i.worldFromView_TH,o.high),v(i.worldFromView_TL,o.low),u(i.viewFromCameraRelative_RS,e.camera.viewMatrix),b(i.projFromView,e.camera.projectionMatrix);const c=f();h(c,i.viewFromCameraRelative_RS),p(n,c);let d=0,l=0;if(this.renderers.forEach((e=>{0===e.refCount.value?(this.renderers.delete(e.key),e.dispose()):e.forEachRenderable((e=>{d+=e.statistics.averageEdgeLength,l++}),t)})),this.componentColorManager.garbageCollect(),this.componentColorManager.updateTextures(),0===l)return;const m={distanceFalloffFactor:40*d/l,minimumEdgeLength:G(e.camera.fullViewport[3],e.camera.fovY,1,3.5*e.camera.pixelRatio),transparency:t,viewProjectionTransform:i,transformNormal_ViewFromGlobal:n};this.updateObjectCameraDistances(e),this.numberOfRenderedEdges=0,this.renderers.forEach((t=>{this.renderRegularEdges(t,e,m),this.renderSilhouetteEdges(t,e,m)}))}updateTransparency(e){const t=K(e.components.meta),r=q(e.components.meta);t===e.edgeTransparency&&r===e.objectTransparency||(e.edgeTransparency=t,e.objectTransparency=r,this.renderers.get(e.rendererKey).setRenderablesDirty())}computeModelTransformWithLocalOrigin(e,t,r){if(e.getCombinedStaticTransformation(t,r),c(t.origin))this.localOrigins.register(t.origin);else{const e=j(this.tmpModelPosition,r[12],r[13],r[14]);t.origin=this.localOrigins.acquire(e)}return C(t.origin.vec3,r),t.origin}updateComponentBuffer(e){const{meta:t,buffer:r}=e;for(let s=0;s<t.length;s++){const e=t[s].material,i=t[s].index,n=o(Math.round(e.size*H),0,255),a=o(e.extensionLength,-I,255-I)+I,c="solid"===e.type?0:1,d=255*e.opacity,l=e.color,m=255*l[0],g=255*l[1],u=255*l[2],h=255*l[3];r.textureBuffer.setData(i,0,m,g,u,h),r.textureBuffer.setData(i,1,n,a,c,d)}}createComponentBuffers(e){if(a(this.componentColorManager))return null;const t=new Array,r=this.componentColorManager.getBuffer(e.length);for(let o=0;o<e.length;o++){const s=e[o],i=r.acquireIndex();t.push({index:i,material:s})}const s={meta:t,buffer:r};return this.updateComponentBuffer(s),s}extractEdges(e,t,r,s,o,i=o.length){return this.worker.process({data:t,indices:o,indicesLength:i,writerSettings:e,skipDeduplicate:r},this.workerAbort.signal,s)}createEdgeResources(e){const t={};if(a(this.verticesBufferObject))return t;if(e.regular.lodInfo.lengths.length>0){const r=new X(this.rctx,D,{vertices:L,instances:A.glLayout},{vertices:this.verticesBufferObject,instances:Q.createVertex(this.rctx,35044,e.regular.instancesData.buffer)});t.regular={vao:r,lod:e.regular.lodInfo}}if(e.silhouette.lodInfo.lengths.length>0){const r=new X(this.rctx,D,{vertices:L,instances:U.glLayout},{vertices:this.verticesBufferObject,instances:Q.createVertex(this.rctx,35044,e.silhouette.instancesData.buffer)});t.silhouette={vao:r,lod:e.silhouette.lodInfo}}return t}async addGeometry(e,t,r,s,o,i,n){const a=r.vertexAttributes.get("position"),c=r.indices.get("position"),d=y(),l={position:a,indices:c,modelTransform:d,origin:this.computeModelTransformWithLocalOrigin(e,s,d)};return this.addPositionData(t,l,r.edgeIndicesLength,o,i,n)}async addPositionData(e,t,r,s,o,i=!1){if(null==e.loaded)return;const n=this.createComponentBuffers([s]);if(a(n)||r<=0)return;const c=this.acquireRenderer(s.type,!!o.slicePlaneEnabled),{modelTransform:d,origin:l}=t,m=t.indices,g=t.position,u=g.data.length/g.size,h=V.createBuffer(u);for(let a=0;a<u;a++)h.position.set(a,0,g.data[a*g.size+0]),h.position.set(a,1,g.data[a*g.size+1]),h.position.set(a,2,g.data[a*g.size+2]);N(n.meta,[0,h.componentIndex.count],h.componentIndex);const p=await this.updatingHandles.addPromise(this.extractEdges(c.writerSettings,h,!1,i,m,r));if(null==e.loaded)return;const{regular:f,silhouette:b}=this.createEdgeResources(p),y=(f?f.vao.size:0)+(b?b.vao.size:0),j={regular:f,silhouette:b,transform:{modelMatrix:d,origin:l},statistics:{gpuMemoryUsage:y,averageEdgeLength:p.averageEdgeLength},components:n,visible:!0,edgeTransparency:K(n.meta),objectTransparency:q(n.meta),distanceToCamera:0,rendererKey:c.key};e.renderables.push(j),c.addRenderable(j),this.gpuMemoryUsage+=y}async addComponentGeometry(e,t,r,s,o,i,n){if(null==t.loaded)return;const c=this.createComponentBuffers(i);if(a(c))return;const d=_(i),l=this.acquireRenderer(d,n.slicePlaneEnabled||!1,!1),m=V.createBuffer(r.count);x(m.position,r),N(c.meta,o,m.componentIndex,s);const g=!0,u=l.writerSettings,h=await this.updatingHandles.addPromise(this.extractEdges(u,m,g,!1,s));if(null==t.loaded)return;const{regular:p,silhouette:f}=this.createEdgeResources(h),b=(p?p.vao.size:0)+(f?f.vao.size:0),y={regular:p,silhouette:f,transform:e,statistics:{gpuMemoryUsage:b,averageEdgeLength:h.averageEdgeLength},components:c,visible:!0,edgeTransparency:K(c.meta),objectTransparency:q(c.meta),distanceToCamera:0,rendererKey:l.key};t.renderables.push(y),l.addRenderable(y),this.gpuMemoryUsage+=b}async addObjectMergedGeometries(e,t,r,s,o){const i=new Map;let n=0,a=null,c=null;for(let b=0;b<e.geometries.length;b++){const t=e.geometries[b],r=e.geometryRecords[b];if(!r.material.supportsEdges)continue;!c&&r.origin&&(c=r);const s=t.indices.get("position");n+=t.edgeIndicesLength,null!=a&&a!==Uint16Array||(a=l(s)?Uint16Array:Uint32Array)}const d=n?new a(n):null,m=[];let g=0;for(let l=0;l<e.geometries.length;l++){const t=e.geometries[l];if(!e.geometryRecords[l].material.supportsEdges)continue;const r=t.vertexAttributes.get("position"),s=t.indices.get("position");let o=i.get(r.data);if(null==o){o=m.length/3;for(let e=0;e<r.data.length;e+=r.size)m.push(r.data[e+0]),m.push(r.data[e+1]),m.push(r.data[e+2]);i.set(r.data,o)}if(s)for(let e=0;e<t.edgeIndicesLength;e++)d[g++]=o+s[e]}const u=c||e.geometryRecords[0],h=y(),p=this.computeModelTransformWithLocalOrigin(e,u,h);for(let l=0;l<e.geometryRecords.length;l++)e.geometryRecords[l].origin=p;const f={position:{data:m,size:3},indices:d,modelTransform:h,origin:p};await this.updatingHandles.addPromise(this.addPositionData(t,f,d.length,r[0],s,o))}acquireRenderer(e,t,r=!0){const s=S.getKey(e,t,r);let o=this.renderers.get(s);return a(this.strokesTexture)&&(this.strokesTexture=F(this.rctx)),o||(o=new S(this.rctx,this.techniqueRepository,{type:e,slicePlaneEnabled:t,strokesTexture:this.strokesTexture,legacy:r}),this.renderers.set(s,o)),o.refCount.increment(),o}removeRenderable(e){ee(e);const t=this.renderers.get(e.rendererKey);if(t){t.removeRenderable(e),t.refCount.decrement(),"origin"in e.transform&&this.localOrigins.release(e.transform.origin),this.gpuMemoryUsage-=e.statistics.gpuMemoryUsage;for(const t of e.components.meta)e.components.buffer.releaseIndex(t.index)}}updateObjectCameraDistances(e){const t=e.camera.viewInverseTransposeMatrix;j(this.tmpCameraPosition,t[3],t[7],t[11]),this.perObjectData.forEach(((e,t)=>{const r=c(e.center)?e.center:E(t.boundingVolumeWorldSpace.bounds),s=w(r,this.tmpCameraPosition);e.renderables.forEach((e=>e.distanceToCamera=s))}))}renderRegularEdges(e,t,r){e.bindRegularEdges(t,r);const s=r.transparency;e.forEachRenderable((s=>{if(!s.visible||!s.regular)return;const o=W(s.regular.lod.lengths,s.distanceToCamera,r);"origin"in s.transform&&(t.localViewMatrixForEdges=this.localOrigins.getViewMatrix(s.transform.origin)),e.renderRegularEdges(s,t,o),this.numberOfRenderedEdges+=o}),s)}renderSilhouetteEdges(e,t,r){e.bindSilhouetteEdges(t,r);const s=r.transparency;e.forEachRenderable((s=>{if(!s.visible||!s.silhouette)return;const o=W(s.silhouette.lod.lengths,s.distanceToCamera,r);"origin"in s.transform&&(t.localViewMatrixForEdges=this.localOrigins.getViewMatrix(s.transform.origin)),e.renderSilhouetteEdges(s,t,o),this.numberOfRenderedEdges+=o}),s)}};function ee(e){e.regular&&(e.regular.vao.vertexBuffers.instances.dispose(),e.regular.vao.dispose(!1),e.regular.vao=null),e.silhouette&&(e.silhouette.vao.vertexBuffers.instances.dispose(),e.silhouette.vao.dispose(!1),e.silhouette.vao=null)}function te(e){let t=null,s=null;for(let i=0;i<e.geometries.length;i++){var o;const n=e.geometryRecords[i];if(n.material.supportsEdges){if(t){if(!r(t,n.transformation))return!1}else t=n.transformation;if(!s&&c(n.origin))s=n;else if(c(null==(o=s)?void 0:o.origin)&&c(n.origin)&&s.origin.id!==n.origin.id)return!1}}return!0}e([m({constructOnly:!0})],$.prototype,"rctx",void 0),e([m({constructOnly:!0})],$.prototype,"renderSR",void 0),e([m({constructOnly:!0})],$.prototype,"techniqueRepository",void 0),e([m({constructOnly:!0})],$.prototype,"setNeedsRender",void 0),e([m({constructOnly:!0})],$.prototype,"schedule",void 0),e([m({readOnly:!0})],$.prototype,"updatingHandles",void 0),e([m({readOnly:!0})],$.prototype,"updating",null),$=e([g("esri.views.3d.webgl-engine.lib.edgeRendering.EdgeView")],$);class re{constructor(e,t=null){this.center=t,this.renderables=new Array,this.loaded=e,this.loaded.then((()=>{null!=this.loaded&&(this.loaded=!0)}))}}export{$ as EdgeView};
