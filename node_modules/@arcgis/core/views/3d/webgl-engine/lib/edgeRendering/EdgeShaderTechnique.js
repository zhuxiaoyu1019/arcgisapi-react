/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import{VertexPosition as r}from"../../core/shaderLibrary/attributes/VertexPosition.glsl.js";import{ReloadableShaderModule as i}from"../../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as o}from"../../core/shaderTechnique/ShaderTechnique.js";import{parameter as t,ShaderTechniqueConfiguration as a}from"../../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{Program as s}from"../Program.js";import{EdgeShaderAttributeLocations as l}from"./bufferLayouts.js";import{E as n}from"../../../../../chunks/EdgeShaderProgram.glsl.js";import{makePipelineState as c,separateBlendingParams as u,defaultColorWriteParams as d,defaultDepthWriteParams as m}from"../../../../webgl/renderState.js";const f=-4e-4,p=.5;class h extends o{bindPass(e){const i=this.program,{edgeRenderParameters:o,bindParameters:t}=e;r.bindViewProjTransform(i,o.viewProjectionTransform),i.setUniformMatrix3fv("uTransformNormal_ViewFromGlobal",o.transformNormal_ViewFromGlobal),i.setUniformMatrix4fv("uProj",t.camera.projectionMatrix),i.setUniform2f("uDepthBias",p,f),i.setUniform2f("uPixelToNDC",2/t.camera.fullViewport[2],2/t.camera.fullViewport[3]),i.setUniform2f("uNDCToPixel",t.camera.fullViewport[2]/2,t.camera.fullViewport[3]/2),i.setUniform1f("uDistanceFalloffFactor",o.distanceFalloffFactor),i.setUniform2f("uViewportDimInv",1/t.camera.fullViewport[2],1/t.camera.fullViewport[3]),i.setUniform1f("uPixelRatio",t.camera.pixelRatio||1)}initializeProgram(e){const r=h.shader.get(),i=this.configuration,o=r.build({slicePlaneEnabled:i.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,silhouette:i.silhouette,legacy:i.legacy,antialiasing:i.antialiasing,mode:i.mode,doublePrecisionRequiresObfuscation:i.doublePrecisionRequiresObfuscation,multipassTerrainEnabled:i.multipassTerrainEnabled,cullAboveGround:i.cullAboveGround});return new s(e.rctx,o,l)}initializePipeline(e){const r=e.rctx.capabilities.blendMinMax;return c(r?{blending:u(1,1,0,1,32774,r.MAX),depthTest:{func:515},colorWrite:d}:{depthTest:{func:515},depthWrite:m,colorWrite:d})}}h.shader=new i(n,(()=>import("../../shaders/sources/edgeRenderer/EdgeShaderProgram.glsl.js"))),function(r){class i extends a{constructor(){super(...arguments),this.slicePlaneEnabled=!1,this.silhouette=!1,this.legacy=!1,this.antialiasing=!1,this.mode=0,this.doublePrecisionRequiresObfuscation=!1,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}e([t()],i.prototype,"slicePlaneEnabled",void 0),e([t()],i.prototype,"silhouette",void 0),e([t()],i.prototype,"legacy",void 0),e([t()],i.prototype,"antialiasing",void 0),e([t({count:3})],i.prototype,"mode",void 0),e([t()],i.prototype,"doublePrecisionRequiresObfuscation",void 0),e([t()],i.prototype,"multipassTerrainEnabled",void 0),e([t()],i.prototype,"cullAboveGround",void 0),r.Configuration=i}(h||(h={}));export{h as EdgeShaderTechnique};
