/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as i}from"../../../../chunks/tslib.es6.js";import{ReloadableShaderModule as r}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as o}from"../core/shaderTechnique/ShaderTechnique.js";import{ShaderTechniqueConfiguration as e,parameter as t}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{Default3D as s}from"../lib/DefaultVertexAttributeLocations.js";import{blendingDefault as a}from"../lib/OrderIndependentTransparency.js";import{Program as n}from"../lib/Program.js";import{S as p}from"../../../../chunks/ShadowAccumulation.glsl.js";import{makePipelineState as m,separateBlendingParams as h,defaultColorWriteParams as l}from"../../../webgl/renderState.js";class c extends o{initializeProgram(i){const r=c.shader.get().build(this.configuration);return new n(i.rctx,r,s)}initializePipeline(i){return 0===this.configuration.pass?m({blending:h(1,1,1,1),colorWrite:l,depthTest:null,depthWrite:null}):1===this.configuration.pass||2===this.configuration.pass?m({blending:a,colorWrite:l,depthTest:null,depthWrite:null}):m({})}bindPass(i){if(0===this.configuration.pass||2===this.configuration.pass){const r=i;this.program.bindTexture(r.linearDepthTexture,"depthMap"),r.shadowMap.bind(this.program),r.shadowMap.bindView(this.program,r.camera.center),this.program.setUniform2fv("nearFar",r.camera.nearFar),this.program.setUniformMatrix4fv("inverseView",r.inverseView),this.program.setUniform4fv("projInfo",r.projInfo),this.program.setUniform2fv("zScale",r.zScale)}else if(1===this.configuration.pass){const r=i;if(this.program.bindTexture(r.shadowAccumulationMap,"shadowAccumulationMap"),this.program.setUniform1f("sampleScale",r.sampleScale),this.program.setUniform1f("opacityFromElevation",r.opacityFromElevation),0===this.configuration.visualization){const r=i;this.program.bindTexture(r.colorRamp,"colorRamp"),this.program.setUniform1f("rampSize",r.rampSize),this.configuration.bandsEnabled&&this.program.setUniform1f("bandSize",r.bandSize)}else if(1===this.configuration.visualization){const r=i;this.program.setUniform1f("threshold",r.threshold),this.program.setUniform4fv("colors",r.colors)}}}get primitiveType(){return 5}}c.shader=new r(p,(()=>import("./ShadowAccumulation.glsl.js")));class d extends e{constructor(){super(...arguments),this.pass=0,this.visualization=0,this.bandsEnabled=!1}}i([t({count:3})],d.prototype,"pass",void 0),i([t()],d.prototype,"visualization",void 0),i([t()],d.prototype,"bandsEnabled",void 0);export{c as ShadowAccumulationTechnique,d as ShadowAccumulationTechniqueConfiguration};
