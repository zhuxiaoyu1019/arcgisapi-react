/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import{c as r}from"../../../../chunks/vec4f64.js";import{bindScreenSizeScalingUniforms as i}from"../core/shaderLibrary/ScreenSizeScaling.glsl.js";import{bindSliceUniformsWithOrigin as t}from"../core/shaderLibrary/Slice.glsl.js";import{bindMultipassTerrainTexture as o}from"../core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{bindProjectionMatrix as s,bindView as a,bindCameraPosition as n}from"../core/shaderLibrary/util/View.glsl.js";import{ReloadableShaderModule as l}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as p}from"../core/shaderTechnique/ShaderTechnique.js";import{ShaderTechniqueConfiguration as d,parameter as c}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{blendingDefault as h,OITBlending as m,OITDepthWrite as u,OITPolygonOffset as g}from"../lib/OrderIndependentTransparency.js";import{Program as b}from"../lib/Program.js";import{S as f}from"../../../../chunks/ShadedColorMaterial.glsl.js";import{makePipelineState as v,cullingParams as y,defaultDepthWriteParams as T,defaultColorWriteParams as E}from"../../../webgl/renderState.js";class S extends p{initializeProgram(e){const r=S.shader.get(),i=this.configuration,t=r.build({output:i.output,slicePlaneEnabled:i.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,screenSizeEnabled:i.screenSizeEnabled,shadingEnabled:i.shadingEnabled,OITEnabled:0===i.transparencyPassType,multipassTerrainEnabled:i.multipassTerrainEnabled,cullAboveGround:i.cullAboveGround});return new b(e.rctx,t,P)}bindPass(e,r){const{screenSizeEnabled:t,shadingEnabled:a}=this.configuration,{color:n,shadingTint:l,shadingDirection:p}=e;s(this.program,r.camera.projectionMatrix),this.program.setUniform4fv("color",n),r.multipassTerrainEnabled&&(this.program.setUniform2fv("cameraNearFar",r.camera.nearFar),this.program.setUniform2fv("inverseViewport",r.inverseViewport),o(this.program,r)),a&&(this.program.setUniform4fv("shadedColor",this.blendColor(w,l,n)),this.program.setUniform3fv("shadingDirection",p),this.program.setUniformMatrix4fv("viewNormal",r.camera.viewInverseTransposeMatrix)),t&&i(this.program,e,r)}bindDraw(e){a(this.program,e),n(this.program,e.origin,e.camera.viewInverseTransposeMatrix),t(this.program,this.configuration,e),this.program.rebindTextures()}blendColor(e,r,i){const t=1-r[3],o=r[3]+i[3]*t;return 0===o?(e[3]=o,e):(e[0]=(r[0]*r[3]+i[0]*i[3]*t)/o,e[1]=(r[1]*r[3]+i[1]*i[3]*t)/o,e[2]=(r[2]*r[3]+i[2]*i[3]*t)/o,e[3]=i[3],e)}setPipelineState(e){const r=this.configuration,i=3===e,t=2===e;return v({blending:0!==r.output&&7!==r.output||!r.transparent?null:i?h:m(e),culling:y(r.cullFace),depthTest:{func:t?513:r.shadingEnabled?515:513},depthWrite:i?r.writeDepth&&T:u(e),colorWrite:E,polygonOffset:i||t?null:g})}initializePipeline(){return this.setPipelineState(this.configuration.transparencyPassType)}}S.shader=new l(f,(()=>import("./ShadedColorMaterial.glsl.js")));class j extends d{constructor(){super(...arguments),this.output=0,this.cullFace=0,this.slicePlaneEnabled=!1,this.transparent=!1,this.writeDepth=!0,this.screenSizeEnabled=!0,this.shadingEnabled=!0,this.transparencyPassType=3,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}e([c({count:8})],j.prototype,"output",void 0),e([c({count:3})],j.prototype,"cullFace",void 0),e([c()],j.prototype,"slicePlaneEnabled",void 0),e([c()],j.prototype,"transparent",void 0),e([c()],j.prototype,"writeDepth",void 0),e([c()],j.prototype,"screenSizeEnabled",void 0),e([c()],j.prototype,"shadingEnabled",void 0),e([c({count:4})],j.prototype,"transparencyPassType",void 0),e([c()],j.prototype,"multipassTerrainEnabled",void 0),e([c()],j.prototype,"cullAboveGround",void 0);const P=new Map([["position",0],["normal",1],["offset",2]]),w=r();export{S as ShadedColorMaterialTechnique,j as ShadedColorMaterialTechniqueConfiguration,P as ShadedColorMaterialVertexAttrLocations};
