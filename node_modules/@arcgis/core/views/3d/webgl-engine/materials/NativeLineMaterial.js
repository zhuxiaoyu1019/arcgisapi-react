/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import e from"../../../../core/Logger.js";import{isSome as t,isNone as r}from"../../../../core/maybe.js";import{createRenderScreenPointArray3 as s}from"../../../../core/screenUtils.js";import{c as i}from"../../../../chunks/vec2.js";import{s as n,f as o,d as a,a as c,b as u,g as l,l as p,i as m}from"../../../../chunks/vec3.js";import{c as f}from"../../../../chunks/vec3f64.js";import{distance2 as h,fromPoints as d,closestLineSegmentPoint as g,create as b}from"../../../../geometry/support/lineSegment.js";import{fromPoints as j,signedDistance as P,normal as v,create as C}from"../../../../geometry/support/plane.js";import{BufferViewVec3f as q}from"../../../../geometry/support/buffer/BufferView.js";import{computeAttachmentOriginLines as y}from"../lib/geometryDataUtils.js";import x from"../lib/GLMaterial.js";import{Material as _,materialParametersDefaults as L}from"../lib/Material.js";import{isTranslationMatrix as O}from"../lib/Util.js";import{writeDefaultAttributes as w}from"./internal/bufferWriterUtils.js";import{PositionColorLayout as A,PositionLayout as S,DefaultBufferWriter as B}from"./internal/DefaultBufferWriter.js";import{intersectDrapedRenderLineGeometry as E}from"./internal/MaterialUtil.js";import{isInstanceHidden as R}from"./renderers/utils.js";import{NativeLineTechniqueConfiguration as T,NativeLineTechnique as M}from"../shaders/NativeLineTechnique.js";const U=e.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial");class H extends _{constructor(e){super(e,V),this.techniqueConfig=new T}getTechniqueConfig(e){this.techniqueConfig.output=e,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.transparent=this.params.color[3]<1||this.params.width<1;const r=t(this.params.stipplePattern);return this.techniqueConfig.stippleEnabled=r,this.techniqueConfig.stippleOffColorEnabled=r&&t(this.params.stippleOffColor),this.techniqueConfig.stippleIntegerRepeatsEnabled=r&&this.params.stippleIntegerRepeats,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,this.techniqueConfig}getPassParameters(){return this.params}intersect(e,t,r,s,i,n,o,a,c){c?E(e,s,n,1,o):this.intersectLineGeometry(e,t,r,s,o)}intersectLineGeometry(e,t,r,s,f){if(!s.options.selectionMode||R(t))return;if(!O(r))return void U.error("intersection assumes a translation-only matrix");const b=e.vertexAttributes.get("position").data,C=s.camera,q=Y;i(q,s.point);const y=2;n(Z[0],q[0]-y,q[1]+y,0),n(Z[1],q[0]+y,q[1]+y,0),n(Z[2],q[0]+y,q[1]-y,0),n(Z[3],q[0]-y,q[1]-y,0);for(let i=0;i<4;i++)if(!C.unprojectFromRenderScreen(Z[i],$[i]))return;j(C.eye,$[0],$[1],ee),j(C.eye,$[1],$[2],te),j(C.eye,$[2],$[3],re),j(C.eye,$[3],$[0],se);let x=Number.MAX_VALUE;for(let i=0;i<b.length-5;i+=3){if(k[0]=b[i]+r[12],k[1]=b[i+1]+r[13],k[2]=b[i+2]+r[14],I[0]=b[i+3]+r[12],I[1]=b[i+4]+r[13],I[2]=b[i+5]+r[14],P(ee,k)<0&&P(ee,I)<0||P(te,k)<0&&P(te,I)<0||P(re,k)<0&&P(re,I)<0||P(se,k)<0&&P(se,I)<0)continue;if(C.projectToRenderScreen(k,F),C.projectToRenderScreen(I,X),F[2]<0&&X[2]>0){o(W,k,I);const e=C.frustum,t=-P(e[4],k)/a(W,v(e[4]));c(W,W,t),u(k,k,W),C.projectToRenderScreen(k,F)}else if(F[2]>0&&X[2]<0){o(W,I,k);const e=C.frustum,t=-P(e[4],I)/a(W,v(e[4]));c(W,W,t),u(I,I,W),C.projectToRenderScreen(I,X)}else if(F[2]<0&&X[2]<0)continue;F[2]=0,X[2]=0;const e=h(d(F,X,K),q);e<x&&(x=e,l(z,k),l(J,I))}const _=s.rayBeginPoint,L=s.rayEndPoint;if(x<y*y){let e=Number.MAX_VALUE;if(g(d(z,J,K),d(_,L,Q),D)){o(D,D,_);const t=p(D);c(D,D,1/t),e=t/m(_,L)}f(e,D)}}computeAttachmentOrigin(e,t){const r=e.vertexAttributes;if(!r)return!1;const s=r.get("position");return y(s,null,!1,t)}createBufferWriter(){const e=this.params.vertexColors?A:S;return r(this.params.stipplePattern)?new B(e):new N(e.clone().vec3f("auxpos1"))}getGLMaterial(e){return 0===e.output||4===e.output?new G(e):void 0}}class G extends x{constructor(e){super(e),this.updateParameters()}updateParameters(){this._technique=this._techniqueRep.releaseAndAcquire(M,this._material.getTechniqueConfig(this._output),this._technique)}beginSlot(e){return 3===e}_updateOccludeeState(e){e.hasOccludees!==this._material.params.sceneHasOcludees&&(this._material.setParameterValues({sceneHasOcludees:e.hasOccludees}),this.updateParameters())}ensureParameters(e){0===this._output&&this._updateOccludeeState(e)}bind(e){this._technique.bindPass(this._material.getPassParameters(),e)}getPipelineState(e,t){return this._technique.getPipelineState(t)}}class N{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get("position").length}write(e,t,r,s){w(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,r,s),this.writeAuxpos1(e,t,r,s)}writeAuxpos1(e,t,r,s){const i=r.getField("auxpos1",q),n=t.indices.get("position"),o=t.vertexAttributes.get("position").data,a=e.transformation,c=i.typedBufferStride,u=i.typedBuffer;s*=c;for(let l=0;l<n.length;l+=2){const e=3*n[l],t=o[e],r=o[e+1],i=o[e+2],p=a[0]*t+a[4]*r+a[8]*i+a[12],m=a[1]*t+a[5]*r+a[9]*i+a[13],f=a[2]*t+a[6]*r+a[10]*i+a[14];for(let n=0;n<2;++n)u[s]=p,u[s+1]=m,u[s+2]=f,s+=c}}}const V={color:[1,1,1,1],vertexColors:!1,slicePlaneEnabled:!1,width:1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null,sceneHasOcludees:!1,...L},k=f(),I=f(),W=f(),D=f(),F=s(),X=s(),z=f(),J=f(),K=b(),Q=b(),Y=f(),Z=[s(),s(),s(),s()],$=[f(),f(),f(),f()],ee=C(),te=C(),re=C(),se=C();export{H as NativeLineMaterial};
