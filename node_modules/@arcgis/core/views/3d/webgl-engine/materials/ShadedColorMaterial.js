/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{n as e,s as t,a as r,b as i}from"../../../../chunks/vec3.js";import{c as s}from"../../../../chunks/vec3f64.js";import{center as a,scale as n}from"../../../../geometry/support/aaBoundingBox.js";import{BufferViewVec3f as o}from"../../../../geometry/support/buffer/BufferView.js";import{newLayout as u}from"../../support/buffer/InterleavedLayout.js";import c from"../lib/GLMaterial.js";import{Material as h,materialParametersDefaults as f}from"../lib/Material.js";import{assert as l}from"../lib/Util.js";import{writeDefaultAttributes as p,writePosition as m}from"./internal/bufferWriterUtils.js";import{intersectTriangleGeometry as d}from"./internal/MaterialUtil.js";import{ShadedColorMaterialTechniqueConfiguration as b,ShadedColorMaterialVertexAttrLocations as g,ShadedColorMaterialTechnique as q}from"../shaders/ShadedColorMaterialTechnique.js";class v extends h{constructor(e){super(e,C),this.supportsEdges=!0,this.techniqueConfig=new b,this._vertexAttributeLocations=g}getTechniqueConfig(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.cullFace=this.params.cullFace,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.screenSizeEnabled=this.params.screenSizeEnabled,this.techniqueConfig.shadingEnabled=this.params.shadingEnabled,this.techniqueConfig.transparencyPassType=t?t.transparencyPassType:3,this.techniqueConfig.multipassTerrainEnabled=!!t&&t.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=!!t&&t.cullAboveGround,this.techniqueConfig}getPassParameters(){return this.params}intersect(e,s,o,u,c,h,f){if(this.params.screenSizeEnabled){const o=e.vertexAttributes.get("offset"),l={applyToVertex:(e,s,a,n)=>{const c=t(P,o.data[3*n+0],o.data[3*n+1],o.data[3*n+2]),h=t(x,e,s,a);return r(c,c,this.params.screenSize*u.camera.computeRenderPixelSizeAt(c)),i(h,h,c),[h[0],h[1],h[2]]},applyToAabb:e=>{const t=a(e,P);return n(e,this.params.screenSize*u.camera.computeRenderPixelSizeAt(t))}};d(e,s,u,c,h,l,f)}else d(e,s,u,c,h,void 0,f)}getGLMaterial(e){return 0===e.output||7===e.output||4===e.output?new E(e):void 0}createBufferWriter(){return new S(this.params.screenSizeEnabled)}}class E extends c{constructor(e){super(e),this.updateParameters()}updateParameters(e){this._technique=this._techniqueRep.releaseAndAcquire(q,this._material.getTechniqueConfig(this._output,e),this._technique)}beginSlot(e){if(4===this._output)return 3===e;let t=3;return this._technique.configuration.transparent&&(t=this._technique.configuration.writeDepth?5:8),e===t}ensureParameters(e){this.updateParameters(e)}bind(e){this._technique.bindPass(this._material.getPassParameters(),e)}}const C={color:[1,1,1,1],shadingTint:[0,0,0,.25],shadingDirection:e(s(),[.5,-.5,-.5]),transparent:!1,writeDepth:!0,slicePlaneEnabled:!1,cullFace:0,screenSizeEnabled:!1,screenSize:14,shadingEnabled:!0,...f};class S{constructor(e){this.screenSizeEnabled=e;const t=u().vec3f("position").vec3f("normal");this.screenSizeEnabled&&t.vec3f("offset"),this.vertexBufferLayout=t}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get("position").length}write(e,t,r,i){if(p(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,r,i),this.screenSizeEnabled){if(!t.vertexAttributes.has("offset"))throw new Error("offset vertex attribute required for screenSizeEnabled ShadedColorMaterial");{const s=t.vertexAttributes.get("offset"),a=t.indices.get("offset");l(3===s.size);const n=r.getField("offset",o);if(!n)throw new Error("unable to acquire view for offset");m(a,s.data,e.invTranspTransformation,n,i)}}}}const P=s(),x=s();export{v as ShadedColorMaterial};
