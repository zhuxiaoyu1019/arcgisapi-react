/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{clamp as e}from"../../../../core/mathUtils.js";import{isNone as t}from"../../../../core/maybe.js";import{fromValues as i}from"../../../../geometry/support/aaBoundingBox.js";import{BufferViewVec4f as s}from"../../../../geometry/support/buffer/BufferView.js";import{newLayout as a}from"../../support/buffer/InterleavedLayout.js";import{computeAttachmentOriginLines as r}from"../lib/geometryDataUtils.js";import n from"../lib/GLMaterial.js";import{Material as o,materialParametersDefaults as u}from"../lib/Material.js";import{isPathGeometry as h}from"../lib/PathGeometry.js";import{assert as c}from"../lib/Util.js";import{pathVertexAttributeLocations as l,PathTechniqueConfiguration as p,PathTechnique as d}from"./PathTechnique.js";import f from"./VisualVariableMaterialParameters.js";import{writeDefaultAttributes as m,writeBufferVec4 as b}from"./internal/bufferWriterUtils.js";import{intersectAabbInvDir as v}from"./internal/MaterialUtil.js";const g=c;class S extends o{constructor(e){super(e,y),this.supportsEdges=!0,this._vertexAttributeLocations=l,this.techniqueConfig=new p,this.vertexBufferLayout=S.getVertexBufferLayout(this.params)}getTechniqueConfig(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.vvSize=this.params.vvSizeEnabled,this.techniqueConfig.vvColor=this.params.vvColorEnabled,this.techniqueConfig.vvOpacity=this.params.vvOpacityEnabled,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,0!==e&&7!==e||(this.techniqueConfig.doubleSidedMode=this.params.doubleSided&&"normal"===this.params.doubleSidedType?1:this.params.doubleSided&&"winding-order"===this.params.doubleSidedType?2:0,this.techniqueConfig.receiveShadows=this.params.receiveShadows,this.techniqueConfig.receiveSSAO=!(!t||!t.ssaoEnabled)&&this.params.receiveSSAO),this.techniqueConfig.transparencyPassType=t?t.transparencyPassType:3,this.techniqueConfig.multipassTerrainEnabled=!!t&&t.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=!!t&&t.cullAboveGround,this.techniqueConfig}getPassParameters(){return this.params}isVisibleInPass(e){return 4!==e&&6!==e&&7!==e||this.params.castShadows}isVisible(){const e=this.params;return!!super.isVisible()&&e.opacity>0}intersect(s,a,r,n,o,u,c){const l=s;if(!h(l))return;const p=l.path,d=[this.params.size[0],this.params.size[1]];if(this.params.vvSizeEnabled){const t=this.params.vvSizeOffset,i=this.params.vvSizeFactor,s=this.params.vvSizeMinSize,a=this.params.vvSizeMaxSize,r=p.sizeAttributeValue;d[0]*=e(t[0]+r*i[0],s[0],a[0]),d[1]*=e(t[2]+r*i[2],s[2],a[2])}const f=Math.max(d[0],d[1]),m=s.boundingInfo;if(t(m))return void this._intersectTriangles(p,d,o,u,c);const b=i(m.bbMin[0]-f,m.bbMin[1]-f,m.bbMin[2]-f,m.bbMax[0]+f,m.bbMax[1]+f,m.bbMax[2]+f),g=[u[0]-o[0],u[1]-o[1],u[2]-o[2]],S=Math.sqrt(g[0]*g[0]+g[1]*g[1]+g[2]*g[2]),q=[S/g[0],S/g[1],S/g[2]];v(b,o,q,n.tolerance)&&this._intersectTriangles(p,d,o,u,c)}_intersectTriangles(e,t,i,s,a){e.baked.size&&e.baked.size[0]===t[0]&&e.baked.size[1]===t[1]||e.baked.bake(t),e.baked.intersect(i,s,a)}computeAttachmentOrigin(e,t){const i=e.vertexAttributes;if(!i)return null;const s=i.get("position");return r(s,null,!1,t)}createBufferWriter(){return new x(this.vertexBufferLayout)}getGLMaterial(e){if(0===e.output||7===e.output||1===e.output||2===e.output||4===e.output||3===e.output&&this.params.castShadows)return new q(e)}static getVertexBufferLayout(e){let t=a().vec3f("position").vec4f("profileRight").vec4f("profileUp").vec4f("profileVertexAndNormal");return(e.vvColorEnabled||e.vvSizeEnabled||e.vvOpacityEnabled)&&(t=t.vec4f("featureValue")),t}}class q extends n{constructor(e){super(e),this.updateParameters()}updateParameters(e){this._technique=this._techniqueRep.releaseAndAcquire(d,this._material.getTechniqueConfig(this._output,e),this._technique)}beginSlot(e){return e===(this._technique.configuration.transparent?5:3)}_updateOccludeeState(e){e.hasOccludees!==this._material.params.sceneHasOcludees&&this._material.setParameterValues({sceneHasOcludees:e.hasOccludees})}_updateShadowState(e){e.shadowMappingEnabled!==this._technique.configuration.receiveShadows&&this._material.setParameterValues({receiveShadows:e.shadowMappingEnabled})}ensureParameters(e){0!==this._output&&7!==this._output||(this._updateShadowState(e),this._updateOccludeeState(e)),this.updateParameters(e)}bind(e){this._technique.bindPass(this._material.getPassParameters(),e)}}const y={size:[1,1,1],ambient:[.2,.2,.2],diffuse:[.8,.8,.8],specular:[0,0,0],opacity:1,doubleSided:!1,doubleSidedType:"normal",receiveSSAO:!0,receiveShadows:!1,castShadows:!0,slicePlaneEnabled:!1,transparent:!1,sceneHasOcludees:!1,...f.Default,...u};class x{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get("position").length}write(e,t,i,a){const r=e=>{if(t.vertexAttributes.has(e)){const r=t.vertexAttributes.get(e),n=t.indices.get(e);g(4===r.size);const o=i.getField(e,s);if(!o)throw new Error("unable to acquire view for "+e);b(n,r.data,o,a)}};r("profileRight"),r("profileUp"),r("profileVertexAndNormal"),this.vertexBufferLayout.hasField("featureValue")&&r("featureValue"),m(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,i,a)}}export{S as PathMaterial};
