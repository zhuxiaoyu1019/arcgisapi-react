/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import{clamp as e}from"../../../../core/mathUtils.js";import{f as o}from"../../../../chunks/mat3.js";import{c as t}from"../../../../chunks/mat3f64.js";import{i,r as n,b as r,j as s,d as l,h as a,m as u,s as f,t as c}from"../../../../chunks/mat4.js";import{c as p}from"../../../../chunks/mat4f64.js";import{s as v}from"../../../../chunks/vec3.js";import{c as d}from"../../../../chunks/vec3f64.js";import{meterIn as z}from"../../../../renderers/support/lengthUtils.js";import m from"../../support/debugFlags.js";function y(e){return null!=e}function S(e){return"number"==typeof e}function h(e){return"string"==typeof e}function x(e){return null==e||h(e)}function b(e,o){e&&e.push(o)}function C(e,o,t,i=p()){const l=e||0,a=o||0,u=t||0;return 0!==l&&n(i,i,-l/180*Math.PI),0!==a&&r(i,i,a/180*Math.PI),0!==u&&s(i,i,u/180*Math.PI),i}function M(e,o,t,i,n){const r=e.minSize,s=e.maxSize;if(e.expression)return b(n,"Could not convert size info: expression not supported"),!1;if(e.useSymbolValue){const e=i.symbolSize[t];return o.minSize[t]=e,o.maxSize[t]=e,o.offset[t]=o.minSize[t],o.factor[t]=0,o.type[t]=1,!0}if(y(e.field))return y(e.stops)?2===e.stops.length&&S(e.stops[0].size)&&S(e.stops[1].size)?(g(e.stops[0].size,e.stops[1].size,e.stops[0].value,e.stops[1].value,o,t),o.type[t]=1,!0):(b(n,"Could not convert size info: stops only supported with 2 elements"),!1):S(r)&&S(s)&&y(e.minDataValue)&&y(e.maxDataValue)?(g(r,s,e.minDataValue,e.maxDataValue,o,t),o.type[t]=1,!0):null!=z[e.valueUnit]?(o.minSize[t]=-1/0,o.maxSize[t]=1/0,o.offset[t]=0,o.factor[t]=1/z[e.valueUnit],o.type[t]=1,!0):"unknown"===e.valueUnit?(b(n,"Could not convert size info: proportional size not supported"),!1):(b(n,"Could not convert size info: scale-dependent size not supported"),!1);if(!y(e.field)){if(e.stops&&e.stops[0]&&S(e.stops[0].size))return o.minSize[t]=e.stops[0].size,o.maxSize[t]=e.stops[0].size,o.offset[t]=o.minSize[t],o.factor[t]=0,o.type[t]=1,!0;if(S(r))return o.minSize[t]=r,o.maxSize[t]=r,o.offset[t]=r,o.factor[t]=0,o.type[t]=1,!0}return b(n,"Could not convert size info: unsupported variant of sizeInfo"),!1}function g(e,o,t,i,n,r){const s=Math.abs(i-t)>0?(o-e)/(i-t):0;n.minSize[r]=s>0?e:o,n.maxSize[r]=s>0?o:e,n.offset[r]=e-t*s,n.factor[r]=s}function V(e,o,t,i){if(e.normalizationField||e.valueRepresentation)return b(i,"Could not convert size info: unsupported property"),null;if(!x(e.field))return b(i,"Could not convert size info: field is not a string"),null;if(o.size){if(e.field)if(o.size.field){if(e.field!==o.size.field)return b(i,"Could not convert size info: multiple fields in use"),null}else o.size.field=e.field}else o.size={field:e.field,minSize:[0,0,0],maxSize:[0,0,0],offset:[0,0,0],factor:[0,0,0],type:[0,0,0]};let n;switch(e.axis){case"width":return n=M(e,o.size,0,t,i),n?o:null;case"height":return n=M(e,o.size,2,t,i),n?o:null;case"depth":return n=M(e,o.size,1,t,i),n?o:null;case"width-and-depth":return n=M(e,o.size,0,t,i),n&&M(e,o.size,1,t,i),n?o:null;case null:case void 0:case"all":return n=M(e,o.size,0,t,i),n=n&&M(e,o.size,1,t,i),n=n&&M(e,o.size,2,t,i),n?o:null;default:return b(i,`Could not convert size info: unknown axis "${e.axis}""`),null}}function T(e,o,t){for(let n=0;n<3;++n){let t=o.unitInMeters;1===e.type[n]&&(t*=o.modelSize[n],e.type[n]=2),e.minSize[n]=e.minSize[n]/t,e.maxSize[n]=e.maxSize[n]/t,e.offset[n]=e.offset[n]/t,e.factor[n]=e.factor[n]/t}let i;if(0!==e.type[0])i=0;else if(0!==e.type[1])i=1;else{if(0===e.type[2])return b(t,"No size axis contains a valid size or scale"),!1;i=2}for(let n=0;n<3;++n)0===e.type[n]&&(e.minSize[n]=e.minSize[i],e.maxSize[n]=e.maxSize[i],e.offset[n]=e.offset[i],e.factor[n]=e.factor[i],e.type[n]=e.type[i]);return!0}function O(e,o,t){e[4*o+0]=t.r/255,e[4*o+1]=t.g/255,e[4*o+2]=t.b/255,e[4*o+3]=t.a}function j(e,o,t){if(e.normalizationField)return b(t,"Could not convert color info: unsupported property"),null;if(h(e.field)){if(!e.stops)return b(t,"Could not convert color info: missing stops or colors"),null;{if(e.stops.length>8)return b(t,"Could not convert color info: too many color stops"),null;o.color={field:e.field,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};const i=e.stops;for(let e=0;e<8;++e){const t=i[Math.min(e,i.length-1)];o.color.values[e]=t.value,O(o.color.colors,e,t.color)}}}else{if(!(e.stops&&e.stops.length>=0))return b(t,"Could not convert color info: no field and no colors/stops"),null;{const t=e.stops&&e.stops.length>=0&&e.stops[0].color;o.color={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};for(let e=0;e<8;e++)o.color.values[e]=1/0,O(o.color.colors,e,t)}}return o}function E(e,o,t){if(e.normalizationField)return b(t,"Could not convert opacity info: unsupported property"),null;if(h(e.field)){if(!e.stops)return b(t,"Could not convert opacity info: missing stops or opacities"),null;{if(e.stops.length>8)return b(t,"Could not convert opacity info: too many opacity stops"),null;o.opacity={field:e.field,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0]};const i=e.stops;for(let e=0;e<8;++e){const t=i[Math.min(e,i.length-1)];o.opacity.values[e]=t.value,o.opacity.opacityValues[e]=t.opacity}}}else{if(!(e.stops&&e.stops.length>=0))return b(t,"Could not convert opacity info: no field and no opacities/stops"),null;{const t=e.stops&&e.stops.length>=0&&e.stops[0].opacity;o.opacity={field:null,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0]};for(let e=0;e<8;e++)o.opacity.values[e]=1/0,o.opacity.opacityValues[e]=t}}return o}function k(e,o,t){const i=2===t&&"arithmetic"===e.rotationType;o.offset[t]=i?90:0,o.factor[t]=i?-1:1,o.type[t]=1}function w(e,o,t){if(!h(e.field))return b(t,"Could not convert rotation info: field is not a string"),null;if(o.rotation){if(e.field)if(o.rotation.field){if(e.field!==o.rotation.field)return b(t,"Could not convert rotation info: multiple fields in use"),null}else o.rotation.field=e.field}else o.rotation={field:e.field,offset:[0,0,0],factor:[1,1,1],type:[0,0,0]};switch(e.axis){case"tilt":return k(e,o.rotation,0),o;case"roll":return k(e,o.rotation,1),o;case null:case void 0:case"heading":return k(e,o.rotation,2),o;default:return b(t,`Could not convert rotation info: unknown axis "${e.axis}""`),null}}function F(e,o,t){if(!e)return null;const i=!o.supportedTypes||!!o.supportedTypes.size,n=!o.supportedTypes||!!o.supportedTypes.color,r=!o.supportedTypes||!!o.supportedTypes.rotation,s=!!o.supportedTypes&&!!o.supportedTypes.opacity,l=e.reduce(((e,l)=>{if(!e)return e;if(l.valueExpression)return b(t,"Could not convert visual variables: arcade expressions not supported"),null;switch(l.type){case"size":return i?V(l,e,o,t):e;case"color":return n?j(l,e,t):e;case"opacity":return s?E(l,e,t):null;case"rotation":return r?w(l,e,t):e;default:return null}}),{size:null,color:null,opacity:null,rotation:null});return!(e.length>0&&l)||l.size||l.color||l.opacity||l.rotation?l&&l.size&&!T(l.size,o,t)?null:l:null}function A(e){return e&&null!=e.size}function D(e,o){if(!e)return{enabled:!1};if(m.DISABLE_FAST_UPDATES)return{enabled:!1};const t=F(e.visualVariables,o);return t?{enabled:!0,visualVariables:t,materialParameters:U(t,o),requiresShaderTransformation:A(t)}:{enabled:!1}}function I(e,o,t){if(!o||!e.enabled)return!1;const i=e.visualVariables,n=F(o.visualVariables,t);return!!n&&(!!(P(i.size,n.size,"size")&&P(i.color,n.color,"color")&&P(i.rotation,n.rotation,"rotation")&&P(i.opacity,n.opacity,"opacity"))&&(e.visualVariables=n,e.materialParameters=U(n,t),e.requiresShaderTransformation=A(n),!0))}function P(e,o,t){if(!!e!=!!o)return!1;if(e&&e.field!==o.field)return!1;if(e&&"rotation"===t){const t=e,i=o;for(let e=0;e<3;e++)if(t.type[e]!==i.type[e]||t.offset[e]!==i.offset[e]||t.factor[e]!==i.factor[e])return!1}return!0}function U(e,n){const r={vvSizeEnabled:!1,vvSizeMinSize:null,vvSizeMaxSize:null,vvSizeOffset:null,vvSizeFactor:null,vvSizeValue:null,vvColorEnabled:!1,vvColorValues:null,vvColorColors:null,vvOpacityEnabled:!1,vvOpacityValues:null,vvOpacityOpacities:null,vvSymbolAnchor:null,vvSymbolRotationMatrix:null},s=A(e);return e&&e.size?(r.vvSizeEnabled=!0,r.vvSizeMinSize=e.size.minSize,r.vvSizeMaxSize=e.size.maxSize,r.vvSizeOffset=e.size.offset,r.vvSizeFactor=e.size.factor):e&&s&&(r.vvSizeValue=n.transformation.scale),e&&s&&(r.vvSymbolAnchor=n.transformation.anchor,r.vvSymbolRotationMatrix=t(),i(q),C(n.transformation.rotation[2],n.transformation.rotation[0],n.transformation.rotation[1],q),o(r.vvSymbolRotationMatrix,q)),e&&e.color&&(r.vvColorEnabled=!0,r.vvColorValues=e.color.values,r.vvColorColors=e.color.colors),e&&e.opacity&&(r.vvOpacityEnabled=!0,r.vvOpacityValues=e.opacity.values,r.vvOpacityOpacities=e.opacity.opacityValues),r}var R;!function(o){const t=p(),i=d();function n(o,n,r){if(!o.vvSizeEnabled)return r;l(t,r);const s=o.vvSymbolRotationMatrix;a(q,s[0],s[1],s[2],0,s[3],s[4],s[5],0,s[6],s[7],s[8],0,0,0,0,1),u(t,t,q);for(let t=0;t<3;++t){const r=o.vvSizeOffset[t]+n[0]*o.vvSizeFactor[t];i[t]=e(r,o.vvSizeMinSize[t],o.vvSizeMaxSize[t])}return f(t,t,i),c(t,t,o.vvSymbolAnchor),t}function r(o,t,i){if(!t.vvSizeEnabled)return v(o,1,1,1);for(let n=0;n<3;++n){const r=t.vvSizeOffset[n]+i[0]*t.vvSizeFactor[n];o[n]=e(r,t.vvSizeMinSize[n],t.vvSizeMaxSize[n])}return o}o.evaluateModelTransform=n,o.evaluateModelTransformScale=r}(R||(R={}));const q=p(),$=R.evaluateModelTransform,_=R.evaluateModelTransformScale;export{F as convertVisualVariables,$ as evaluateModelTransform,_ as evaluateModelTransformScale,U as getMaterialParams,D as initFastSymbolUpdatesState,I as updateFastSymbolUpdatesState};
