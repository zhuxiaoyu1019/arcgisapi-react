/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import"../../../../../geometry.js";import t from"../../../../../core/Accessor.js";import s from"../../../../../core/Handles.js";import{handlesGroup as n,makeHandle as r}from"../../../../../core/handleUtils.js";import{isNone as i,isSome as o,abortMaybe as a,removeMaybe as l,none as c}from"../../../../../core/maybe.js";import{createTask as p,ignoreAbortErrors as h}from"../../../../../core/promiseUtils.js";import{property as u}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/Logger.js";import{subclass as g}from"../../../../../core/accessorSupport/decorators/subclass.js";import{reactionInit as d}from"../../../../../core/accessorSupport/trackingUtils.js";import{g as y,f as _,n as m,a as v,b as f,j as A,w as b}from"../../../../../chunks/vec3.js";import{c as T}from"../../../../../chunks/vec3f64.js";import{fromPoints as C,create as O}from"../../../../../geometry/support/ray.js";import{LineOfSightAnalysis as j}from"./LineOfSightAnalysis.js";import{LineOfSightResult as E}from"./LineOfSightResult.js";import{Intersector as I}from"../../../webgl-engine/lib/Intersector.js";import{toGraphic as L}from"../../../webgl-engine/lib/intersectorUtilsConversions.js";import{ImmediateTask as w,TaskPriority as S}from"../../../../support/Scheduler.js";import P from"../../../../../geometry/Point.js";let V=class extends t{constructor(e){super(e),this._tasks=w,this._handles=new s,this._analysisHandles=new s}initialize(){var e;const t=null==(e=this.view.resourceController)?void 0:e.scheduler;t&&(this._tasks=t.registerTask(S.LINE_OF_SIGHT_TOOL));this._handles.add([d((()=>this.layer.observer),(e=>this._onObserverChange(e))),this._connectAnalyses(),this._connectTargets()]),this._intersector=new I(this.view.state.viewingMode),this._intersector.options.hud=!1,this._intersector.options.store=0}destroy(){this._handles.destroy(),this._analysisHandles.destroy(),this._analyses.removeAll()}get updating(){return this._tasks.updating}get priority(){return this._tasks.priority}set priority(e){this._tasks.priority=e}get _analyses(){return this.layerViewData.analyses}get _observerEngineLocation(){return this.layerViewData.observerEngineLocation}set _observerEngineLocation(e){this.layerViewData.observerEngineLocation=e}get _screenPixelSize(){return this.view.state.camera.computeScreenPixelSizeAt(this._observerEngineLocation)}getLineOfSightComputationDependencies(e){const{inputPoints:t}=e;return{inputPoints:t}}computeAnalysis(e,t=!1){const{analysis:s}=e,{inputPoints:n,computationResult:r}=s,{observerAdjusted:i,targetAdjusted:o}=n,{start:a,end:l}=r;y(a,i),y(l,o);t||this._canComputeAnalysis(s)?this._computeAnalysisIntersection(e):this._interpolateAnalysisIntersection(e),s.updateComputationResults()}_adjustStartEndPositions(e){const t=this._screenPixelSize,s=this.view,{inputPoints:n}=e,{observer:r,target:i,observerAdjusted:o,targetAdjusted:a}=n,l=R;_(l,i,r);const c=t;m(l,l),v(l,l,Math.min(c,1)),f(o,r,l),_(l,r,i);const p=s.state.camera.computeScreenPixelSizeAt(i);m(l,l),v(l,l,Math.min(p,1)),f(a,i,l)}_computeAnalysisIntersection({analysis:e,interpolationInfo:t}){const{view:s}=this,{sceneIntersectionHelper:n,renderCoordsHelper:r}=s;if(i(n))return;const o=this._intersector,{computationResult:a,inputPoints:l}=e,{observer:c,target:p}=l,{start:h,end:u}=a,g=C(h,u,H);n.intersectToolIntersectorRay(g,o);const d=a.intersection,_=R,m=!!o.results.min&&o.results.min.getIntersectionPoint(d);let v=!0;if(m){y(t.originalIntersection,d),y(t.originalObserver,h),y(t.originalTarget,u),r.fromRenderCoords(d,_,s.spatialReference);const e=1-A(u,p)/A(h,p);v=A(c,d)>=e*A(c,p)}const f=new P(_,s.spatialReference);e.result=new E({target:e.target,intersectedGraphic:v?null:L(o.results.min,s),intersectedLocation:v?null:f,visible:!!m&&v}),a.isValid=l.isValid=!0,a.isTargetVisible=v}_interpolateAnalysisIntersection({analysis:e,interpolationInfo:t}){const{computationResult:s,inputPoints:n}=e,{start:r,end:i,intersection:o}=s,{originalIntersection:a,originalObserver:l,originalTarget:c}=t;if(y(o,a),n.isValid){const e=R,t=A(l,a)/A(l,c);b(e,r,l),v(e,e,1-t),f(o,o,e),b(e,i,c),v(e,e,t),f(o,o,e),s.isValid=!0}else e.result=null,s.isValid=!1,s.isTargetVisible=!1}_canComputeAnalysis(e){const t=this.layer.observer,s=this.view.frustum;if(i(t)||i(e.target)||i(s))return!1;const{observerAdjusted:n,targetAdjusted:r}=e.inputPoints,o=s.intersectsPoint(n),a=s.intersectsPoint(r);return o&&a}_onObserverChange(e){if(i(e))return void this.layer.targets.removeAll();const t=T();this.view.renderCoordsHelper.toRenderCoords(e,t),this._observerEngineLocation=t,this.priority=S.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onObserverChangeForAnalysis(e){e.inputPoints.isValid=!1}_onObserverEngineForAnalysis(e,t){const{inputPoints:s}=e;y(s.observer,t),this._adjustStartEndPositions(e),e.updateInputPoints(),this.priority=S.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onTargetLocationChange(e,t){const{inputPoints:s}=e;s.isValid=!1,this.view.renderCoordsHelper.toRenderCoords(t,s.target),this._adjustStartEndPositions(e),e.updateInputPoints(),this.priority=S.LINE_OF_SIGHT_TOOL_INTERACTIVE}_connectAnalysisToTarget(e){return d((()=>({analysis:e,target:e.target})),(({analysis:e,target:t})=>{o(t)&&this._onTargetLocationChange(e,t)}))}_connectAnalysisToObserver(e){return d((()=>({analysis:e,observer:this.layer.observer})),(({analysis:e})=>{this._onObserverChangeForAnalysis(e)}))}_connectAnalysisToObserverEngine(e){return d((()=>({analysis:e,observer:this._observerEngineLocation})),(({analysis:e,observer:t})=>{this._onObserverEngineForAnalysis(e,t)}))}_connectAnalysisForCompute(e){let t=c;const s={analysis:e,interpolationInfo:{originalIntersection:T(),originalObserver:T(),originalTarget:T()}};return n([d((()=>this.getLineOfSightComputationDependencies(e)),(()=>{t=a(t),t=p((async e=>{await h(this._tasks.schedule((()=>this.computeAnalysis(s)),e))}))})),r((()=>t=a(t)))])}_connectAnalysis(e){const t=this._analysisHandles;t.has(e)||t.add([this._connectAnalysisToTarget(e),this._connectAnalysisToObserver(e),this._connectAnalysisToObserverEngine(e),this._connectAnalysisForCompute(e)])}_disconnectAnalysis(e){this._analysisHandles.remove(e)}_onAnalysesCollectionChange(e){e.added.forEach((e=>this._connectAnalysis(e))),e.removed.forEach((e=>this._disconnectAnalysis(e)))}_onTargetsChange(e){return this._analyses.removeAll(),e.items.length>0&&e.forEach((e=>this._addTarget(e))),e.on("change",(e=>this._onTargetCollectionChange(e)))}_onTargetCollectionChange(e){e.added.forEach((e=>this._addTarget(e))),e.removed.forEach((e=>this._removeTarget(e)))}_addTarget(e){const t=this._analyses;t.some((t=>t.target===e))||t.add(new j({target:e}))}_removeTarget(e){const t=this._analyses,s=t.find((t=>t.target===e));t.remove(s)}_connectAnalyses(){let e=null;return n([d((()=>this._analyses),(t=>{e=l(e),e=t.on("change",(e=>this._onAnalysesCollectionChange(e))),t.forEach((e=>this._connectAnalysis(e)))})),r((()=>e=l(e)))])}_connectTargets(){let e=null;return n([d((()=>this.layer.targets),(t=>{e=l(e),e=this._onTargetsChange(t)})),r((()=>e=l(e)))])}};e([u({constructOnly:!0})],V.prototype,"layer",void 0),e([u({constructOnly:!0})],V.prototype,"layerViewData",void 0),e([u({constructOnly:!0})],V.prototype,"view",void 0),e([u()],V.prototype,"updating",null),e([u()],V.prototype,"priority",null),e([u()],V.prototype,"_analyses",null),e([u()],V.prototype,"_observerEngineLocation",null),e([u()],V.prototype,"_screenPixelSize",null),e([u()],V.prototype,"_tasks",void 0),V=e([g("esri.views.3d.layers.analysis.LineOfSight.LineOfSightController")],V);const R=T(),H=O();export{V as LineOfSightController};
