/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{isNone as t}from"../../../../core/maybe.js";import{d as e}from"../../../../chunks/mat4.js";import{c as a}from"../../../../chunks/mat4f64.js";import{s as o}from"../../../../chunks/vec3.js";import{c as s}from"../../../../chunks/vec3f64.js";import{projectBuffer as n,computeLinearTransformation as r}from"../../../../geometry/projection.js";import{evaluateElevationAlignmentAtPoint as i}from"./elevationAlignmentUtils.js";import{updateVertexAttributeAuxpos1w as l}from"./graphicUtils.js";import c from"../../support/debugFlags.js";import{SamplePosition as m}from"../../support/ElevationProvider.js";function f(t,e,a,o){const s=t.stageObject,r=a.spatialReference,l=s.geometryRecords,f=l.length,E="absolute-height"!==e.mode;let u=0;for(let p=0;p<f;p++){const t=l[p].geometry,f=l[p].getShaderTransformation();A[0]=f[12],A[1]=f[13],A[2]=f[14],t.invalidateBoundingInfo();const I=t.getMutableAttribute("position"),b=I.data,g=t.vertexAttributes.get("mapPos").data,R=I.size,_=b.length/R,D=new m(g,r);let v=0,L=!1,j=0;for(let s=0;s<_;s++){h[0]=b[v],h[1]=b[v+1],h[2]=b[v+2];const t=i(D,a,e,o,E?S:null);if(E&&(j+=S.sampledElevation),c.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(b[v]=D.array[D.offset],b[v+1]=D.array[D.offset+1],b[v+2]=t,n(b,r,v,b,o.spatialReference,v,1),b[v]-=A[0],b[v+1]-=A[1],b[v+2]-=A[2]):(T[0]=b[v]+A[0],T[1]=b[v+1]+A[1],T[2]=b[v+2]+A[2],o.setAltitude(T,t),b[v]=T[0]-A[0],b[v+1]=T[1]-A[1],b[v+2]=T[2]-A[2]),c.TESTS_DISABLE_UPDATE_THRESHOLDS)L=!0;else{const t=d/o.unitInMeters;(Math.abs(h[0]-b[v])>=t||Math.abs(h[1]-b[v+1])>=t||Math.abs(h[2]-b[v+2])>=t)&&(L=!0)}v+=R,D.offset+=3}u+=j/_,L&&s.geometryVertexAttrsUpdated(p)}return u/f}function E(t,a,s,n){const m=t.stageObject,f=a.centerPointInElevationSR;let E=0,p=0;if(m.metadata.usesVerticalDistanceToGround)E=i(f,s,a,n,S),l(m,S.verticalDistanceToGround),p=S.sampledElevation;else{const t="absolute-height"!==a.mode;E=i(f,s,a,n,t?S:null),t&&(p=S.sampledElevation)}const A=e(u,m.transformation),h=o(b,A[12],A[13],A[14]);c.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(T[0]=f.x,T[1]=f.y,T[2]=E,r(f.spatialReference,T,A,n.spatialReference)&&(m.transformation=A)):n.setAltitudeOfTransformation(E,A);const I=d/n.unitInMeters;return(Math.abs(A[12]-h[0])>=I||Math.abs(A[13]-h[1])>=I||Math.abs(A[14]-h[2])>=I)&&(m.transformation=A),p}const u=a();function p(e,a,s,n){const l=e.graphics3DSymbolLayer.lodRenderer;if(t(l))return 0;const m=a.centerPointInElevationSR;let f=0,E=0;const u="absolute-height"!==a.mode;f=i(m,s,a,n,u?S:null),u&&(E=S.sampledElevation);const p=l.instanceData,A=e.instanceIndex,h=I;p.getGlobalTransform(A,h);const g=o(b,h[12],h[13],h[14]);c.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(T[0]=m.x,T[1]=m.y,T[2]=f,r(m.spatialReference,T,h,n.spatialReference)&&p.setGlobalTransform(A,h)):n.setAltitudeOfTransformation(f,h);const R=d/n.unitInMeters;return(c.TESTS_DISABLE_UPDATE_THRESHOLDS||Math.abs(h[12]-g[0])>=R||Math.abs(h[13]-g[1])>=R||Math.abs(h[14]-g[2])>=R)&&p.setGlobalTransform(A,h),E}const d=.01,T=s(),A=s(),h=s(),I=a(),b=s(),S={verticalDistanceToGround:0,sampledElevation:0};export{p as perLodInstanceElevationAligner,E as perObjectElevationAligner,f as perVertexElevationAligner};
