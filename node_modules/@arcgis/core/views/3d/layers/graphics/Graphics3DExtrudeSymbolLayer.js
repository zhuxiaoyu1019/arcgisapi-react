/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{get as t,isSome as s,isNone as r}from"../../../../core/maybe.js";import{e as n}from"../../../../chunks/earcut.js";import{a}from"../../../../chunks/mat3.js";import{c as o}from"../../../../chunks/mat3f64.js";import{a as i}from"../../../../chunks/mat4.js";import{I as l,c}from"../../../../chunks/mat4f64.js";import{g as h,n as m,s as p,f as d,c as u,m as f}from"../../../../chunks/vec3.js";import{d as g,c as y}from"../../../../chunks/vec3f64.js";import{computeLinearTransformation as _}from"../../../../geometry/projection.js";import{create as E,empty as b,expandWithBuffer as x,intersectsClippingArea as v}from"../../../../geometry/support/aaBoundingBox.js";import{BufferViewVec3f64 as P}from"../../../../geometry/support/buffer/BufferView.js";import{t as w,a as A}from"../../../../chunks/vec32.js";import{getDriverAxisSizeValue as j}from"../../../../renderers/support/renderingInfoUtils.js";import{needsElevationUpdates3D as L,evaluateElevationAlignmentAtPoint as S}from"./elevationAlignmentUtils.js";import{ElevationContext as B}from"./ElevationContext.js";import{Graphics3DObject3DGraphicLayer as C}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as M}from"./Graphics3DSymbolLayer.js";import{validateSymbolLayerSize as R,computeCentroid as z}from"./graphicUtils.js";import{geometryAsPolygon as G,geometryToRenderInfo as D}from"./polygonUtils.js";import{createMaterial as I}from"../support/edgeUtils.js";import T from"../../support/debugFlags.js";import{SamplePosition as U}from"../../support/ElevationProvider.js";import{Geometry as V}from"../../webgl-engine/lib/Geometry.js";import{Object3D as O}from"../../webgl-engine/lib/Object3D.js";import{DefaultMaterial as k}from"../../webgl-engine/materials/DefaultMaterial.js";const F=["polygon","extent"];class N extends M{constructor(e,t,s,r){super(e,t,s,r),this.ensureDrapedStatus(!1)}async doLoad(){if(!this._drivenProperties.size){const t=R(this._getSymbolSize());if(t)throw new e("graphics3dextrudesymbollayer:invalid-size",t)}const s=t(this.symbolLayer,"material","color"),r=this._getCombinedOpacityAndColor(s),n=g(r),a=r[3],o=a<1||this.needsDrivenTransparentPass,i={usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0,diffuse:n,ambient:n,opacity:a,transparent:o,cullFace:o?0:2,vertexColors:!0,slicePlaneEnabled:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,offsetTransparentBackfaces:!0};this._material=new k(i),this._bottomMaterial=new k({...i,cullFace:2}),this._context.stage.add(this._material),this._context.stage.add(this._bottomMaterial)}destroy(){super.destroy(),this._material&&(this._context.stage.remove(this._material),this._context.stage.remove(this._bottomMaterial))}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,F,this.symbolLayer.type))return null;const s=this._getVertexOpacityAndColor(e.renderingInfo,255),r=this.setGraphicElevationContext(t,new B);return this._createAs3DShape(t,e.renderingInfo,s,r,t.uid)}layerOpacityChanged(e,r){const n=t(this.symbolLayer,"material","color"),a=this._getCombinedOpacity(n),o=a<1||this.needsDrivenTransparentPass;this._material.setParameterValues({opacity:a,transparent:o}),this._bottomMaterial.setParameterValues({opacity:a,transparent:o});const i=this._getLayerOpacity();return e.forEach((e=>{const t=r(e);s(t)&&t.layerOpacityChanged(i,this._context.isAsync)})),!0}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,L)}slicePlaneEnabledChanged(e,t){return this._material.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled}),this._bottomMaterial.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled}),e.forEach((e=>{const r=t(e);s(r)&&r.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)})),!0}physicalBasedRenderingChanged(){return this._material.setParameterValues({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._bottomMaterial.setParameterValues({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0}pixelRatioChanged(){return!0}_getExtrusionSize(e){let t;var s;e.size&&this._drivenProperties.size?t=null!=(s=j(e.size,2))?s:0:t=this._getSymbolSize();return t/=this._context.renderCoordsHelper.unitInMeters,t}_getSymbolSize(){var e;return null!=(e=this.symbolLayer.size)?e:1}_createAs3DShape(e,t,h,m,p){const d=G(e.geometry);if(r(d))return null;const u=D(d,this._context.elevationProvider,this._context.renderCoordsHelper,m);if(this._logGeometryCreationWarnings(u,d.rings,"rings","ExtrudeSymbol3DLayer"),0===d.rings.length||!d.rings.some((e=>e.length>0)))return null;const f=z(d);if(r(f))return null;const g=new Array,j=new Array,S=new Array,B=E(),M=c(),R=y(),T=1===this._context.renderCoordsHelper.viewingMode;T||this._context.renderCoordsHelper.worldUpAtPosition(null,R),_(d.spatialReference,[f.x,f.y,0],M,this._context.renderCoordsHelper.spatialReference);const U=c();i(U,M);const V=o();a(V,U);const{polygons:k,mapPosition:F,position:N}=u,Y=N.length/3,W=new Float64Array(3*Y*6),q=new Float64Array(3*Y*6),J=new Float64Array(3*Y*6),K=new Float64Array(1*Y*6);let Q=0;for(let s=0;s<k.length;++s){const e=k[s],r=e.count;if(this._context.clippingExtent&&(b(B),x(B,e.mapPosition),!v(B,this._context.clippingExtent)))continue;const a=n(e.mapPosition,e.holeIndices,3);if(0===a.length)continue;const o=3*r*2+a.length,i=new Uint32Array(o),c=new Uint32Array(a.length),m=6*r,p=3*W.BYTES_PER_ELEMENT,d=new P(W.buffer,Q*p,p,(Q+m)*p),u=3*q.BYTES_PER_ELEMENT,f=new P(q.buffer,Q*u,u,(Q+m)*u),y=new Float64Array(J.buffer,3*Q*J.BYTES_PER_ELEMENT,3*m),_=new Float64Array(K.buffer,1*Q*K.BYTES_PER_ELEMENT,1*m),E=this._getExtrusionSize(t);H(N,F,a,e,d.typedBuffer,y,f.typedBuffer,_,0,i,c,E,R,T),w(d,d,U),A(f,f,V),Q+=6*r;const L=this._createExtrudeGeometry(i,i.length-c.length,{positions:d.typedBuffer,elevation:y,normals:f.typedBuffer,heights:_},h);g.push(L),j.push(this._material),S.push(l);const C=this._createExtrudeGeometry(c,0,{positions:d.typedBuffer,elevation:y,normals:f.typedBuffer,heights:_},h);g.push(C),j.push(this._bottomMaterial),S.push(l)}if(0===g.length)return null;const X=new O({geometries:g,materials:j,transformations:S,metadata:{layerUid:this._context.layer.uid,graphicUid:p,isElevationSource:!0}});X.transformation=M;const Z=se,$=I(this.symbolLayer,{opacity:this._getLayerOpacity()}),ee=s($)?{baseMaterial:this._material,edgeMaterials:[$],properties:{mergeGeometries:!0,slicePlaneEnabled:this._context.slicePlaneEnabled}}:null,te=new C(this,X,g,null,null,Z,m,ee);return te.alignedSampledElevation=u.sampledElevation,te.needsElevationUpdates=L(m.mode),te}_createExtrudeGeometry(e,t,s,r){const n=new Uint32Array(e.length),a=[["position",{size:3,data:s.positions,exclusive:!0}],["normal",{size:3,data:s.normals,exclusive:!0}],["color",{size:4,data:r,exclusive:!0}],["size",{size:1,data:s.heights,exclusive:!0}]],o=[["position",e],["normal",e],["color",n]];return s.elevation&&(a.push(["mapPos",{size:3,data:s.elevation}]),o.push(["mapPos",e])),new V(a,o,0,t)}}function H(e,t,s,r,n,a,o,i,l,c,h,m,p,d){const u=s.length/3;let f=0,g=2*r.count;Y(e,t,r.index,r.count,s,0,u,n,a,o,i,l,c,h,g,m,p,d),l+=2*r.count,g=0,J(n,a,i,o,f,r.pathLengths[0],r.count,l,c,g,m),l+=4*r.pathLengths[0],g+=2*r.pathLengths[0],f+=r.pathLengths[0];for(let y=1;y<r.pathLengths.length;++y)J(n,a,i,o,f,r.pathLengths[y],r.count,l,c,g,m),l+=4*r.pathLengths[y],g+=2*r.pathLengths[y],f+=r.pathLengths[y]}function Y(e,t,s,r,n,a,o,i,l,c,p,d,u,f,g,y,_,E){h(ne,_);const b=y>0?1:-1;let x=3*s,v=d,P=3*v,w=d+r,A=3*w;for(let h=0;h<r;++h)E&&(ne[0]=e[x+0],ne[1]=e[x+1],ne[2]=e[x+2],m(ne,ne)),i[P+0]=e[x+0],i[P+1]=e[x+1],i[P+2]=e[x+2],l[P+0]=t[x+0],l[P+1]=t[x+1],l[P+2]=t[x+2],c[P+0]=-b*ne[0],c[P+1]=-b*ne[1],c[P+2]=-b*ne[2],p[v]=0,i[A+0]=e[x+0]+y*ne[0],i[A+1]=e[x+1]+y*ne[1],i[A+2]=e[x+2]+y*ne[2],l[A+0]=t[x+0],l[A+1]=t[x+1],l[A+2]=t[x+2],c[A+0]=b*ne[0],c[A+1]=b*ne[1],c[A+2]=b*ne[2],p[w]=y,P+=3,A+=3,x+=3,v+=1,w+=1;x=3*a,P=0,A=3*g;const j=y<0?oe:ae,L=y<0?ae:oe;for(let h=0;h<o;++h)f[P+0]=n[x+j[0]],f[P+1]=n[x+j[1]],f[P+2]=n[x+j[2]],u[A+0]=n[x+L[0]]+r,u[A+1]=n[x+L[1]]+r,u[A+2]=n[x+L[2]]+r,P+=3,A+=3,x+=3}function W(e,t,s,r,n,a,o){r[a]=r[o],o*=3,e[(a*=3)+0]=e[o+0],e[a+1]=e[o+1],e[a+2]=e[o+2],t[a+0]=t[o+0],t[a+1]=t[o+1],t[a+2]=t[o+2],s[a+0]=n[0],s[a+1]=n[1],s[a+2]=n[2]}const q=y();function J(e,t,s,r,n,a,o,i,l,c,h){let m=n,p=n+1,d=n+o,u=n+o+1,f=i,g=i+1,y=i+2*a,_=i+2*a+1;h<0&&(m=n+o+1,u=n),c*=3;for(let E=0;E<a;++E)E===a-1&&(h>0?(p=n,u=n+o):(p=n,m=n+o)),ee(e,m,p,d,q),W(e,t,r,s,q,f,m),W(e,t,r,s,q,g,p),W(e,t,r,s,q,y,d),W(e,t,r,s,q,_,u),l[c++]=f,l[c++]=y,l[c++]=_,l[c++]=f,l[c++]=_,l[c++]=g,m++,p++,d++,u++,f+=2,g+=2,y+=2,_+=2}const K=y(),Q=y(),X=y(),Z=y(),$=y();function ee(e,t,s,r,n){t*=3,s*=3,r*=3,p(K,e[t++],e[t++],e[t++]),p(Q,e[s++],e[s++],e[s++]),p(X,e[r++],e[r++],e[r++]),d(Z,Q,K),d($,X,K),u(n,$,Z),m(n,n)}const te=y();function se(e,t,s,r){const n=e.stageObject,a=n.geometryRecords,o=a.length,l="absolute-height"!==t.mode;let h=0;const m=n.transformation,d=i(c(),m);for(let i=0;i<o;i+=2){const e=a[i].geometry,o=e.getMutableAttribute("position").data,c=e.vertexAttributes.get("size").data,u=e.vertexAttributes.get("mapPos").data,g=new U(u),y=o.length/3;let _=0,E=!1,b=0;const x=s.spatialReference;for(let n=0;n<y;n++){te[0]=o[_],te[1]=o[_+1],te[2]=o[_+2];const e=S(g,s,t,r,l?le:null);l&&(b+=le.sampledElevation),T.DISABLE_ELEVATION_ALIGNERS_ITERATIVE_UPDATES?(p(re,g.array[g.offset+0],g.array[g.offset+1],e+c[_/3]),r.toRenderCoords(re,x,re),f(re,re,d)):(p(re,o[_+0],o[_+1],o[_+2]),f(re,re,m),r.setAltitude(re,e+c[_/3]),f(re,re,d)),o[_]=re[0],o[_+1]=re[1],o[_+2]=re[2];const n=ie/r.unitInMeters;(Math.abs(te[0]-o[_])>=n||Math.abs(te[1]-o[_+1])>=n||Math.abs(te[2]-o[_+2])>=n)&&(E=!0),g.offset+=3,_+=3}E&&(e.invalidateBoundingInfo(),n.geometryVertexAttrsUpdated(i),a[i+1].geometry.invalidateBoundingInfo(),n.geometryVertexAttrsUpdated(i+1)),h+=b/y}return h/o}const re=y(),ne=y(),ae=[0,2,1],oe=[0,1,2],ie=.01,le={verticalDistanceToGround:0,sampledElevation:0};export default N;export{N as Graphics3DExtrudeSymbolLayer};
