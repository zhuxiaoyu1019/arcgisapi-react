/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{sign as t,acosClamped as i,reciprocalClamped as r}from"../../../../core/mathUtils.js";import{isSome as s,get as a}from"../../../../core/maybe.js";import{s as o}from"../../../../chunks/mat2.js";import{s as n,b as l}from"../../../../chunks/vec2.js";import{f as h}from"../../../../chunks/vec2f64.js";import{s as c,b as p,d as m,c as d,a as f,n as u,o as y,f as g}from"../../../../chunks/vec3.js";import{c as _}from"../../../../chunks/vec3f32.js";import{d as b,c as v}from"../../../../chunks/vec3f64.js";import{projectBuffer as x}from"../../../../geometry/projection.js";import{create as w,empty as S,expandWithBuffer as D,intersectsClippingArea as P}from"../../../../geometry/support/aaBoundingBox.js";import"../../../../layers/graphics/dehydratedFeatures.js";import{needsElevationUpdates3D as R,evaluateElevationAlignmentAtPoint as V}from"./elevationAlignmentUtils.js";import{ElevationContext as j}from"./ElevationContext.js";import{Graphics3DObject3DGraphicLayer as C}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as A,getAttributeValue as L}from"./Graphics3DSymbolLayer.js";import{isValidSize as z}from"./graphicUtils.js";import{initFastSymbolUpdatesState as E,updateFastSymbolUpdatesState as U}from"../support/FastSymbolUpdates.js";import{Object3D as k}from"../../webgl-engine/lib/Object3D.js";import{PathGeometry as F,isPathGeometry as G}from"../../webgl-engine/lib/PathGeometry.js";import{Profile as I,SimpleExtruder as M,MiterExtruder as O,RoundCapBuilder as B,TriangulationCapBuilder as q,NoCapBuilder as H,Path as T,Builder as N,FastUpdatePathGeometry as W,StaticPathGeometry as Z,computeMinimumRotationTangentFrame as J,vertexSpaceToProfileSpace as K,PathVertex as Q}from"../../webgl-engine/lib/pathGeometryUtils.js";import{DefaultMaterial as X}from"../../webgl-engine/materials/DefaultMaterial.js";import{PathMaterial as Y}from"../../webgl-engine/materials/PathMaterial.js";const $=["polyline"];class ee extends A{constructor(e,t,i,r){super(e,t,i,r),this._intrinsicSize=h(1,1),this.upVectorAlignment="path",this.stencilWidth=.1,this.ensureDrapedStatus(!1)}async doLoad(){const t=s(this.symbolLayer.width)?this.symbolLayer.width:s(this.symbolLayer.height)?this.symbolLayer.height:this.symbolLayer.size,i=s(this.symbolLayer.height)?this.symbolLayer.height:t;this._vvConvertOptions={modelSize:[1,1,1],symbolSize:[t,1,i],unitInMeters:this._context.renderCoordsHelper.unitInMeters,transformation:{anchor:[0,0,0],scale:[1,1,1],rotation:[0,0,0]},supportedTypes:{size:!0,color:!0,opacity:!0,rotation:!1}},this._context.renderer&&this._context.renderer.visualVariables&&this._context.renderer.visualVariables.length>0?this._fastUpdates=E(this._context.renderer,this._vvConvertOptions):this._fastUpdates={enabled:!1};const r=this.symbolLayer.anchor||"center";this.upVectorAlignment="path","heading"===this.symbolLayer.profileRotation&&(this.upVectorAlignment="world");const o=this.symbolLayer.profile||"circle";switch(o){case"circle":default:this._profile=I.circle(ce);break;case"quad":this._profile=I.rect()}let h=[0,0];"center"!==r&&(h={left:[.5,0],right:[-.5,0],top:[0,-.5],bottom:[0,.5]}[r],this._profile.translate(h[0],h[1]));switch(this.symbolLayer.join||"simple"){case"round":this._extruder=new O(0,le);break;case"bevel":this._extruder=new O(0,1);break;case"miter":this._extruder=new O(.8*Math.PI,1);break;case"simple":default:this._extruder=new M}const c=this.symbolLayer.cap||"butt";switch(c){case"none":this._startCap=new H,this._endCap=new H;break;case"butt":default:this._startCap=new q(this._profile,0),this._endCap=new q(this._profile,0,!0);break;case"square":this._startCap=new q(this._profile,-.5),this._endCap=new q(this._profile,.5,!0);break;case"round":{const e="quad"===o;this._startCap=new B({profile:this._profile,flip:!1,breakNormals:e,subdivisions:he}),this._endCap=new B({profile:this._profile,flip:!0,breakNormals:e,subdivisions:he});break}}const p=a(this.symbolLayer,"material","color"),m=this._getCombinedOpacityAndColor(p),d=b(m),f=m[3],u=f<1||this.needsDrivenTransparentPass,y={diffuse:d,ambient:d,opacity:f,transparent:u,vertexColors:!1,slicePlaneEnabled:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,cullFace:u||"none"===c?0:2,offsetTransparentBackfaces:!0};if(!this._drivenProperties.size&&(n(this._intrinsicSize,t,i),!z(this._intrinsicSize[0])||!z(this._intrinsicSize[1])))throw new e("graphics3dpathsymbollayer:invalid-size","Symbol sizes may not be negative values");this._fastUpdates.enabled&&this._fastUpdates.visualVariables.size||l(this._intrinsicSize,this._intrinsicSize,1/this._context.renderCoordsHelper.unitInMeters),this._fastUpdates.enabled?(Object.assign(y,this._fastUpdates.materialParameters,{size:[this._intrinsicSize[0],this._intrinsicSize[1],0]}),this._material=new Y(y)):(y.vertexColors=this._drivenProperties.color||this._drivenProperties.opacity,this._material=new X(y)),this._material.setParameterValues({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._context.stage.add(this._material)}destroy(){super.destroy(),this._context.stage.remove(this._material),this._material=null}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,$,this.symbolLayer.type))return null;const i=this.setGraphicElevationContext(t,new j),r=e.renderingInfo;return this._createAs3DShape(t,r,i,t.uid)}layerOpacityChanged(){const e=a(this.symbolLayer,"material","color"),t=this._getCombinedOpacity(e),i=t<1||this.needsDrivenTransparentPass;return this._material.setParameterValues({opacity:t,transparent:i}),!0}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,R)}slicePlaneEnabledChanged(){return this._material.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled}),!0}physicalBasedRenderingChanged(){return this._material.setParameterValues({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0}pixelRatioChanged(){return!0}applyRendererDiff(e,t){for(const i in e.diff)switch(i){case"visualVariables":if(!U(this._fastUpdates,t,this._vvConvertOptions))return!1;this._material.setParameterValues(this._fastUpdates.materialParameters);break;default:return!1}return!0}getVertexData(e){let t=0;const i=e.paths,r=[],s=e.spatialReference,a=this._context.elevationProvider.spatialReference,o=this._context.renderCoordsHelper.spatialReference;for(const m of i)t+=m.length;const n=new Float64Array(3*t),l=new Float64Array(3*t),h=new Float64Array(3*t);let c=0;for(const m of i){r.push({index:c,numVertices:m.length});for(const t of m)n[c++]=t[0],n[c++]=t[1],n[c++]=e.hasZ?t[2]:0}let p=!0;return s.equals(a)?this._copyVertices(n,0,l,0,t):p=x(n,s,0,l,a,0,t),a.equals(o)?this._copyVertices(l,0,h,0,t):x(l,a,0,h,o,0,t),{pathVertexDataInfos:r,vertexDataGS:n,vertexDataES:l,vertexDataRS:h,projectionSuccess:p,terrainElevation:0}}_copyVertices(e,t,i,r,s){t*=3,r*=3;for(let a=0;a<s;++a)i[r++]=e[t++],i[r++]=e[t++],i[r++]=e[t++]}_createAs3DShape(e,t,i,r){const a=e.geometry,o=new Array,n=new Array,l=new Array,h=a.spatialReference,p=w(),m=this._context.renderCoordsHelper,d=this.getVertexData(a);if(!d.projectionSuccess)return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"),null;if(d.pathVertexDataInfos.length>0){for(let r=0;r<d.pathVertexDataInfos.length;++r){const a=d.pathVertexDataInfos[r],f=a.index,u=a.numVertices;if(u<2)continue;if(s(this._context.clippingExtent)&&(S(p),D(p,d.vertexDataES,3*f,u),!P(p,this._context.clippingExtent)))continue;const y=[];for(let e=f;e<f+3*u;){const t=e++,r=e++,s=e++,a=new Q;c(a.posGS,d.vertexDataGS[t],d.vertexDataGS[r],d.vertexDataGS[s]),c(a.posES,d.vertexDataES[t],d.vertexDataES[r],d.vertexDataES[s]);const o=V(a.posES,this._context.elevationProvider,i,m,null);c(ae,d.vertexDataRS[t],d.vertexDataRS[r],d.vertexDataRS[s]),m.setAltitude(ae,o),c(a.pos,ae[0],ae[1],ae[2]),y.push(a)}const g=new T(y);te(g,this.upVectorAlignment,this._context.renderCoordsHelper);const _=new N(g,this._profile,this._extruder,this._startCap,this._endCap);let b=null;if(this._fastUpdates.enabled){const t=this._fastUpdates.visualVariables,i=t.size?L(t.size.field,e):0,r=t.color?L(t.color.field,e):0,s=t.opacity?L(t.opacity.field,e):0;b=new W(_,i,r,s)}else{const e=[this._intrinsicSize[0],this._intrinsicSize[1]];this._drivenProperties.size&&(e[0]*=ie(t.size[0],"symbol-value"===t.size[2]?this.symbolLayer.height||0:t.size[2],this.symbolLayer.width||0),e[1]*=ie(t.size[2],"symbol-value"===t.size[0]?this.symbolLayer.width||0:t.size[0],this.symbolLayer.height||0));let i=null;this._drivenProperties.color&&(i=t.color),this._drivenProperties.opacity&&null!=t.opacity&&(i=i?[i[0],i[1],i[2],t.opacity]:[1,1,1,t.opacity]);const r=new Z(_);r.bake(e),i&&r.bakeVertexColors(i),b=r}const{vertexAttributes:v,indices:x}=b.createGeometryData(),w=new F(v,x,b,h,this.upVectorAlignment,this.stencilWidth);o.push(w),n.push(this._material),l.push(b.xform)}if(o.length>0){const e={layerUid:this._context.layer.uid,graphicUid:r},t=new k({geometries:o,materials:n,transformations:l,metadata:e}),s=new C(this,t,o,null,null,se,i);return s.alignedSampledElevation=d.terrainElevation,s.needsElevationUpdates=R(i.mode),s}}else 0!==a.paths.length&&a.paths.some((e=>e.length>0))||this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)");return null}}function te(e,s,a){switch(s){case"world":for(const t of e.vertices)p(oe,t.pos,e.offset),a.worldUpAtPosition(oe,ae),t.setFrameFromUpVector(ae),t.computeRotationAxisAndAngleFromUpVector();break;case"path":p(oe,e.vertices[0].pos,e.offset),a.worldUpAtPosition(oe,ae),J(e,ae);for(const s of e.vertices){const e=t(m(s.frame.right,s.vRight));d(s.rotationFrame.up,s.vRight,s.vLeft),f(s.rotationFrame.up,s.rotationFrame.up,e),u(s.rotationFrame.up,s.rotationFrame.up);const a=m(s.rotationFrame.up,s.frame.up),n=m(s.rotationFrame.up,s.frame.right);if(f(oe,s.frame.up,-n),f(ne,s.frame.right,a),p(oe,oe,ne),u(s.rotationFrame.right,oe),K(s.rotationRight,s.frame,s.rotationFrame.right),y(oe,s.vLeft),s.rotationAngle=-e*(Math.PI-i(m(oe,s.vRight))),Math.abs(s.rotationAngle)>0){const e=r(Math.cos(.5*s.rotationAngle));o(s.miterStretch,1+(e-1)*s.rotationRight[0]*s.rotationRight[0],(e-1)*s.rotationRight[0]*s.rotationRight[1],(e-1)*s.rotationRight[0]*s.rotationRight[1],1+(e-1)*s.rotationRight[1]*s.rotationRight[1])}const l=Math.PI-s.rotationAngle;s.maxStretchDistance=Math.abs(Math.min(s.vLeftLength,s.vRightLength)*r(Math.cos(.5*l)))}}}function ie(e,t,i){switch(e){case"symbol-value":return i;case"proportional":return t;default:return e}}function re(e,t,i,r){let s=0;for(const a of e.vertices){const o=V(a.posES,i,t,r,pe);s+=pe.sampledElevation,p(ae,a.pos,e.offset),r.setAltitude(ae,o),g(a.pos,ae,e.offset)}return e.updatePathVertexInformation(),s/e.vertices.length}function se(e,t,i,r){const s=e.stageObject,a=s.geometryRecords,o=a.length;let n=0;r.spatialReference;for(let l=0;l<o;l++){const e=a[l].geometry;if(!G(e))continue;const o=e.path,h=o.builder.path;e.geometrySR,n+=re(h,t,i,r),"world"!==e.upVectorAlignment&&te(h,e.upVectorAlignment,r),o.onPathChanged(),e.invalidateBoundingInfo(),s.geometryVertexAttrsUpdated(l)}return n/o}const ae=v(),oe=_(),ne=_(),le=3,he=3,ce=10,pe={verticalDistanceToGround:0,sampledElevation:0};export default ee;export{ee as Graphics3DPathSymbolLayer,ce as NUM_CIRCLE_PROFILE_SUBDIVISIONS,he as NUM_ROUND_CAP_EXTRUSION_SUBDIVISIONS,le as NUM_ROUND_JOIN_SUBDIVISIONS};
