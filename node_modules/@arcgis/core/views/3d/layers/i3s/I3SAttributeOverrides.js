/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import e from"../../../../request.js";import{splitIntoChunks as t,remove as s}from"../../../../core/arrayUtils.js";import{resultOrAbort as i,result as r}from"../../../../core/asyncUtils.js";import{estimateStringByteSize as a,estimateNumberByteSize as n}from"../../../../core/byteSizeEstimations.js";import o from"../../../../core/Logger.js";import{isNone as c,unwrap as d,get as h,isSome as l}from"../../../../core/maybe.js";import{createAbortController as m,whenOrAbort as u}from"../../../../core/promiseUtils.js";import{formatNumber as g}from"../../../../intl/number.js";import{getMaximumQuerySize as b,queryAllJSON as p}from"../../../../layers/support/featureQueryAll.js";const f=o.getLogger("esri.views.3d.layers.i3s.I3SAttributeOverrides");class y{constructor(e,t){this.layer=e,this.warnMaximumChangedObjectsExceeded=!1,this.changedObjectIds=new Set,this.pendingFetchAbortController=m(),this.interactiveEditingSessions=null,this._maximumNumberOfEditOVerrides=v,this.memCache=t.getMemCache(`${e.uid}-attribute-overrides`),this.pendingFetchChangedObjectIds=this.fetchChangedObjectIds(this.pendingFetchAbortController.signal),this.pendingFetchChangedObjectIds.then((()=>this.pendingFetchAbortController=null))}destroy(){this.layer=null,this.memCache.destroy(),this.memCache=null,this.pendingFetchAbortController&&(this.pendingFetchAbortController.abort(),this.pendingFetchAbortController=null),this.pendingFetchChangedObjectIds=null}createInteractiveEditSession(e){this.changedObjectIds.add(e),c(this.interactiveEditingSessions)&&(this.interactiveEditingSessions=[]);const t=this.interactiveEditingSessions,i=new O(e,{rollback:()=>{s(t,i),0===t.length&&(this.interactiveEditingSessions=null)},commit:t=>{for(const[s,i]of t)this.updateValue(e,s,i)}});return t.unshift(i),i}async apply(e,t,s){if(c(t))return;const{loadedAttributes:i,attributeData:r}=t;if(c(i)||0===i.length||c(r))return;if(await u(this.pendingFetchChangedObjectIds,s),0===this.changedObjectIds.size)return;const a={loadedAttributes:i,attributeData:r},n=this.getOverridesFromCache(e,a,this.changedObjectIds),{objectIds:o,fieldNames:d}=n,h=await this.queryOverridesFromAssociatedLayer(o,d,s);c(h)||this.processOverridesFromAssociatedLayer(e,h,d,a)}updateValue(e,t,s){this.changedObjectIds.add(e),this.cacheValue(e,t,s)}cacheValue(e,t,s){this.memCache.put(this.getCacheKey(e,t),s,this.memCacheValueSize(s))}getOverridesFromCache(e,{loadedAttributes:t,attributeData:s},i){const r=new Set,a=new Array;for(const o of t)a[o.index]=s[o.name];const n=new Set;for(let o=0;o<e.length;o++){const s=e[o];if(i.has(s))for(const e of t){const t=this.fromCache(s,e.index);void 0===t?(r.add(s),n.add(e.name)):a[e.index][o]=t}}return{objectIds:Array.from(r),fieldNames:Array.from(n)}}fromCache(e,t){const s=this.fromInteractiveEditingSession(e,t);if(void 0!==s)return s;const i=this.getCacheKey(e,t);return this.memCache.get(i)}fromInteractiveEditingSession(e,t){if(!c(this.interactiveEditingSessions))for(const s of this.interactiveEditingSessions){if(s.objectId!==e)continue;const i=s.get(t);if(void 0!==i)return i}}getCacheKey(e,t){return`${e}-${t}`}async queryOverridesFromAssociatedLayer(e,s,r){if(0===e.length||0===s.length)return null;e=e.sort(((e,t)=>e-t)),this.warnMaximumChangedObjectsExceeded&&(this.warnMaximumChangedObjectsExceeded=!1,this.logMaximumObjectsExceededWarning());const a=d(this.layer.associatedLayer),n=a.createQuery();n.where="1=1",n.returnGeometry=!1,n.outFields=[a.objectIdField,...s],n.cacheHint=!0,n.objectIds=e;const o=b(a),c=e.length>o?t(e,o).map((e=>{const t=n.clone();return t.objectIds=e,i(p(a,t,{signal:r}))})):[i(p(a,n,{signal:r}))];return(await Promise.all(c)).reduce(((e,t)=>e.concat(t.ok?t.value.features:[])),[])}logMaximumObjectsExceededWarning(){let e=`The number of edited objects that are not yet cached in the scene service exceeds the maximum limit. Attribute changes will only be available for the first ${g(this._maximumNumberOfEditOVerrides)} objects. Please consider re-caching the scene service`;const t=this.layer.portalItem;t&&t.loaded?e+=` (${t.portal.url}/home/item.html?id=${t.id}#settings)`:e+=` (${this.layer.parsedUrl.path})`,f.warn("#queryOverrides()",this.layer.title,`${e}.`)}processOverridesFromAssociatedLayer(e,t,s,{loadedAttributes:i,attributeData:r}){const a=d(this.layer.associatedLayer).objectIdField,n=s.map((e=>r[e])),o=new Map(i.map((e=>[e.name,e.index]))),c=s.map((e=>o.get(e))),h=new Map(Array.from(e,((e,t)=>[e,t])));for(const d of t){const e=d.attributes[a];for(let t=0;t<s.length;t++){const i=c[t],r=h.get(e),a=d.attributes[s[t]];n[t][r]=a,this.cacheValue(e,i,a)}}}memCacheValueSize(e){return"string"==typeof e?a(e):n()}async fetchChangedObjectIds(t){var s,i,a;const n=this.layer;if(await n.load({signal:t}),this.changedObjectIds.clear(),c(n.associatedLayer)||null==(s=n.associatedLayer.capabilities)||null==(i=s.operations)||!i.supportsChangeTracking)return;const o=this.getFetchChangedObjectIdsServerGen();if(c(o))return null;const d=n.associatedLayer.layerId,m=await r(e(`${n.associatedLayer.url}/extractChanges`,{method:"post",query:{f:"json",returnIdsOnly:!0,layers:`${d}`,returnUpdates:!0,returnDeletes:!1,returnInserts:!1,layerServerGens:JSON.stringify([{id:d,serverGen:o}])},timeout:j,signal:t})),u=m.ok&&null!=(a=m.value.data)&&a.edits?h(m.value.data.edits[0],"objectIds","updates"):null;if(l(u)){const e=Math.min(this._maximumNumberOfEditOVerrides,u.length);e<u.length&&(this.warnMaximumChangedObjectsExceeded=!0);const t=u.sort(((e,t)=>e-t));for(let s=0;s<e;s++)this.changedObjectIds.add(t[s])}}getFetchChangedObjectIdsServerGen(){const e=this.layer;if(l(e.serviceUpdateTimeStamp)&&l(e.serviceUpdateTimeStamp.lastUpdate))return e.serviceUpdateTimeStamp.lastUpdate;const t=e.associatedLayer;return l(t)&&l(t.serverGens)&&l(t.serverGens.minServerGen)?t.serverGens.minServerGen:null}get test(){const e=Array.from(this.changedObjectIds),t=this.pendingFetchChangedObjectIds,s=this;return{changedObjectIds:e,pendingFetchChangedObjectIds:t,get maximumNumberOfEditOVerrides(){return s._maximumNumberOfEditOVerrides},set maximumNumberOfEditOVerrides(e){s._maximumNumberOfEditOVerrides=e}}}}class O{constructor(e,t){this.objectId=e,this.options=t,this.updates=new Map,this.state=0}get(e){return this.updates.get(e)}set(e,t){this.isActive&&this.updates.set(e,t)}rollback(){this.isActive&&(this.state=2,this.options.rollback())}commit(){this.isActive&&(this.state=1,this.options.commit(this.updates),this.updates.clear())}get isActive(){return 0===this.state}}const j=1e4,v=5e4;export{y as I3SAttributeOverrides};
