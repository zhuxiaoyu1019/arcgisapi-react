/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import e from"../../../Camera.js";import"../../../geometry.js";import t from"../../../Graphic.js";import n from"../../../Viewpoint.js";import{result as r}from"../../../core/asyncUtils.js";import"../../../core/has.js";import a from"../../../core/Error.js";import{isSome as o,isNone as i,unwrapOr as s,unwrap as c}from"../../../core/maybe.js";import{eachAlways as l}from"../../../core/promiseUtils.js";import{f as m,t as f}from"../../../chunks/mat3.js";import{c as u}from"../../../chunks/mat3f64.js";import{c as p}from"../../../chunks/mat4f64.js";import{a as g,b as h,i as y,g as d,f as x,s as w,t as v}from"../../../chunks/vec3.js";import{c as b}from"../../../chunks/vec3f64.js";import{projectVectorToPoint as j,projectPointToVector as R,projectBuffer as G,computeLinearTransformation as z,projectVectorToVector as S}from"../../../geometry/projection.js";import{empty as B,center as k,toRect as M,isPoint as Z,create as F,expandWithVec3 as A,expandWithAABB as E,width as U,height as P,depth as T}from"../../../geometry/support/aaBoundingBox.js";import{isPoint as I,create as N}from"../../../geometry/support/aaBoundingRect.js";import{intersectsPoint as O}from"../../../geometry/support/frustum.js";import{canProject as q,project as V}from"../../../geometry/support/webMercatorUtils.js";import{cameraOnContentAlongViewDirection as W}from"../camera/intersectionUtils.js";import{internalToExternal as C,scaleToDistance as Y,fromCenterDistance as $,fromExtent as D,scaleToResolution as X,zoomToScale as _,externalToInternal as H,computeScale as J,AsyncContext as K,distanceToScale as L,fromCenterScale as Q,directionToHeadingTilt as ee}from"./cameraUtils.js";import{getElevationAtPoint as te}from"./ElevationProvider.js";import{cyclicalDeg as ne}from"./mathUtils.js";import re from"../../../geometry/SpatialReference.js";import ae from"../../../geometry/Extent.js";import oe from"../../../geometry/Geometry.js";import ie from"../../../geometry/Point.js";const se=.66;function ce(e){return 360-ne.normalize(e)}function le(e){return ne.normalize(360-e)}function me(e){return o(e)&&e.resolver&&e.resolver.reject(),null}function fe(e,t){return o(e)&&e.resolver&&e.resolver.resolve(t),t}function ue(e,t,n,r=null){if(!t)return me(r);const a=e.spatialReference||re.WGS84;if(o(t.camera)){const e=t.get("camera.position.spatialReference");if(!q(e,a))return me(r);const n=t.camera.clone();return e.equals(a)||(n.position=V(n.position,a)),fe(r,n)}if(i(t.targetGeometry))return me(r);const s=t.get("targetGeometry.spatialReference");if(s&&!q(s,a))return me(r);const c=C(e,e.state.camera);let l=1;if(null!=t.rotation&&(c.heading=ce(t.rotation),l=0),null!=n&&(c.tilt=n),"point"===t.targetGeometry.type){const n=t.targetGeometry;let a;const o=t.targetGeometry.clone();return a=null!=t.scale?Y(e,t.scale,n.latitude):e.state.camera.distance,$(e,o,a,c,l,r)}const m=t.targetGeometry.extent;return D(e,m,c.heading,c.tilt,l,r)}function pe(e,t,r=null){return i(r)&&(r=new n),xe(e,null,t.clone(),r)}async function ge(t,r,o){const i=Fe(t,r);if(!i)throw new a("viewpointutils-create:no-target","Missing target for creating viewpoint");const s=new e({fov:t.camera.fov}),c=new n({camera:s});if(i.target instanceof n){return Ae(await je(t,i.target,i,o,c))}if(i.target instanceof e)return Ae(Re(t,i.target,c));const l=null!=i.scale||null!=i.zoom;if(i.target instanceof ae){const e=i.target.xmin===i.target.xmax||i.target.ymin===i.target.ymax;return Ae(l||e?await ze(t,i,i.target.center,s,o,c):await ke(t,i,i.target,s,o,c))}const m={boundingBox:B(),hasZ:!1,screenSpaceObjects:[]},f=l?ye(t,i):void 0;if(await be(t,i.target,f,m),isFinite(m.boundingBox[0])){let e;if(k(m.boundingBox,Ue),Ce.x=Ue[0],Ce.y=Ue[1],Ce.z=Ue[2],Ce.spatialReference=t.spatialReference,isFinite(Ce.z)&&m.hasZ?e=Z(m.boundingBox):(Ce.z=void 0,e=I(M(m.boundingBox,Ne))),l||e)return Ae(await ze(t,i,Ce,s,o,c));const n=Ee(t,m.screenSpaceObjects);return Ae(await Ze(t,i,Ce,m.boundingBox,n,s,o,c))}return i.position?Ae(Se(t,i,s,c)):Ae(await Be(t,i,s,o,c))}function he(e,t){return null==t.scale&&null!=t.zoom?_(e,t.zoom):t.scale}function ye(e,t){return X(e,he(e,t))}function de(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=ce(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function xe(e,t,n,r){const a=e.spatialReference||re.WGS84;return t=o(t)?t:H(e,n),i(t)||(r.targetGeometry=j(t.center,e.renderSpatialReference,a),r.scale=J(e,t),r.rotation=le(n.heading),r.camera=n),r}function we(e,t,n){if(!t)return;if(!q(t.spatialReference,e.spatialReference))throw new a("viewpointutils:incompatible-spatialreference",`Spatial reference (${t.spatialReference?t.spatialReference.wkid:"unknown"}) is incompatible with the view (${e.spatialReference.wkid})`,{geometry:t});const r=[];if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":n=t.extent.center;break;case"mesh":n=t.origin;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}n&&q(n,e.basemapTerrain.spatialReference)?Ue[2]=s(te(e.elevationProvider,n),0):Ue[2]=0}(0,Ye[t.type])(t,(e=>{r.push(e[0],e[1],e[2])}),Ue);const o=r.length/3;if(0===o)return;const i=new Array(r.length);if(G(r,t.spatialReference,0,i,e.spatialReference,0,o)){t.hasZ&&(n.hasZ=!0);for(let e=0;e<i.length;e+=3)t.hasZ?(Ue[0]=i[e+0],Ue[1]=i[e+1],Ue[2]=i[e+2]):(Ue[0]=i[e+0],Ue[1]=i[e+1]),A(n.boundingBox,Ue)}}async function ve(e,t,n,a){const o=await r(e.whenViewForGraphic(t));if(!1===o.ok||i(o.value)||!("whenGraphicBounds"in o.value))return void we(e,t.geometry,a);const s=o.value,c=await r(s.whenGraphicBounds(t,{minDemResolution:n}));if(!1===c.ok)return void we(e,t.geometry,a);const{screenSpaceObjects:l,boundingBox:m}=c.value;E(a.boundingBox,m),l&&l.forEach((e=>{a.screenSpaceObjects.push(e)})),isFinite(m[2])&&(a.hasZ=!0)}async function be(e,n,r,a){if(Array.isArray(n)&&2===n.length){const t=n[0],r=n[1];if("number"==typeof t&&"number"==typeof r)return Ce.x=t,Ce.y=r,Ce.z=void 0,Ce.spatialReference=e.spatialReference.isGeographic?e.spatialReference:re.WGS84,void we(e,Ce,a)}n&&"function"==typeof n.map?await l(n.map((t=>be(e,t,r,a)))):n instanceof oe?we(e,n,a):n instanceof t&&await ve(e,n,r,a)}async function je(e,t,n,r,a){if(o(t.camera))return Re(e,t.camera,a);a.scale=t.scale,a.rotation=t.rotation,a.targetGeometry=o(t.targetGeometry)?t.targetGeometry.clone():null,a.camera=null,null!=n.heading?a.rotation=le(n.heading):null!=n.rotation&&(a.rotation=n.rotation);const i=he(e,n);null!=i&&(a.scale=i);const s=new K(r);return ue(e,a,n.tilt,s),a.camera=await s.resolver.promise,a}function Re(e,t,n){const r=e.spatialReference,a=t.position.spatialReference;return q(a,r)?((t=t.clone()).fov=e.camera.fov,a.equals(r)||(t.position=V(t.position,r)),xe(e,null,t,n)):null}function Ge(e,t,n,r,a,o){const i=e.renderSpatialReference;return R(n.position,qe,i),R(t,Ve,i),o.targetGeometry=new ie(t),a.position=new ie(n.position),x(Oe,Ve,qe),ee(e,qe,Oe,r.up,a),o.scale=L(e,y(qe,Ve),o.targetGeometry.latitude),o.rotation=le(a.heading),o.camera=a,o}async function ze(e,t,n,r,o,s){if(i(n))throw new a("createfromcenter","invalid point");s.targetGeometry=n.clone();const c=W(e);if(t.position)return Ge(e,s.targetGeometry,t,c,r,s);if(t.zoomFactor){const r=c.distance/t.zoomFactor,a=g(Ue,c.viewForward,-r);c.eye=h(Ue,c.center,a),s.scale=L(e,r,n.latitude)}C(e,c,r);const l=de(r,t)?0:1;if(!t.zoomFactor){s.scale=he(e,t),null==s.scale&&(R(n,Ue,e.renderSpatialReference),O(c.frustum,Ue)?s.scale=L(e,y(c.eye,Ue),n.latitude):s.scale=J(e,c));const a=new K(o);Q(e,s.targetGeometry,s.scale,r,l,a),s.camera=await a.resolver.promise}return s}function Se(e,t,n,r){const a=W(e);return d(Oe,a.viewForward),ee(e,a.eye,Oe,a.up,We),n.position=new ie(t.position),n.heading=null!=t.heading?t.heading:We.heading,n.tilt=null!=t.tilt?t.tilt:We.tilt,xe(e,null,n,r)}async function Be(e,t,n,r,a){const o=W(e);return ze(e,t,j(o.center,e.renderSpatialReference,e.spatialReference),n,r,a)}async function ke(e,t,n,r,a,o){o.targetGeometry=n.clone();const i=W(e);C(e,i,r);const s=de(r,t)?0:1,c=new K(a);return D(e,n,r.heading,r.tilt,s,c),o.camera=await c.resolver.promise,o}function Me(e,t,n,r,a){let o=0;n.hasZ?o=n.z:e.basemapTerrain&&(o=c(te(e.elevationProvider,n))),w(Ue,n.x,n.y,o),z(e.spatialReference,Ue,Pe,e.renderSpatialReference),m(Te,Pe),f(Te,Te),B(Ie);const i=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let c=0;c<i.length;c++){const t=i[c];let n=r[t[2]];isFinite(n)||(n=o),w(Ue,r[t[0]],r[t[1]],n),S(Ue,e.spatialReference,Ue,e.renderSpatialReference),A(Ie,v(Ue,Ue,Te))}const s=U(Ie),l=P(Ie),u=T(Ie),p=1/Math.tan(t.fovX/2),g=1/Math.tan(t.fovY/2),h=.5*Math.sqrt(s*s+u*u)*Math.max(g,p)+.5*l,y=.5*l*g+.5*Math.max(s,u);return Math.max(h,y)/a}async function Ze(e,t,n,r,a,o,i,s){s.targetGeometry=n.clone();const c=W(e),l=Me(e,c,n,r,a);C(e,c,o);const m=de(o,t)?0:1;s.scale=L(e,l,s.targetGeometry.latitude);const f=new K(i);return Q(e,s.targetGeometry,s.scale,o,m,f),s.camera=await f.resolver.promise,s}function Fe(e,t){if(!t||!e.spatialReference)return null;const n={target:null};if("declaredClass"in t||Array.isArray(t))n.target=t;else{for(const e in t)n[e]=t[e];t.center&&!n.target&&(n.target=t.center)}return n}function Ae(e){return e&&o(e.camera)&&(e.rotation=le(e.camera.heading)),e}function Ee(e,t){const n=se;if(!t.length)return n;let r=Number.NEGATIVE_INFINITY;for(let a=0;a<t.length;a++){const e=t[a].screenSpaceBoundingRect;r=Math.max(r,Math.abs(e[0]),Math.abs(e[1]),Math.abs(e[2]),Math.abs(e[3]))}return n-r/Math.min(e.width,e.height)*2}const Ue=b(),Pe=p(),Te=u(),Ie=F(),Ne=N(),Oe=b(),qe=b(),Ve=b(),We={heading:0,tilt:0},Ce=new ie,Ye={point(e,t,n){n[0]=e.x,n[1]=e.y,e.hasZ&&(n[2]=e.z),t(n)},polygon(e,t,n){const r=e.hasZ;for(let a=0;a<e.rings.length;a++){const o=e.rings[a];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],r&&(n[2]=o[e][2]),t(n)}},polyline(e,t,n){const r=e.hasZ;for(let a=0;a<e.paths.length;a++){const o=e.paths[a];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],r&&(n[2]=o[e][2]),t(n)}},multipoint(e,t,n){const r=e.points,a=e.hasZ;for(let o=0;o<r.length;o++)n[0]=r[o][0],n[1]=r[o][1],a&&(n[2]=r[o][2]),t(n)},extent(e,t,n){e.hasZ?(t(w(n,e.xmin,e.ymin,e.zmin)),t(w(n,e.xmax,e.ymin,e.zmin)),t(w(n,e.xmin,e.ymax,e.zmin)),t(w(n,e.xmax,e.ymax,e.zmin)),t(w(n,e.xmin,e.ymin,e.zmax)),t(w(n,e.xmax,e.ymin,e.zmax)),t(w(n,e.xmin,e.ymax,e.zmax)),t(w(n,e.xmax,e.ymax,e.zmax))):(t(w(n,e.xmin,e.ymin,n[2])),t(w(n,e.xmax,e.ymin,n[2])),t(w(n,e.xmin,e.ymax,n[2])),t(w(n,e.xmax,e.ymax,n[2])))},mesh(e,t,n){const r=e.vertexAttributes&&e.vertexAttributes.position;if(r)for(let a=0;a<r.length;a+=3)t(w(n,r[a+0],r[a+1],r[a+2]))}};export{ge as create,pe as fromCamera,le as headingToRotation,ce as rotationToHeading,ue as toCamera};
