/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import{clamp as t}from"../../../../core/mathUtils.js";import{createRenderScreenPointArray3 as r}from"../../../../core/screenUtils.js";import{property as o}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/accessorSupport/ensureType.js";import"../../../../core/Logger.js";import{subclass as s}from"../../../../core/accessorSupport/decorators/subclass.js";import{d as i,z as n,g as a,e as c,f as d,n as p}from"../../../../chunks/vec3.js";import{c as h}from"../../../../chunks/vec3f64.js";import u from"../../../../geometry/Point.js";import{wrap as l}from"../../../../geometry/support/ray.js";import{PropertiesPool as m}from"../PropertiesPool.js";import{PointOfInterest as f}from"./PointOfInterest.js";import{TaskPriority as y}from"../../../support/Scheduler.js";const g=Array;let _=class extends f{constructor(e){super(e),this._propertiesPool=new m({location:u,renderLocation:g},this),this._dirty=!0,this.renderLocation=this._propertiesPool.get("renderLocation")}initialize(){this.handles.add([this.centerOnSurface.watch("renderLocation",(()=>this.updateRenderLocation())),this.state.watch("camera",(()=>this.updateRenderLocation()))]),this.scheduler&&this.handles.add(this.scheduler.registerTask(y.POINT_OF_INTEREST_FREQUENT,this))}destroy(){this._propertiesPool.destroy(),this._propertiesPool=null}get updating(){return this._dirty||this.centerOnSurface.updating}get location(){const e=this._propertiesPool.get("location");return this.renderCoordsHelper.fromRenderCoords(this.renderLocation,e,this.state.spatialReference),e}get running(){return this._dirty}runTask(){const e=this._get("renderLocation"),r=this.centerOnSurface.renderLocation,o=this.renderCoordsHelper,s=this.state.camera;this._dirty=!1,o.worldUpAtPosition(r,S);const d=Math.max(0,(Math.acos(i(S,s.viewForward))-.5*Math.PI)*(s.aboveGround?1:-1));if(Number.isNaN(d)){if(!e||!n(e,r)){const e=this._propertiesPool.get("renderLocation");a(e,r),this._set("renderLocation",e)}return}const p=1-t(d/(.5*Math.PI),0,1),h=p*p*p;this._calculateScreenHorizontalEdgeOnSurface(O);const u=this._propertiesPool.get("renderLocation");c(u,r,O,h),e&&n(e,u)||this._set("renderLocation",u)}_calculateScreenHorizontalEdgeOnSurface(e){const t=this.state.camera,o=t.getRenderCenter(r());if(o[1]=t.aboveGround?t.padding[2]:t.fullHeight-t.padding[0],this.estimateSurfaceIntersectionAtRenderPoint(o,e))return e;const s=this.renderCoordsHelper.getAltitude(this.centerOnSurface.renderLocation);if(t.unprojectFromRenderScreen(o,L)){d(L,L,t.eye);const r=p(L,L);if(this.renderCoordsHelper.intersectManifold(l(t.eye,r),s,e))return e}return this.renderCoordsHelper.setAltitude(e,s,t.eye)}updateRenderLocation(){this._dirty=!0}};e([o()],_.prototype,"_dirty",void 0),e([o({constructOnly:!0})],_.prototype,"scheduler",void 0),e([o({constructOnly:!0})],_.prototype,"centerOnSurface",void 0),e([o({constructOnly:!0})],_.prototype,"estimateSurfaceIntersectionAtRenderPoint",void 0),e([o({readOnly:!0})],_.prototype,"updating",null),e([o({readOnly:!0})],_.prototype,"location",null),e([o({readOnly:!0})],_.prototype,"renderLocation",void 0),_=e([s("esri.views.3d.support.CenterOnSurface")],_);const S=h(),L=h(),O=h();var P=_;export default P;export{_ as Focus};
