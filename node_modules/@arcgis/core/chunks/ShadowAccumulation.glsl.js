/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
import{ScreenSpacePass as e}from"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.js";import{ReadLinearDepth as a}from"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js";import{ReadShadowMap as r}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{CameraSpace as o}from"../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl.js";import{RgbaFloatEncoding as t}from"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js";import{glsl as s}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as d}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";const i=255,l=1/i;function n(n){const m=new d;m.fragment.include(t),m.fragment.include(a),m.include(o),m.include(e);const{pass:p}=n;if(1===p){const{visualization:e,bandsEnabled:a}=n;m.fragment.constants.add("inverseSampleValue","float",i),m.fragment.uniforms.add("shadowAccumulationMap","sampler2D"),m.fragment.uniforms.add("sampleScale","float"),m.fragment.uniforms.add("opacityFromElevation","float"),0===e?(m.fragment.uniforms.add("colorRamp","sampler2D"),m.fragment.uniforms.add("rampSize","float"),m.fragment.code.add(s`vec4 sampleColorRamp(sampler2D ramp, float rampSize, float u) {
float rampU = (u * (rampSize - 1.0) + 0.5) / rampSize;
return texture2D(ramp, vec2(rampU, 0.5));
}`),a&&m.fragment.uniforms.add("bandSize","float")):1===e&&(m.fragment.uniforms.add("threshold","float"),m.fragment.uniforms.add("colors","vec4",2)),m.fragment.code.add(s`
      void main(void) {
        vec4 record = texture2D(shadowAccumulationMap, uv);
        float pixelSamples = record.r * inverseSampleValue;

        if (pixelSamples < 1.0) {
          discard;
        }

        float strength = pixelSamples * sampleScale;

        ${0===e&&a?s`strength = ceil(strength / bandSize) * bandSize;`:""}

        gl_FragColor = ${0===e?s`sampleColorRamp(colorRamp, rampSize, strength)`:s`strength <= threshold ? colors[0] : colors[1]`};

        gl_FragColor.a *= opacityFromElevation;
      }
    `)}else 0!==p&&2!==p||(m.include(r),m.fragment.uniforms.add("depthMap","sampler2D"),m.fragment.uniforms.add("inverseView","mat4"),m.fragment.uniforms.add("nearFar","vec2"),0===p?m.fragment.constants.add("sampleValue","float",l):m.fragment.constants.add("shadowColor","vec4",[0,0,0,.8]),m.fragment.code.add(s`
      void main(void) {

        float depth = rgba2float(texture2D(depthMap, uv));
        // 0.0 is the clear value of depthMap, which means nothing has been drawn there and we should discard
        if (depth == 0.0) {
          discard;
        }

        float currentPixelDepth = linearDepthFromFloat(depth, nearFar);

        if (-currentPixelDepth > nearFar.y || -currentPixelDepth < nearFar.x) {
          discard;
        }

        vec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);
        vec4 worldSpacePos = inverseView * currentPixelPos;

        mat4 shadowMatrix;
        float linearDepth = -currentPixelDepth;
        int i = chooseCascade(linearDepth, shadowMatrix);

        if (i >= uShadowMapNum) {
          discard;
        }

        vec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);

        // vertex completely outside? -> no shadow
        if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {
          discard;
        }

        vec2 uvShadow = cascadeCoordinates(i, lvpos);

        float depthShadow = readShadowMapDepth(uvShadow, uShadowMapTex);
        bool shadow = depthShadow < lvpos.z;

        if (!shadow) {
          discard;
        }

        gl_FragColor = ${0===p?s`vec4(sampleValue)`:s`shadowColor`};
      }
    `));return m}var m=Object.freeze({__proto__:null,shadowAccumulationMaxSamples:i,build:n});export{m as S,n as b,i as s};
