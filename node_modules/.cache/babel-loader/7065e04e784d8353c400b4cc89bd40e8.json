{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { RgbaFloatEncoding as a } from \"../util/RgbaFloatEncoding.glsl.js\";\nimport { glsl as e } from \"../../shaderModules/interfaces.js\";\n\nfunction t(t) {\n  t.fragment.include(a), t.fragment.uniforms.add(\"uShadowMapTex\", \"sampler2D\"), t.fragment.uniforms.add(\"uShadowMapNum\", \"int\"), t.fragment.uniforms.add(\"uShadowMapDistance\", \"vec4\"), t.fragment.uniforms.add(\"uShadowMapMatrix\", \"mat4\", 4), t.fragment.uniforms.add(\"uDepthHalfPixelSz\", \"float\"), t.fragment.code.add(e`int chooseCascade(float _linearDepth, out mat4 mat) {\nvec4 distance = uShadowMapDistance;\nfloat depth = _linearDepth;\nint i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\nmat = i == 0 ? uShadowMapMatrix[0] : i == 1 ? uShadowMapMatrix[1] : i == 2 ? uShadowMapMatrix[2] : uShadowMapMatrix[3];\nreturn i;\n}\nvec3 lightSpacePosition(vec3 _vpos, mat4 mat) {\nvec4 lv = mat * vec4(_vpos, 1.0);\nlv.xy /= lv.w;\nreturn 0.5 * lv.xyz + vec3(0.5);\n}\nvec2 cascadeCoordinates(int i, vec3 lvpos) {\nreturn vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n}\nfloat readShadowMapDepth(vec2 uv, sampler2D _depthTex) {\nreturn rgba2float(texture2D(_depthTex, uv));\n}\nfloat posIsInShadow(vec2 uv, vec3 lvpos, sampler2D _depthTex) {\nreturn readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;\n}\nfloat filterShadow(vec2 uv, vec3 lvpos, float halfPixelSize, sampler2D _depthTex) {\nfloat texSize = 0.5 / halfPixelSize;\nvec2 st = fract((vec2(halfPixelSize) + uv) * texSize);\nfloat s00 = posIsInShadow(uv + vec2(-halfPixelSize, -halfPixelSize), lvpos, _depthTex);\nfloat s10 = posIsInShadow(uv + vec2(halfPixelSize, -halfPixelSize), lvpos, _depthTex);\nfloat s11 = posIsInShadow(uv + vec2(halfPixelSize, halfPixelSize), lvpos, _depthTex);\nfloat s01 = posIsInShadow(uv + vec2(-halfPixelSize, halfPixelSize), lvpos, _depthTex);\nreturn mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n}\nfloat readShadowMap(const in vec3 _vpos, float _linearDepth) {\nmat4 mat;\nint i = chooseCascade(_linearDepth, mat);\nif (i >= uShadowMapNum) { return 0.0; }\nvec3 lvpos = lightSpacePosition(_vpos, mat);\nif (lvpos.z >= 1.0) { return 0.0; }\nif (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\nvec2 uv = cascadeCoordinates(i, lvpos);\nreturn filterShadow(uv, lvpos, uDepthHalfPixelSz, uShadowMapTex);\n}`);\n}\n\nfunction o(a, e) {\n  e.shadowMappingEnabled && (e.shadowMap.bind(a), e.shadowMap.bindView(a, e.origin));\n}\n\nfunction i(a, e, t) {\n  e.shadowMappingEnabled && e.shadowMap.bindView(a, t);\n}\n\nfunction l(a, e) {\n  e.shadowMappingEnabled && e.shadowMap.bindView(a, e.origin);\n}\n\nexport { t as ReadShadowMap, o as bindReadShadowMapUniforms, l as bindReadShadowMapView, i as bindReadShadowMapViewCustomOrigin };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgis-api-react/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js"],"names":["RgbaFloatEncoding","a","glsl","e","t","fragment","include","uniforms","add","code","o","shadowMappingEnabled","shadowMap","bind","bindView","origin","i","l","ReadShadowMap","bindReadShadowMapUniforms","bindReadShadowMapView","bindReadShadowMapViewCustomOrigin"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,iBAAiB,IAAIC,CAA5B,QAAkC,mCAAlC;AAAsE,SAAOC,IAAI,IAAIC,CAAf,QAAqB,mCAArB;;AAAyD,SAASC,CAAT,CAAWA,CAAX,EAAa;AAACA,EAAAA,CAAC,CAACC,QAAF,CAAWC,OAAX,CAAmBL,CAAnB,GAAsBG,CAAC,CAACC,QAAF,CAAWE,QAAX,CAAoBC,GAApB,CAAwB,eAAxB,EAAwC,WAAxC,CAAtB,EAA2EJ,CAAC,CAACC,QAAF,CAAWE,QAAX,CAAoBC,GAApB,CAAwB,eAAxB,EAAwC,KAAxC,CAA3E,EAA0HJ,CAAC,CAACC,QAAF,CAAWE,QAAX,CAAoBC,GAApB,CAAwB,oBAAxB,EAA6C,MAA7C,CAA1H,EAA+KJ,CAAC,CAACC,QAAF,CAAWE,QAAX,CAAoBC,GAApB,CAAwB,kBAAxB,EAA2C,MAA3C,EAAkD,CAAlD,CAA/K,EAAoOJ,CAAC,CAACC,QAAF,CAAWE,QAAX,CAAoBC,GAApB,CAAwB,mBAAxB,EAA4C,OAA5C,CAApO,EAAyRJ,CAAC,CAACC,QAAF,CAAWI,IAAX,CAAgBD,GAAhB,CAAoBL,CAAE;AAC5b;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAvCsa,CAAzR;AAuCzI;;AAAA,SAASO,CAAT,CAAWT,CAAX,EAAaE,CAAb,EAAe;AAACA,EAAAA,CAAC,CAACQ,oBAAF,KAAyBR,CAAC,CAACS,SAAF,CAAYC,IAAZ,CAAiBZ,CAAjB,GAAoBE,CAAC,CAACS,SAAF,CAAYE,QAAZ,CAAqBb,CAArB,EAAuBE,CAAC,CAACY,MAAzB,CAA7C;AAA+E;;AAAA,SAASC,CAAT,CAAWf,CAAX,EAAaE,CAAb,EAAeC,CAAf,EAAiB;AAACD,EAAAA,CAAC,CAACQ,oBAAF,IAAwBR,CAAC,CAACS,SAAF,CAAYE,QAAZ,CAAqBb,CAArB,EAAuBG,CAAvB,CAAxB;AAAkD;;AAAA,SAASa,CAAT,CAAWhB,CAAX,EAAaE,CAAb,EAAe;AAACA,EAAAA,CAAC,CAACQ,oBAAF,IAAwBR,CAAC,CAACS,SAAF,CAAYE,QAAZ,CAAqBb,CAArB,EAAuBE,CAAC,CAACY,MAAzB,CAAxB;AAAyD;;AAAA,SAAOX,CAAC,IAAIc,aAAZ,EAA0BR,CAAC,IAAIS,yBAA/B,EAAyDF,CAAC,IAAIG,qBAA9D,EAAoFJ,CAAC,IAAIK,iCAAzF","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{RgbaFloatEncoding as a}from\"../util/RgbaFloatEncoding.glsl.js\";import{glsl as e}from\"../../shaderModules/interfaces.js\";function t(t){t.fragment.include(a),t.fragment.uniforms.add(\"uShadowMapTex\",\"sampler2D\"),t.fragment.uniforms.add(\"uShadowMapNum\",\"int\"),t.fragment.uniforms.add(\"uShadowMapDistance\",\"vec4\"),t.fragment.uniforms.add(\"uShadowMapMatrix\",\"mat4\",4),t.fragment.uniforms.add(\"uDepthHalfPixelSz\",\"float\"),t.fragment.code.add(e`int chooseCascade(float _linearDepth, out mat4 mat) {\nvec4 distance = uShadowMapDistance;\nfloat depth = _linearDepth;\nint i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\nmat = i == 0 ? uShadowMapMatrix[0] : i == 1 ? uShadowMapMatrix[1] : i == 2 ? uShadowMapMatrix[2] : uShadowMapMatrix[3];\nreturn i;\n}\nvec3 lightSpacePosition(vec3 _vpos, mat4 mat) {\nvec4 lv = mat * vec4(_vpos, 1.0);\nlv.xy /= lv.w;\nreturn 0.5 * lv.xyz + vec3(0.5);\n}\nvec2 cascadeCoordinates(int i, vec3 lvpos) {\nreturn vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n}\nfloat readShadowMapDepth(vec2 uv, sampler2D _depthTex) {\nreturn rgba2float(texture2D(_depthTex, uv));\n}\nfloat posIsInShadow(vec2 uv, vec3 lvpos, sampler2D _depthTex) {\nreturn readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;\n}\nfloat filterShadow(vec2 uv, vec3 lvpos, float halfPixelSize, sampler2D _depthTex) {\nfloat texSize = 0.5 / halfPixelSize;\nvec2 st = fract((vec2(halfPixelSize) + uv) * texSize);\nfloat s00 = posIsInShadow(uv + vec2(-halfPixelSize, -halfPixelSize), lvpos, _depthTex);\nfloat s10 = posIsInShadow(uv + vec2(halfPixelSize, -halfPixelSize), lvpos, _depthTex);\nfloat s11 = posIsInShadow(uv + vec2(halfPixelSize, halfPixelSize), lvpos, _depthTex);\nfloat s01 = posIsInShadow(uv + vec2(-halfPixelSize, halfPixelSize), lvpos, _depthTex);\nreturn mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n}\nfloat readShadowMap(const in vec3 _vpos, float _linearDepth) {\nmat4 mat;\nint i = chooseCascade(_linearDepth, mat);\nif (i >= uShadowMapNum) { return 0.0; }\nvec3 lvpos = lightSpacePosition(_vpos, mat);\nif (lvpos.z >= 1.0) { return 0.0; }\nif (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\nvec2 uv = cascadeCoordinates(i, lvpos);\nreturn filterShadow(uv, lvpos, uDepthHalfPixelSz, uShadowMapTex);\n}`)}function o(a,e){e.shadowMappingEnabled&&(e.shadowMap.bind(a),e.shadowMap.bindView(a,e.origin))}function i(a,e,t){e.shadowMappingEnabled&&e.shadowMap.bindView(a,t)}function l(a,e){e.shadowMappingEnabled&&e.shadowMap.bindView(a,e.origin)}export{t as ReadShadowMap,o as bindReadShadowMapUniforms,l as bindReadShadowMapView,i as bindReadShadowMapViewCustomOrigin};\n"]},"metadata":{},"sourceType":"module"}