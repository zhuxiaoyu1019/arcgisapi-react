{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { Slice as e } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { ReadLinearDepth as i } from \"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";\nimport { multipassTerrainTest as o } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";\nimport { glsl as s } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as n } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { AdjustProjectedPosition as t } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/AdjustProjectedPosition.glsl.js\";\nimport { DiscardByCoverage as d } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardByCoverage.glsl.js\";\nimport { DiscardNonSilhouetteEdges as a } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardNonSilhouetteEdges.glsl.js\";\nimport { DiscardShortEdges as l } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardShortEdges.glsl.js\";\nimport { EdgeUtil as r } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/EdgeUtil.glsl.js\";\nimport { LineAmplitude as c } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/LineAmplitude.glsl.js\";\nimport { LineOffset as P } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/LineOffset.glsl.js\";\nimport { UnpackAttributes as u } from \"../views/3d/webgl-engine/shaders/sources/edgeRenderer/UnpackAttributes.glsl.js\";\n\nfunction p(p) {\n  const v = new n(),\n        g = v.vertex,\n        f = v.fragment;\n  return p.legacy && g.uniforms.add(\"uModel\", \"mat4\"), p.antialiasing && (g.code.add(s`#define ANTIALIASING 1`), f.code.add(s`#define ANTIALIASING 1`)), v.include(t, p), v.include(c, p), v.include(r, p), v.include(u, p), v.include(P, p), v.include(e, p), v.include(a, p), v.include(d, p), v.include(l, p), v.varyings.add(\"vColor\", \"vec4\"), v.varyings.add(\"vRadius\", \"float\"), v.varyings.add(\"vPosition\", \"vec3\"), v.varyings.add(\"vWorldPosition\", \"vec3\"), v.varyings.add(\"vViewPos\", \"vec3\"), v.varyings.add(\"vLineLengthPixels\", \"float\"), v.varyings.add(\"vSizeFalloffFactor\", \"float\"), g.uniforms.add(\"uPixelToNDC\", \"vec2\"), g.uniforms.add(\"uNDCToPixel\", \"vec2\"), g.uniforms.add(\"uPixelRatio\", \"float\"), v.attributes.add(\"position0\", \"vec3\"), v.attributes.add(\"position1\", \"vec3\"), v.attributes.add(\"variantOffset\", \"float\"), v.attributes.add(\"variantStroke\", \"float\"), v.attributes.add(\"variantExtension\", \"float\"), g.code.add(s`const float opaqueCutoff = 1.0 / 255.0;\nvoid calculateGeometricOutputs(vec3 viewPosV0, vec3 viewPosV1, vec3 worldPosV0, vec3 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\nvec2 sideness = unpackedAttributes.sideness;\nvec2 sidenessNorm = unpackedAttributes.sidenessNorm;\nvWorldPosition = mix(worldPosV0, worldPosV1, sidenessNorm.y).xyz;\nvec3 viewPos = mix(viewPosV0, viewPosV1, sidenessNorm.y);\nvViewPos = viewPos;\nvec4 projPosV0 = projFromViewPosition(viewPosV0);\nvec4 projPosV1 = projFromViewPosition(viewPosV1);\nvec4 projPos = projFromViewPosition(viewPos);\nvec3 screenSpaceLineNDC = (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);\nvec2 screenSpaceLinePixels = screenSpaceLineNDC.xy * uNDCToPixel;\nfloat lineLengthPixels = length(screenSpaceLinePixels);\nfloat dzPerPixel = screenSpaceLineNDC.z / lineLengthPixels;\nvec2 screenSpaceDirection = screenSpaceLinePixels / lineLengthPixels;\nvec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;\nfloat falloffFactor = distanceBasedPerspectiveFactor(-viewPos.z) * uPixelRatio;\nfloat lineWidthPixels = unpackedAttributes.lineWidthPixels * falloffFactor;\nfloat extensionLengthPixels = calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;\nfloat lineAmplitudePixels = calculateLineAmplitude(unpackedAttributes) * uPixelRatio;\nvSizeFalloffFactor = falloffFactor;\nfloat lineWidthAndAmplitudePixels = lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;\nfloat extendedLineLengthPixels = lineLengthPixels + extensionLengthPixels + extensionLengthPixels;\n#ifdef ANTIALIASING\nconst float aaPaddingPixels = 1.0;\nfloat halfAAPaddedLineWidthAndAmplitudePixels = lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;\nfloat aaPaddedRoundedCapSizePixels = lineWidthPixels * 0.5 + aaPaddingPixels;\n#else\nfloat halfAAPaddedLineWidthAndAmplitudePixels = max(lineWidthAndAmplitudePixels, 1.0) * 0.5;\nfloat aaPaddedRoundedCapSizePixels = max(lineWidthPixels, 1.0) * 0.5;\n#endif\nvec2 halfAAPaddedLineWidthAndAmplitudeNDC = halfAAPaddedLineWidthAndAmplitudePixels * uPixelToNDC;\nvec2 aaPaddedRoundedCapSizeNDC = aaPaddedRoundedCapSizePixels * uPixelToNDC;\nvec2 extensionLengthNDC = extensionLengthPixels * uPixelToNDC;\nvec2 ndcOffset = (\nscreenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)\n+ perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC\n);\nprojPos.xy += ndcOffset * projPos.w;\nprojPos.z += (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;\nprojPos = adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));\nfloat aaPaddedLineWithCapsLengthPixels = extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;\nfloat pixelPositionAlongLine = aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;\nvPosition = vec3(\nhalfAAPaddedLineWidthAndAmplitudePixels * sideness.x,\npixelPositionAlongLine,\npixelPositionAlongLine / extendedLineLengthPixels\n);\nvRadius = lineWidthPixels * 0.5;\nvLineLengthPixels = extendedLineLengthPixels;\ndiscardShortEdges(unpackedAttributes, lineLengthPixels);\ngl_Position = projPos;\n}\nvoid main() {\nComponentData component = readComponentData();\nUnpackedAttributes unpackedAttributes = unpackAttributes(component);\nvec3 worldPosV0 = worldFromModelPosition(position0);\nvec3 worldPosV1 = worldFromModelPosition(position1);\nvec3 viewPosV0 = viewFromModelPosition(position0);\nvec3 viewPosV1 = viewFromModelPosition(position1);\nvColor = component.color;\nif (vColor.a < opaqueCutoff) {\ngl_Position = vec4(10.0, 10.0, 10.0, 1.0);\nreturn;\n}\nif (discardNonSilhouetteEdges(viewPosV0, worldPosV0)) {\nreturn;\n}\ncalculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal(), unpackedAttributes);\ncalculateStyleOutputs(unpackedAttributes);\n}`), p.multipassTerrainEnabled && (v.fragment.include(i), v.include(o, p)), v.fragment.code.add(s`\n    vec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {\n      float lineOffset = calculateLineOffset();\n      float positionX = position.x - lineOffset;\n\n      if (radius < 1.0) {\n        // Handle this specifically for subpixel sizes:\n        // 1. Compute correct coverage (note coverage is computed by\n        //    0.5 - dist, so we make sure that that will lead to correct\n        //    subpixel coverage\n        // 2. Ignore rounded caps\n        float coverageX = clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);\n        float coverageY = clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);\n\n        float coverage = min(coverageX, coverageY);\n\n        return vec2(0.5 - coverage, 0.0);\n      }\n      else {\n        // Between -radius -> 0 for start cap, 0 for line, 0 -> radius\n        float positionOnCap = position.y - clamp(position.y, 0.0, lineLength);\n\n        vec2 lineToPosition = vec2(positionX, positionOnCap);\n        return vec2(length(lineToPosition) - radius, positionOnCap / radius);\n      }\n    }\n\n    void main() {\n      ${p.multipassTerrainEnabled ? \"terrainDepthTest(gl_FragCoord, vViewPos.z);\" : \"\"}\n      float radius = vRadius * calculateLinePressure();\n\n      vec2 distance = lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);\n      float coverage = clamp(0.5 - distance.x, 0.0, 1.0);\n\n      discardByCoverage(radius, coverage);\n      discardBySlice(vWorldPosition);\n\n      float alpha = vColor.a * coverage;\n\n      gl_FragColor = vec4(vColor.rgb, alpha);\n\n    }\n  `), v;\n}\n\nvar v = Object.freeze({\n  __proto__: null,\n  build: p\n});\nexport { v as E, p as b };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgisapi-react/node_modules/@arcgis/core/chunks/EdgeShaderProgram.glsl.js"],"names":["Slice","e","ReadLinearDepth","i","multipassTerrainTest","o","glsl","s","ShaderBuilder","n","AdjustProjectedPosition","t","DiscardByCoverage","d","DiscardNonSilhouetteEdges","a","DiscardShortEdges","l","EdgeUtil","r","LineAmplitude","c","LineOffset","P","UnpackAttributes","u","p","v","g","vertex","f","fragment","legacy","uniforms","add","antialiasing","code","include","varyings","attributes","multipassTerrainEnabled","Object","freeze","__proto__","build","E","b"],"mappings":"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CQ,IAAF,CAAOF,GAAP,CAAW3B,CAAE;AACjxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAtEowE,CAAl1B,EAsE96CmB,CAAC,CAACc,uBAAF,KAA4Bb,CAAC,CAACI,QAAF,CAAWM,OAAX,CAAmBlC,CAAnB,GAAsBwB,CAAC,CAACU,OAAF,CAAUhC,CAAV,EAAYqB,CAAZ,CAAlD,CAtE86C,EAsE52CC,CAAC,CAACI,QAAF,CAAWK,IAAX,CAAgBF,GAAhB,CAAoB3B,CAAE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQmB,CAAC,CAACc,uBAAF,GAA0B,6CAA1B,GAAwE,EAAG;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GA1CsE,CAtE42C,EAgH76Cb,CAhHs6C;AAgHp6C;;AAAA,IAAIA,CAAC,GAACc,MAAM,CAACC,MAAP,CAAc;AAACC,EAAAA,SAAS,EAAC,IAAX;AAAgBC,EAAAA,KAAK,EAAClB;AAAtB,CAAd,CAAN;AAA8C,SAAOC,CAAC,IAAIkB,CAAZ,EAAcnB,CAAC,IAAIoB,CAAnB","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{Slice as e}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{ReadLinearDepth as i}from\"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";import{multipassTerrainTest as o}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";import{glsl as s}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as n}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{AdjustProjectedPosition as t}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/AdjustProjectedPosition.glsl.js\";import{DiscardByCoverage as d}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardByCoverage.glsl.js\";import{DiscardNonSilhouetteEdges as a}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardNonSilhouetteEdges.glsl.js\";import{DiscardShortEdges as l}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardShortEdges.glsl.js\";import{EdgeUtil as r}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/EdgeUtil.glsl.js\";import{LineAmplitude as c}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/LineAmplitude.glsl.js\";import{LineOffset as P}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/LineOffset.glsl.js\";import{UnpackAttributes as u}from\"../views/3d/webgl-engine/shaders/sources/edgeRenderer/UnpackAttributes.glsl.js\";function p(p){const v=new n,g=v.vertex,f=v.fragment;return p.legacy&&g.uniforms.add(\"uModel\",\"mat4\"),p.antialiasing&&(g.code.add(s`#define ANTIALIASING 1`),f.code.add(s`#define ANTIALIASING 1`)),v.include(t,p),v.include(c,p),v.include(r,p),v.include(u,p),v.include(P,p),v.include(e,p),v.include(a,p),v.include(d,p),v.include(l,p),v.varyings.add(\"vColor\",\"vec4\"),v.varyings.add(\"vRadius\",\"float\"),v.varyings.add(\"vPosition\",\"vec3\"),v.varyings.add(\"vWorldPosition\",\"vec3\"),v.varyings.add(\"vViewPos\",\"vec3\"),v.varyings.add(\"vLineLengthPixels\",\"float\"),v.varyings.add(\"vSizeFalloffFactor\",\"float\"),g.uniforms.add(\"uPixelToNDC\",\"vec2\"),g.uniforms.add(\"uNDCToPixel\",\"vec2\"),g.uniforms.add(\"uPixelRatio\",\"float\"),v.attributes.add(\"position0\",\"vec3\"),v.attributes.add(\"position1\",\"vec3\"),v.attributes.add(\"variantOffset\",\"float\"),v.attributes.add(\"variantStroke\",\"float\"),v.attributes.add(\"variantExtension\",\"float\"),g.code.add(s`const float opaqueCutoff = 1.0 / 255.0;\nvoid calculateGeometricOutputs(vec3 viewPosV0, vec3 viewPosV1, vec3 worldPosV0, vec3 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\nvec2 sideness = unpackedAttributes.sideness;\nvec2 sidenessNorm = unpackedAttributes.sidenessNorm;\nvWorldPosition = mix(worldPosV0, worldPosV1, sidenessNorm.y).xyz;\nvec3 viewPos = mix(viewPosV0, viewPosV1, sidenessNorm.y);\nvViewPos = viewPos;\nvec4 projPosV0 = projFromViewPosition(viewPosV0);\nvec4 projPosV1 = projFromViewPosition(viewPosV1);\nvec4 projPos = projFromViewPosition(viewPos);\nvec3 screenSpaceLineNDC = (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);\nvec2 screenSpaceLinePixels = screenSpaceLineNDC.xy * uNDCToPixel;\nfloat lineLengthPixels = length(screenSpaceLinePixels);\nfloat dzPerPixel = screenSpaceLineNDC.z / lineLengthPixels;\nvec2 screenSpaceDirection = screenSpaceLinePixels / lineLengthPixels;\nvec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;\nfloat falloffFactor = distanceBasedPerspectiveFactor(-viewPos.z) * uPixelRatio;\nfloat lineWidthPixels = unpackedAttributes.lineWidthPixels * falloffFactor;\nfloat extensionLengthPixels = calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;\nfloat lineAmplitudePixels = calculateLineAmplitude(unpackedAttributes) * uPixelRatio;\nvSizeFalloffFactor = falloffFactor;\nfloat lineWidthAndAmplitudePixels = lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;\nfloat extendedLineLengthPixels = lineLengthPixels + extensionLengthPixels + extensionLengthPixels;\n#ifdef ANTIALIASING\nconst float aaPaddingPixels = 1.0;\nfloat halfAAPaddedLineWidthAndAmplitudePixels = lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;\nfloat aaPaddedRoundedCapSizePixels = lineWidthPixels * 0.5 + aaPaddingPixels;\n#else\nfloat halfAAPaddedLineWidthAndAmplitudePixels = max(lineWidthAndAmplitudePixels, 1.0) * 0.5;\nfloat aaPaddedRoundedCapSizePixels = max(lineWidthPixels, 1.0) * 0.5;\n#endif\nvec2 halfAAPaddedLineWidthAndAmplitudeNDC = halfAAPaddedLineWidthAndAmplitudePixels * uPixelToNDC;\nvec2 aaPaddedRoundedCapSizeNDC = aaPaddedRoundedCapSizePixels * uPixelToNDC;\nvec2 extensionLengthNDC = extensionLengthPixels * uPixelToNDC;\nvec2 ndcOffset = (\nscreenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)\n+ perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC\n);\nprojPos.xy += ndcOffset * projPos.w;\nprojPos.z += (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;\nprojPos = adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));\nfloat aaPaddedLineWithCapsLengthPixels = extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;\nfloat pixelPositionAlongLine = aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;\nvPosition = vec3(\nhalfAAPaddedLineWidthAndAmplitudePixels * sideness.x,\npixelPositionAlongLine,\npixelPositionAlongLine / extendedLineLengthPixels\n);\nvRadius = lineWidthPixels * 0.5;\nvLineLengthPixels = extendedLineLengthPixels;\ndiscardShortEdges(unpackedAttributes, lineLengthPixels);\ngl_Position = projPos;\n}\nvoid main() {\nComponentData component = readComponentData();\nUnpackedAttributes unpackedAttributes = unpackAttributes(component);\nvec3 worldPosV0 = worldFromModelPosition(position0);\nvec3 worldPosV1 = worldFromModelPosition(position1);\nvec3 viewPosV0 = viewFromModelPosition(position0);\nvec3 viewPosV1 = viewFromModelPosition(position1);\nvColor = component.color;\nif (vColor.a < opaqueCutoff) {\ngl_Position = vec4(10.0, 10.0, 10.0, 1.0);\nreturn;\n}\nif (discardNonSilhouetteEdges(viewPosV0, worldPosV0)) {\nreturn;\n}\ncalculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal(), unpackedAttributes);\ncalculateStyleOutputs(unpackedAttributes);\n}`),p.multipassTerrainEnabled&&(v.fragment.include(i),v.include(o,p)),v.fragment.code.add(s`\n    vec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {\n      float lineOffset = calculateLineOffset();\n      float positionX = position.x - lineOffset;\n\n      if (radius < 1.0) {\n        // Handle this specifically for subpixel sizes:\n        // 1. Compute correct coverage (note coverage is computed by\n        //    0.5 - dist, so we make sure that that will lead to correct\n        //    subpixel coverage\n        // 2. Ignore rounded caps\n        float coverageX = clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);\n        float coverageY = clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);\n\n        float coverage = min(coverageX, coverageY);\n\n        return vec2(0.5 - coverage, 0.0);\n      }\n      else {\n        // Between -radius -> 0 for start cap, 0 for line, 0 -> radius\n        float positionOnCap = position.y - clamp(position.y, 0.0, lineLength);\n\n        vec2 lineToPosition = vec2(positionX, positionOnCap);\n        return vec2(length(lineToPosition) - radius, positionOnCap / radius);\n      }\n    }\n\n    void main() {\n      ${p.multipassTerrainEnabled?\"terrainDepthTest(gl_FragCoord, vViewPos.z);\":\"\"}\n      float radius = vRadius * calculateLinePressure();\n\n      vec2 distance = lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);\n      float coverage = clamp(0.5 - distance.x, 0.0, 1.0);\n\n      discardByCoverage(radius, coverage);\n      discardBySlice(vWorldPosition);\n\n      float alpha = vColor.a * coverage;\n\n      gl_FragColor = vec4(vColor.rgb, alpha);\n\n    }\n  `),v}var v=Object.freeze({__proto__:null,build:p});export{v as E,p as b};\n"]},"metadata":{},"sourceType":"module"}