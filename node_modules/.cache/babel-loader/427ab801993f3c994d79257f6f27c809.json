{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { Slice as e } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { Transform as t } from \"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";\nimport { VertexColor as a } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";\nimport { OutputDepth as o } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";\nimport { OutputHighlight as r } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";\nimport { ReadLinearDepth as i } from \"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";\nimport { multipassTerrainTest as n } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";\nimport { symbolAlphaCutoff as l } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js\";\nimport { ColorConversion as c } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { glsl as d } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as s } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nconst p = .70710678118,\n      v = p,\n      u = .08715574274;\n\nfunction m(m) {\n  const f = new s();\n  m.draped || f.extensions.add(\"GL_OES_standard_derivatives\");\n  const h = 1 === m.output;\n  f.include(t, {\n    linearDepth: h\n  }), f.include(a, m), f.vertex.uniforms.add(\"proj\", \"mat4\"), f.vertex.uniforms.add(\"view\", \"mat4\"), h && (f.include(o, m), f.vertex.uniforms.add(\"cameraNearFar\", \"vec2\"), f.varyings.add(\"linearDepth\", \"float\")), m.draped ? f.vertex.uniforms.add(\"worldToScreenRatio\", \"float\") : (f.vertex.uniforms.add(\"worldToScreenPerDistanceRatio\", \"float\"), f.vertex.uniforms.add(\"camPos\", \"vec3\"), f.attributes.add(\"boundingRect\", \"mat3\")), f.attributes.add(\"position\", \"vec3\"), f.attributes.add(\"uvMapSpace\", \"vec4\"), f.varyings.add(\"vpos\", \"vec3\"), f.varyings.add(\"vuv\", \"vec2\"), m.multipassTerrainEnabled && f.varyings.add(\"depth\", \"float\");\n  const w = 3 === m.style || 4 === m.style || 5 === m.style;\n  return w && f.vertex.code.add(d`\n      const mat2 rotate45 = mat2(${d.float(p)}, ${d.float(-v)},\n                                 ${d.float(v)}, ${d.float(p)});\n    `), m.draped || (f.vertex.code.add(d`vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {\nfloat projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);\nreturn center + halfVector * clamp(projectedLength, -1.0, 1.0);\n}`), f.vertex.code.add(d`vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {\nfloat d = dot(planeNormal, planePoint);\nfloat t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);\nreturn rayOrigin + t * rayDir;\n}`), f.vertex.code.add(d`\n      float boundingRectDistanceToCamera() {\n        vec3 center = vec3(boundingRect[0][0], boundingRect[0][1], boundingRect[0][2]);\n        vec3 halfU = vec3(boundingRect[1][0], boundingRect[1][1], boundingRect[1][2]);\n        vec3 halfV = vec3(boundingRect[2][0], boundingRect[2][1], boundingRect[2][2]);\n        vec3 n = normalize(cross(halfU, halfV));\n\n        vec3 viewDir = - vec3(view[0][2], view[1][2], view[2][2]);\n\n        float viewAngle = dot(viewDir, n);\n        float minViewAngle = ${d.float(u)};\n\n        if (abs(viewAngle) < minViewAngle) {\n          // view direction is (almost) parallel to plane -> clamp it to min angle\n          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;\n          viewDir = normalize(viewDir + normalComponent * n);\n        }\n\n        // intersect view direction with infinite plane that contains bounding rect\n        vec3 planeProjected = intersectRayPlane(viewDir, camPos, n, center);\n\n        // clip to bounds by projecting to u and v line segments individually\n        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);\n        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);\n\n        // use to calculate the closest point to camera on bounding rect\n        vec3 closestPoint = uProjected + vProjected - center;\n\n        return length(closestPoint - camPos);\n      }\n    `)), f.vertex.code.add(d`\n    vec2 scaledUV() {\n      vec2 uv = uvMapSpace.xy ${w ? \" * rotate45\" : \"\"};\n      vec2 uvCellOrigin = uvMapSpace.zw ${w ? \" * rotate45\" : \"\"};\n\n      ${m.draped ? d`\n            float ratio = worldToScreenRatio;\n          ` : d`\n            float distanceToCamera = boundingRectDistanceToCamera();\n            float ratio = worldToScreenPerDistanceRatio / distanceToCamera;\n\n            // Logarithmically discretize ratio to avoid jittering\n            float step = 0.1;\n            ratio = log(ratio);\n            ratio = ceil(ratio / step) * step;\n            ratio = exp(ratio);\n          `}\n\n      vec2 uvOffset = mod(uvCellOrigin * ratio, ${d.float(m.patternSpacing)});\n      return uvOffset + (uv * ratio);\n    }\n  `), f.vertex.code.add(d`\n    void main(void) {\n      vuv = scaledUV();\n      vpos = position;\n      ${m.multipassTerrainEnabled ? \"depth = (view * vec4(vpos, 1.0)).z;\" : \"\"}\n      forwardNormalizedVertexColor();\n      gl_Position = ${h ? d`transformPositionWithDepth(proj, view, vpos, cameraNearFar, linearDepth);` : d`transformPosition(proj, view, vpos);`}\n    }\n  `), f.include(e, m), f.fragment.include(c), f.fragment.uniforms.add(\"matColor\", \"vec4\"), m.draped && f.fragment.uniforms.add(\"texelSize\", \"float\"), 4 === m.output && f.include(r), m.multipassTerrainEnabled && (f.fragment.include(i), f.include(n, m)), 4 !== m.output && (f.fragment.code.add(d`\n      const float lineWidth = ${d.float(m.lineWidth)};\n      const float spacing = ${d.float(m.patternSpacing)};\n      const float spacingINV = ${d.float(1 / m.patternSpacing)};\n\n      float coverage(float p, float txlSize) {\n        p = mod(p, spacing);\n\n        float halfTxlSize = txlSize / 2.0;\n\n        float start = p - halfTxlSize;\n        float end = p + halfTxlSize;\n\n        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;\n        coverage -= min(lineWidth, mod(start, spacing));\n        coverage -= max(lineWidth - mod(end, spacing), 0.0);\n\n        return coverage / txlSize;\n      }\n    `), m.draped || f.fragment.code.add(d`const int maxSamples = 5;\nfloat sample(float p) {\nvec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));\nfloat fwidth = dxdy.x + dxdy.y;\nivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));\nvec2 invSamples = 1.0 / vec2(samples);\nfloat accumulator = 0.0;\nfor (int j = 0; j < maxSamples; j++) {\nif(j >= samples.y) {\nbreak;\n}\nfor (int i = 0; i < maxSamples; i++) {\nif(i >= samples.x) {\nbreak;\n}\nvec2 step = vec2(i,j) * invSamples - 0.5;\naccumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);\n}\n}\naccumulator /= float(samples.x * samples.y);\nreturn accumulator;\n}`)), f.fragment.code.add(d`\n    void main() {\n      discardBySlice(vpos);\n      ${m.multipassTerrainEnabled ? \"terrainDepthTest(gl_FragCoord, depth);\" : \"\"}\n      vec4 color = ${m.attributeColor ? \"vColor * matColor;\" : \"matColor;\"}\n      color = highlightSlice(color, vpos);\n\n      ${4 !== m.output ? d`color.a *= ${g(m)};` : \"\"}\n\n      if (color.a < ${d.float(l)}) {\n        discard;\n      }\n\n      ${7 === m.output ? d`gl_FragColor = vec4(color.a);` : \"\"}\n\n      ${0 === m.output ? d`gl_FragColor = color; ${m.OITEnabled ? \"gl_FragColor = premultiplyAlpha(gl_FragColor);\" : \"\"}` : \"\"}\n      ${4 === m.output ? d`outputHighlight();` : \"\"}\n      ${1 === m.output ? d`outputDepth(linearDepth);` : \"\"};\n    }\n  `), f;\n}\n\nfunction g(e) {\n  function t(t) {\n    return e.draped ? d`coverage(vuv.${t}, texelSize)` : d`sample(vuv.${t})`;\n  }\n\n  switch (e.style) {\n    case 3:\n    case 0:\n      return t(\"y\");\n\n    case 4:\n    case 1:\n      return t(\"x\");\n\n    case 5:\n    case 2:\n      return d`\n        1.0 - (1.0 - ${t(\"x\")}) * (1.0 - ${t(\"y\")})\n      `;\n\n    default:\n      return \"0.0\";\n  }\n}\n\nvar f = Object.freeze({\n  __proto__: null,\n  build: m\n});\nexport { f as P, m as b };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgis-api-react/node_modules/@arcgis/core/chunks/Pattern.glsl.js"],"names":["Slice","e","Transform","t","VertexColor","a","OutputDepth","o","OutputHighlight","r","ReadLinearDepth","i","multipassTerrainTest","n","symbolAlphaCutoff","l","ColorConversion","c","glsl","d","ShaderBuilder","s","p","v","u","m","f","draped","extensions","add","h","output","include","linearDepth","vertex","uniforms","varyings","attributes","multipassTerrainEnabled","w","style","code","float","patternSpacing","fragment","lineWidth","attributeColor","g","OITEnabled","Object","freeze","__proto__","build","P","b"],"mappings":"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","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{Slice as e}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{Transform as t}from\"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";import{VertexColor as a}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";import{OutputDepth as o}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{OutputHighlight as r}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";import{ReadLinearDepth as i}from\"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";import{multipassTerrainTest as n}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";import{symbolAlphaCutoff as l}from\"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js\";import{ColorConversion as c}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{glsl as d}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as s}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";const p=.70710678118,v=p,u=.08715574274;function m(m){const f=new s;m.draped||f.extensions.add(\"GL_OES_standard_derivatives\");const h=1===m.output;f.include(t,{linearDepth:h}),f.include(a,m),f.vertex.uniforms.add(\"proj\",\"mat4\"),f.vertex.uniforms.add(\"view\",\"mat4\"),h&&(f.include(o,m),f.vertex.uniforms.add(\"cameraNearFar\",\"vec2\"),f.varyings.add(\"linearDepth\",\"float\")),m.draped?f.vertex.uniforms.add(\"worldToScreenRatio\",\"float\"):(f.vertex.uniforms.add(\"worldToScreenPerDistanceRatio\",\"float\"),f.vertex.uniforms.add(\"camPos\",\"vec3\"),f.attributes.add(\"boundingRect\",\"mat3\")),f.attributes.add(\"position\",\"vec3\"),f.attributes.add(\"uvMapSpace\",\"vec4\"),f.varyings.add(\"vpos\",\"vec3\"),f.varyings.add(\"vuv\",\"vec2\"),m.multipassTerrainEnabled&&f.varyings.add(\"depth\",\"float\");const w=3===m.style||4===m.style||5===m.style;return w&&f.vertex.code.add(d`\n      const mat2 rotate45 = mat2(${d.float(p)}, ${d.float(-v)},\n                                 ${d.float(v)}, ${d.float(p)});\n    `),m.draped||(f.vertex.code.add(d`vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {\nfloat projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);\nreturn center + halfVector * clamp(projectedLength, -1.0, 1.0);\n}`),f.vertex.code.add(d`vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {\nfloat d = dot(planeNormal, planePoint);\nfloat t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);\nreturn rayOrigin + t * rayDir;\n}`),f.vertex.code.add(d`\n      float boundingRectDistanceToCamera() {\n        vec3 center = vec3(boundingRect[0][0], boundingRect[0][1], boundingRect[0][2]);\n        vec3 halfU = vec3(boundingRect[1][0], boundingRect[1][1], boundingRect[1][2]);\n        vec3 halfV = vec3(boundingRect[2][0], boundingRect[2][1], boundingRect[2][2]);\n        vec3 n = normalize(cross(halfU, halfV));\n\n        vec3 viewDir = - vec3(view[0][2], view[1][2], view[2][2]);\n\n        float viewAngle = dot(viewDir, n);\n        float minViewAngle = ${d.float(u)};\n\n        if (abs(viewAngle) < minViewAngle) {\n          // view direction is (almost) parallel to plane -> clamp it to min angle\n          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;\n          viewDir = normalize(viewDir + normalComponent * n);\n        }\n\n        // intersect view direction with infinite plane that contains bounding rect\n        vec3 planeProjected = intersectRayPlane(viewDir, camPos, n, center);\n\n        // clip to bounds by projecting to u and v line segments individually\n        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);\n        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);\n\n        // use to calculate the closest point to camera on bounding rect\n        vec3 closestPoint = uProjected + vProjected - center;\n\n        return length(closestPoint - camPos);\n      }\n    `)),f.vertex.code.add(d`\n    vec2 scaledUV() {\n      vec2 uv = uvMapSpace.xy ${w?\" * rotate45\":\"\"};\n      vec2 uvCellOrigin = uvMapSpace.zw ${w?\" * rotate45\":\"\"};\n\n      ${m.draped?d`\n            float ratio = worldToScreenRatio;\n          `:d`\n            float distanceToCamera = boundingRectDistanceToCamera();\n            float ratio = worldToScreenPerDistanceRatio / distanceToCamera;\n\n            // Logarithmically discretize ratio to avoid jittering\n            float step = 0.1;\n            ratio = log(ratio);\n            ratio = ceil(ratio / step) * step;\n            ratio = exp(ratio);\n          `}\n\n      vec2 uvOffset = mod(uvCellOrigin * ratio, ${d.float(m.patternSpacing)});\n      return uvOffset + (uv * ratio);\n    }\n  `),f.vertex.code.add(d`\n    void main(void) {\n      vuv = scaledUV();\n      vpos = position;\n      ${m.multipassTerrainEnabled?\"depth = (view * vec4(vpos, 1.0)).z;\":\"\"}\n      forwardNormalizedVertexColor();\n      gl_Position = ${h?d`transformPositionWithDepth(proj, view, vpos, cameraNearFar, linearDepth);`:d`transformPosition(proj, view, vpos);`}\n    }\n  `),f.include(e,m),f.fragment.include(c),f.fragment.uniforms.add(\"matColor\",\"vec4\"),m.draped&&f.fragment.uniforms.add(\"texelSize\",\"float\"),4===m.output&&f.include(r),m.multipassTerrainEnabled&&(f.fragment.include(i),f.include(n,m)),4!==m.output&&(f.fragment.code.add(d`\n      const float lineWidth = ${d.float(m.lineWidth)};\n      const float spacing = ${d.float(m.patternSpacing)};\n      const float spacingINV = ${d.float(1/m.patternSpacing)};\n\n      float coverage(float p, float txlSize) {\n        p = mod(p, spacing);\n\n        float halfTxlSize = txlSize / 2.0;\n\n        float start = p - halfTxlSize;\n        float end = p + halfTxlSize;\n\n        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;\n        coverage -= min(lineWidth, mod(start, spacing));\n        coverage -= max(lineWidth - mod(end, spacing), 0.0);\n\n        return coverage / txlSize;\n      }\n    `),m.draped||f.fragment.code.add(d`const int maxSamples = 5;\nfloat sample(float p) {\nvec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));\nfloat fwidth = dxdy.x + dxdy.y;\nivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));\nvec2 invSamples = 1.0 / vec2(samples);\nfloat accumulator = 0.0;\nfor (int j = 0; j < maxSamples; j++) {\nif(j >= samples.y) {\nbreak;\n}\nfor (int i = 0; i < maxSamples; i++) {\nif(i >= samples.x) {\nbreak;\n}\nvec2 step = vec2(i,j) * invSamples - 0.5;\naccumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);\n}\n}\naccumulator /= float(samples.x * samples.y);\nreturn accumulator;\n}`)),f.fragment.code.add(d`\n    void main() {\n      discardBySlice(vpos);\n      ${m.multipassTerrainEnabled?\"terrainDepthTest(gl_FragCoord, depth);\":\"\"}\n      vec4 color = ${m.attributeColor?\"vColor * matColor;\":\"matColor;\"}\n      color = highlightSlice(color, vpos);\n\n      ${4!==m.output?d`color.a *= ${g(m)};`:\"\"}\n\n      if (color.a < ${d.float(l)}) {\n        discard;\n      }\n\n      ${7===m.output?d`gl_FragColor = vec4(color.a);`:\"\"}\n\n      ${0===m.output?d`gl_FragColor = color; ${m.OITEnabled?\"gl_FragColor = premultiplyAlpha(gl_FragColor);\":\"\"}`:\"\"}\n      ${4===m.output?d`outputHighlight();`:\"\"}\n      ${1===m.output?d`outputDepth(linearDepth);`:\"\"};\n    }\n  `),f}function g(e){function t(t){return e.draped?d`coverage(vuv.${t}, texelSize)`:d`sample(vuv.${t})`}switch(e.style){case 3:case 0:return t(\"y\");case 4:case 1:return t(\"x\");case 5:case 2:return d`\n        1.0 - (1.0 - ${t(\"x\")}) * (1.0 - ${t(\"y\")})\n      `;default:return\"0.0\"}}var f=Object.freeze({__proto__:null,build:m});export{f as P,m as b};\n"]},"metadata":{},"sourceType":"module"}