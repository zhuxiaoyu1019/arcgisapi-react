{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { glsl as e } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as o } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\n\nfunction t(t) {\n  const r = new o();\n  return 0 === t.output && (r.attributes.add(\"position\", \"vec2\"), r.vertex.uniforms.add(\"uResolution\", \"vec4\"), r.varyings.add(\"fTexCoord\", \"vec2\"), r.varyings.add(\"fOffset[3]\", \"vec4\"), r.vertex.code.add(e`void SMAAEdgeDetectionVS( vec2 texcoord ) {\nfOffset[0] = texcoord.xyxy + uResolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );\nfOffset[1] = texcoord.xyxy + uResolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );\nfOffset[2] = texcoord.xyxy + uResolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );\n}\nvoid main() {\nfTexCoord = (position + 1.0 ) * 0.5;\ngl_Position = vec4(position, 0, 1);\nSMAAEdgeDetectionVS( fTexCoord );\n}`), r.fragment.uniforms.add(\"tColor\", \"sampler2D\"), r.fragment.code.add(e`\n      vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n        vec2 threshold = vec2( ${e.float(t.threshold)} );\n\n        // Calculate color deltas:\n        vec4 delta;\n        vec3 C = texture2D( colorTex, texcoord ).rgb;\n\n        vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n        vec3 t = abs( C - Cleft );\n        delta.x = max( max( t.r, t.g ), t.b );\n\n        vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n        t = abs( C - Ctop );\n        delta.y = max( max( t.r, t.g ), t.b );\n\n        // We do the usual threshold:\n        vec2 edges = step( threshold, delta.xy );\n\n        // Then discard if there is no edge:\n        if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n            discard;\n\n        // Calculate right and bottom deltas:\n        vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n        t = abs( C - Cright );\n        delta.z = max( max( t.r, t.g ), t.b );\n\n        vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n        t = abs( C - Cbottom );\n        delta.w = max( max( t.r, t.g ), t.b );\n\n        // Calculate the maximum delta in the direct neighborhood:\n        float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\n        // Calculate left-left and top-top deltas:\n        vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n        t = abs( C - Cleftleft );\n        delta.z = max( max( t.r, t.g ), t.b );\n\n        vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n        t = abs( C - Ctoptop );\n        delta.w = max( max( t.r, t.g ), t.b );\n\n        // Calculate the final maximum delta:\n        maxDelta = max( max( maxDelta, delta.z ), delta.w );\n\n        // Local contrast adaptation in action:\n        edges.xy *= step( maxDelta, float(${e.float(t.localConstrastAdaption)}) * delta.xy );\n\n        return vec4( edges, 0.0, 0.0 );\n      }\n\n      void main() {\n        gl_FragColor = SMAAColorEdgeDetectionPS( fTexCoord, fOffset, tColor );\n      }\n    `)), 1 === t.output && (r.attributes.add(\"position\", \"vec2\"), r.vertex.uniforms.add(\"uResolution\", \"vec4\"), r.varyings.add(\"fTexCoord\", \"vec2\"), r.varyings.add(\"fOffset[3]\", \"vec4\"), r.varyings.add(\"fPixCoord\", \"vec2\"), r.vertex.code.add(e`\n      void SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n        fPixCoord = texcoord * uResolution.zw;\n        fOffset[0] = texcoord.xyxy + uResolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );\n        fOffset[1] = texcoord.xyxy + uResolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );\n        fOffset[2] = vec4( fOffset[0].xz, fOffset[1].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * uResolution.xxyy * float( ${e.int(t.maxSearchSteps)} );\n      }\n\n      void main() {\n        fTexCoord = (position + 1.0 ) * 0.5;\n        gl_Position = vec4(position, 0, 1);\n        SMAABlendingWeightCalculationVS( fTexCoord );\n      }\n    `), r.fragment.uniforms.add(\"tEdges\", \"sampler2D\").add(\"tArea\", \"sampler2D\").add(\"tSearch\", \"sampler2D\").add(\"tColor\", \"sampler2D\").add(\"uResolution\", \"vec4\"), r.fragment.code.add(e`\n      #define SMAA_AREATEX_PIXEL_SIZE ( 1.0 / vec2( 160.0, 560.0 ) )\n      #define SMAA_AREATEX_SUBTEX_SIZE ( 1.0 / 7.0 )\n\n      vec4 SMAASampleLevelZeroOffset(sampler2D tex, vec2 coord, vec2 offset) {\n        return texture2D( tex, coord + offset.x * uResolution.xy, 0.0 );\n      }\n\n      vec2 round( vec2 x ) {\n        return sign( x ) * floor( abs( x ) + 0.5 );\n      }\n\n      float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n        e.r = bias + e.r * scale;\n        return 255.0 * texture2D( searchTex, e, 0.0 ).r;\n      }\n\n      float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 0.0, 1.0 );\n        for ( int i = 0; i < ${e.int(t.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord -= vec2( 2.0, 0.0 ) * uResolution.xy;\n          if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n        }\n        texcoord.x += 0.25 * uResolution.x;\n        texcoord.x += uResolution.x;\n        texcoord.x += 2.0 * uResolution.x;\n        texcoord.x -= uResolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n        return texcoord.x;\n      }\n\n      float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 0.0, 1.0 );\n        for ( int i = 0; i < ${e.int(t.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord += vec2( 2.0, 0.0 ) * uResolution.xy;\n          if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n        }\n        texcoord.x -= 0.25 * uResolution.x;\n        texcoord.x -= uResolution.x;\n        texcoord.x -= 2.0 * uResolution.x;\n        texcoord.x += uResolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n        return texcoord.x;\n      }\n\n      float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 1.0, 0.0 );\n        for ( int i = 0; i < ${e.int(t.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord += vec2( 0.0, 2.0 ) * uResolution.xy;\n          if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n        }\n        texcoord.y -= 0.25 * uResolution.y;\n        texcoord.y -= uResolution.y;\n        texcoord.y -= 2.0 * uResolution.y;\n        texcoord.y += uResolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );\n        return texcoord.y;\n      }\n\n      float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 1.0, 0.0 );\n        for ( int i = 0; i < ${e.int(t.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord -= vec2( 0.0, 2.0 ) * uResolution.xy;\n          if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n        }\n        texcoord.y += 0.25 * uResolution.y;\n        texcoord.y += uResolution.y;\n        texcoord.y += 2.0 * uResolution.y;\n        texcoord.y -= uResolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );\n        return texcoord.y;\n      }\n\n      vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n        vec2 texcoord = float( ${e.int(t.maxDistanceAreaTex)} ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n        texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n        texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n        return texture2D( areaTex, texcoord, 0.0 ).rg;\n      }\n\n      vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n        vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n        vec2 e = texture2D( edgesTex, texcoord ).rg;\n        if ( e.g > 0.0 ) {\n          vec2 d;\n          vec2 coords;\n          coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n          coords.y = offset[ 1 ].y;\n          d.x = coords.x;\n          float e1 = texture2D( edgesTex, coords, 0.0 ).r;\n          coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n          d.y = coords.x;\n          d = d * uResolution.z - pixcoord.x;\n          vec2 sqrt_d = sqrt( abs( d ) );\n          coords.y -= 1.0 * uResolution.y;\n          float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, vec2( 1.0, 0.0 ) ).r;\n          weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n        }\n\n        if ( e.r > 0.0 ) {\n          vec2 d;\n          vec2 coords;\n          coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n          coords.x = offset[ 0 ].x;\n          d.x = coords.y;\n          float e1 = texture2D( edgesTex, coords, 0.0 ).g;\n          coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n          d.y = coords.y;\n          d = d * uResolution.w - pixcoord.y;\n          vec2 sqrt_d = sqrt( abs( d ) );\n          coords.y -= 1.0 * uResolution.y;\n          float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, vec2( 0.0, 1.0 ) ).g;\n          weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n\n          // for some reason the following lines are necessary to prevent\n          // texture lookup precision issues on some Intel integrated graphics chips\n          vec4 dbg = (offset[ 0 ]+offset[ 1 ]+offset[ 2 ] + coords.xyyx);\n          weights.r += 0.00000001 * dot(vec4(0,1,0,1),dbg);\n        }\n        return weights;\n      }\n\n      void main() {\n        gl_FragColor = SMAABlendingWeightCalculationPS( fTexCoord, fPixCoord, fOffset, tEdges, tArea, tSearch, ivec4( 0.0 ) );\n      }\n    `)), 2 === t.output && (r.attributes.add(\"position\", \"vec2\"), r.vertex.uniforms.add(\"uResolution\", \"vec4\"), r.varyings.add(\"fTexCoord\", \"vec2\"), r.varyings.add(\"fOffset[2]\", \"vec4\"), r.vertex.code.add(e`void SMAANeighborhoodBlendingVS( vec2 texcoord ) {\nfOffset[0] = texcoord.xyxy + uResolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );\nfOffset[1] = texcoord.xyxy + uResolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );\n}\nvoid main() {\nfTexCoord = (position + 1.0 ) * 0.5;\ngl_Position = vec4(position, 0, 1);\nSMAANeighborhoodBlendingVS(fTexCoord);\n}`), r.fragment.uniforms.add(\"tBlendWeights\", \"sampler2D\"), r.fragment.uniforms.add(\"tColor\", \"sampler2D\"), r.fragment.uniforms.add(\"uResolution\", \"vec4\"), r.fragment.code.add(e`vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\nvec4 a;\na.xz = texture2D( blendTex, texcoord ).xz;\na.y = texture2D( blendTex, offset[ 1 ].zw ).g;\na.w = texture2D( blendTex, offset[ 1 ].xy ).a;\nif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\nreturn texture2D( colorTex, texcoord, 0.0 );\n} else {\nvec2 offset;\noffset.x = a.a > a.b ? a.a : -a.b;\noffset.y = a.g > a.r ? -a.g : a.r;\nif ( abs( offset.x ) > abs( offset.y )) {\noffset.y = 0.0;\n} else {\noffset.x = 0.0;\n}\nvec4 C = texture2D( colorTex, texcoord, 0.0 );\ntexcoord += sign( offset ) * uResolution.xy;\nvec4 Cop = texture2D( colorTex, texcoord, 0.0 );\nfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\nvec4 mixed = mix(C, Cop, s);\nreturn mixed;\n}\n}\nvoid main() {\ngl_FragColor = SMAANeighborhoodBlendingPS( fTexCoord, fOffset, tColor, tBlendWeights );\n}`)), r;\n}\n\nvar r = Object.freeze({\n  __proto__: null,\n  build: t\n});\nexport { r as S, t as b };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgis-api-react/node_modules/@arcgis/core/chunks/SMAA.glsl.js"],"names":["glsl","e","ShaderBuilder","o","t","r","output","attributes","add","vertex","uniforms","varyings","code","fragment","float","threshold","localConstrastAdaption","int","maxSearchSteps","maxDistanceAreaTex","Object","freeze","__proto__","build","S","b"],"mappings":"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","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{glsl as e}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as o}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";function t(t){const r=new o;return 0===t.output&&(r.attributes.add(\"position\",\"vec2\"),r.vertex.uniforms.add(\"uResolution\",\"vec4\"),r.varyings.add(\"fTexCoord\",\"vec2\"),r.varyings.add(\"fOffset[3]\",\"vec4\"),r.vertex.code.add(e`void SMAAEdgeDetectionVS( vec2 texcoord ) {\nfOffset[0] = texcoord.xyxy + uResolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );\nfOffset[1] = texcoord.xyxy + uResolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );\nfOffset[2] = texcoord.xyxy + uResolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );\n}\nvoid main() {\nfTexCoord = (position + 1.0 ) * 0.5;\ngl_Position = vec4(position, 0, 1);\nSMAAEdgeDetectionVS( fTexCoord );\n}`),r.fragment.uniforms.add(\"tColor\",\"sampler2D\"),r.fragment.code.add(e`\n      vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n        vec2 threshold = vec2( ${e.float(t.threshold)} );\n\n        // Calculate color deltas:\n        vec4 delta;\n        vec3 C = texture2D( colorTex, texcoord ).rgb;\n\n        vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n        vec3 t = abs( C - Cleft );\n        delta.x = max( max( t.r, t.g ), t.b );\n\n        vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n        t = abs( C - Ctop );\n        delta.y = max( max( t.r, t.g ), t.b );\n\n        // We do the usual threshold:\n        vec2 edges = step( threshold, delta.xy );\n\n        // Then discard if there is no edge:\n        if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n            discard;\n\n        // Calculate right and bottom deltas:\n        vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n        t = abs( C - Cright );\n        delta.z = max( max( t.r, t.g ), t.b );\n\n        vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n        t = abs( C - Cbottom );\n        delta.w = max( max( t.r, t.g ), t.b );\n\n        // Calculate the maximum delta in the direct neighborhood:\n        float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\n        // Calculate left-left and top-top deltas:\n        vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n        t = abs( C - Cleftleft );\n        delta.z = max( max( t.r, t.g ), t.b );\n\n        vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n        t = abs( C - Ctoptop );\n        delta.w = max( max( t.r, t.g ), t.b );\n\n        // Calculate the final maximum delta:\n        maxDelta = max( max( maxDelta, delta.z ), delta.w );\n\n        // Local contrast adaptation in action:\n        edges.xy *= step( maxDelta, float(${e.float(t.localConstrastAdaption)}) * delta.xy );\n\n        return vec4( edges, 0.0, 0.0 );\n      }\n\n      void main() {\n        gl_FragColor = SMAAColorEdgeDetectionPS( fTexCoord, fOffset, tColor );\n      }\n    `)),1===t.output&&(r.attributes.add(\"position\",\"vec2\"),r.vertex.uniforms.add(\"uResolution\",\"vec4\"),r.varyings.add(\"fTexCoord\",\"vec2\"),r.varyings.add(\"fOffset[3]\",\"vec4\"),r.varyings.add(\"fPixCoord\",\"vec2\"),r.vertex.code.add(e`\n      void SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n        fPixCoord = texcoord * uResolution.zw;\n        fOffset[0] = texcoord.xyxy + uResolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );\n        fOffset[1] = texcoord.xyxy + uResolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );\n        fOffset[2] = vec4( fOffset[0].xz, fOffset[1].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * uResolution.xxyy * float( ${e.int(t.maxSearchSteps)} );\n      }\n\n      void main() {\n        fTexCoord = (position + 1.0 ) * 0.5;\n        gl_Position = vec4(position, 0, 1);\n        SMAABlendingWeightCalculationVS( fTexCoord );\n      }\n    `),r.fragment.uniforms.add(\"tEdges\",\"sampler2D\").add(\"tArea\",\"sampler2D\").add(\"tSearch\",\"sampler2D\").add(\"tColor\",\"sampler2D\").add(\"uResolution\",\"vec4\"),r.fragment.code.add(e`\n      #define SMAA_AREATEX_PIXEL_SIZE ( 1.0 / vec2( 160.0, 560.0 ) )\n      #define SMAA_AREATEX_SUBTEX_SIZE ( 1.0 / 7.0 )\n\n      vec4 SMAASampleLevelZeroOffset(sampler2D tex, vec2 coord, vec2 offset) {\n        return texture2D( tex, coord + offset.x * uResolution.xy, 0.0 );\n      }\n\n      vec2 round( vec2 x ) {\n        return sign( x ) * floor( abs( x ) + 0.5 );\n      }\n\n      float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n        e.r = bias + e.r * scale;\n        return 255.0 * texture2D( searchTex, e, 0.0 ).r;\n      }\n\n      float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 0.0, 1.0 );\n        for ( int i = 0; i < ${e.int(t.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord -= vec2( 2.0, 0.0 ) * uResolution.xy;\n          if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n        }\n        texcoord.x += 0.25 * uResolution.x;\n        texcoord.x += uResolution.x;\n        texcoord.x += 2.0 * uResolution.x;\n        texcoord.x -= uResolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n        return texcoord.x;\n      }\n\n      float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 0.0, 1.0 );\n        for ( int i = 0; i < ${e.int(t.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord += vec2( 2.0, 0.0 ) * uResolution.xy;\n          if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n        }\n        texcoord.x -= 0.25 * uResolution.x;\n        texcoord.x -= uResolution.x;\n        texcoord.x -= 2.0 * uResolution.x;\n        texcoord.x += uResolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n        return texcoord.x;\n      }\n\n      float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 1.0, 0.0 );\n        for ( int i = 0; i < ${e.int(t.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord += vec2( 0.0, 2.0 ) * uResolution.xy;\n          if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n        }\n        texcoord.y -= 0.25 * uResolution.y;\n        texcoord.y -= uResolution.y;\n        texcoord.y -= 2.0 * uResolution.y;\n        texcoord.y += uResolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );\n        return texcoord.y;\n      }\n\n      float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 1.0, 0.0 );\n        for ( int i = 0; i < ${e.int(t.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord -= vec2( 0.0, 2.0 ) * uResolution.xy;\n          if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n        }\n        texcoord.y += 0.25 * uResolution.y;\n        texcoord.y += uResolution.y;\n        texcoord.y += 2.0 * uResolution.y;\n        texcoord.y -= uResolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );\n        return texcoord.y;\n      }\n\n      vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n        vec2 texcoord = float( ${e.int(t.maxDistanceAreaTex)} ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n        texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n        texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n        return texture2D( areaTex, texcoord, 0.0 ).rg;\n      }\n\n      vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n        vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n        vec2 e = texture2D( edgesTex, texcoord ).rg;\n        if ( e.g > 0.0 ) {\n          vec2 d;\n          vec2 coords;\n          coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n          coords.y = offset[ 1 ].y;\n          d.x = coords.x;\n          float e1 = texture2D( edgesTex, coords, 0.0 ).r;\n          coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n          d.y = coords.x;\n          d = d * uResolution.z - pixcoord.x;\n          vec2 sqrt_d = sqrt( abs( d ) );\n          coords.y -= 1.0 * uResolution.y;\n          float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, vec2( 1.0, 0.0 ) ).r;\n          weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n        }\n\n        if ( e.r > 0.0 ) {\n          vec2 d;\n          vec2 coords;\n          coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n          coords.x = offset[ 0 ].x;\n          d.x = coords.y;\n          float e1 = texture2D( edgesTex, coords, 0.0 ).g;\n          coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n          d.y = coords.y;\n          d = d * uResolution.w - pixcoord.y;\n          vec2 sqrt_d = sqrt( abs( d ) );\n          coords.y -= 1.0 * uResolution.y;\n          float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, vec2( 0.0, 1.0 ) ).g;\n          weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n\n          // for some reason the following lines are necessary to prevent\n          // texture lookup precision issues on some Intel integrated graphics chips\n          vec4 dbg = (offset[ 0 ]+offset[ 1 ]+offset[ 2 ] + coords.xyyx);\n          weights.r += 0.00000001 * dot(vec4(0,1,0,1),dbg);\n        }\n        return weights;\n      }\n\n      void main() {\n        gl_FragColor = SMAABlendingWeightCalculationPS( fTexCoord, fPixCoord, fOffset, tEdges, tArea, tSearch, ivec4( 0.0 ) );\n      }\n    `)),2===t.output&&(r.attributes.add(\"position\",\"vec2\"),r.vertex.uniforms.add(\"uResolution\",\"vec4\"),r.varyings.add(\"fTexCoord\",\"vec2\"),r.varyings.add(\"fOffset[2]\",\"vec4\"),r.vertex.code.add(e`void SMAANeighborhoodBlendingVS( vec2 texcoord ) {\nfOffset[0] = texcoord.xyxy + uResolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );\nfOffset[1] = texcoord.xyxy + uResolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );\n}\nvoid main() {\nfTexCoord = (position + 1.0 ) * 0.5;\ngl_Position = vec4(position, 0, 1);\nSMAANeighborhoodBlendingVS(fTexCoord);\n}`),r.fragment.uniforms.add(\"tBlendWeights\",\"sampler2D\"),r.fragment.uniforms.add(\"tColor\",\"sampler2D\"),r.fragment.uniforms.add(\"uResolution\",\"vec4\"),r.fragment.code.add(e`vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\nvec4 a;\na.xz = texture2D( blendTex, texcoord ).xz;\na.y = texture2D( blendTex, offset[ 1 ].zw ).g;\na.w = texture2D( blendTex, offset[ 1 ].xy ).a;\nif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\nreturn texture2D( colorTex, texcoord, 0.0 );\n} else {\nvec2 offset;\noffset.x = a.a > a.b ? a.a : -a.b;\noffset.y = a.g > a.r ? -a.g : a.r;\nif ( abs( offset.x ) > abs( offset.y )) {\noffset.y = 0.0;\n} else {\noffset.x = 0.0;\n}\nvec4 C = texture2D( colorTex, texcoord, 0.0 );\ntexcoord += sign( offset ) * uResolution.xy;\nvec4 Cop = texture2D( colorTex, texcoord, 0.0 );\nfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\nvec4 mixed = mix(C, Cop, s);\nreturn mixed;\n}\n}\nvoid main() {\ngl_FragColor = SMAANeighborhoodBlendingPS( fTexCoord, fOffset, tColor, tBlendWeights );\n}`)),r}var r=Object.freeze({__proto__:null,build:t});export{r as S,t as b};\n"]},"metadata":{},"sourceType":"module"}