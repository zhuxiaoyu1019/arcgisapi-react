{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { ScreenSizePerspective as e } from \"../util/ScreenSizePerspective.glsl.js\";\nimport { glsl as t } from \"../../shaderModules/interfaces.js\";\n\nfunction o(o, a) {\n  const i = o;\n  i.include(e), i.attributes.add(\"position\", \"vec3\"), i.attributes.add(\"normal\", \"vec3\"), i.attributes.add(\"auxpos1\", \"vec4\"), i.vertex.uniforms.add(\"proj\", \"mat4\"), i.vertex.uniforms.add(\"view\", \"mat4\"), i.vertex.uniforms.add(\"viewNormal\", \"mat4\"), i.vertex.uniforms.add(\"viewport\", \"vec4\"), i.vertex.uniforms.add(\"camPos\", \"vec3\"), i.vertex.uniforms.add(\"polygonOffset\", \"float\"), i.vertex.uniforms.add(\"cameraGroundRelative\", \"float\"), i.vertex.uniforms.add(\"pixelRatio\", \"float\"), i.vertex.uniforms.add(\"perDistancePixelRatio\", \"float\"), i.vertex.uniforms.add(\"uRenderTransparentlyOccludedHUD\", \"float\"), a.verticalOffsetEnabled && i.vertex.uniforms.add(\"verticalOffset\", \"vec4\"), a.screenSizePerspectiveEnabled && i.vertex.uniforms.add(\"screenSizePerspectiveAlignment\", \"vec4\"), i.vertex.uniforms.add(\"hudVisibilityTexture\", \"sampler2D\"), i.vertex.constants.add(\"smallOffsetAngle\", \"float\", .984807753012208), i.vertex.code.add(t`struct ProjectHUDAux {\nvec3 posModel;\nvec3 posView;\nvec3 vnormal;\nfloat distanceToCamera;\nfloat absCosAngle;\n};`), i.vertex.code.add(t`float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\nfloat pointGroundSign = sign(pointGroundDistance);\nif (pointGroundSign == 0.0) {\npointGroundSign = cameraGroundRelative;\n}\nfloat groundRelative = cameraGroundRelative * pointGroundSign;\nif (polygonOffset > .0) {\nfloat cosAlpha = clamp(absCosAngle, 0.01, 1.0);\nfloat tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\nfloat factor = (1.0 - tanAlpha / viewport[2]);\nif (groundRelative > 0.0) {\nposView *= factor;\n}\nelse {\nposView /= factor;\n}\n}\nreturn groundRelative;\n}`), a.isDraped || i.vertex.code.add(t`void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {\nfloat distanceToCamera = length(posView);\nfloat pixelOffset = distanceToCamera * perDistancePixelRatio * 0.5;\nvec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;\nvec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\nposModel += modelOffset;\nposView += viewOffset;\n}`), i.vertex.code.add(t`\n    vec4 projectPositionHUD(out ProjectHUDAux aux) {\n      // centerOffset is in view space and is used to implement world size offsetting\n      // of labels with respect to objects. It also pulls the label towards the viewer\n      // so that the label is visible in front of the object.\n      vec3 centerOffset = auxpos1.xyz;\n\n      // The pointGroundDistance is the distance of the geometry to the ground and is\n      // negative if the point is below the ground, or positive if the point is above\n      // ground.\n      float pointGroundDistance = auxpos1.w;\n\n      aux.posModel = position;\n      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;\n      aux.vnormal = normal;\n      ${a.isDraped ? \"\" : \"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);\"}\n\n      // Screen sized offset in world space, used for example for line callouts\n      // Note: keep this implementation in sync with the CPU implementation, see\n      //   - MaterialUtil.verticalOffsetAtDistance\n      //   - HUDMaterial.applyVerticalOffsetTransformation\n\n      aux.distanceToCamera = length(aux.posView);\n\n      vec3 viewDirObjSpace = normalize(camPos - aux.posModel);\n      float cosAngle = dot(aux.vnormal, viewDirObjSpace);\n\n      aux.absCosAngle = abs(cosAngle);\n\n      ${a.screenSizePerspectiveEnabled && (a.verticalOffsetEnabled || 1 === a.screenCenterOffsetUnitsEnabled) ? \"vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);\" : \"\"}\n\n      ${a.verticalOffsetEnabled ? a.screenSizePerspectiveEnabled ? \"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);\" : \"float verticalOffsetScreenHeight = verticalOffset.x;\" : \"\"}\n\n      ${a.verticalOffsetEnabled ? t`\n            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\n            vec3 modelOffset = aux.vnormal * worldOffset;\n            aux.posModel += modelOffset;\n            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n            aux.posView += viewOffset;\n            // Since we elevate the object, we need to take that into account\n            // in the distance to ground\n            pointGroundDistance += worldOffset;` : \"\"}\n\n      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\n\n      ${1 !== a.screenCenterOffsetUnitsEnabled ? t`\n            // Apply x/y in view space, but z in screen space (i.e. along posView direction)\n            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);\n\n            // Same material all have same z != 0.0 condition so should not lead to\n            // branch fragmentation and will save a normalization if it's not needed\n            if (centerOffset.z != 0.0) {\n              aux.posView -= normalize(aux.posView) * centerOffset.z;\n            }\n          ` : \"\"}\n\n      vec4 posProj = proj * vec4(aux.posView, 1.0);\n\n      ${1 === a.screenCenterOffsetUnitsEnabled ? a.screenSizePerspectiveEnabled ? \"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);\" : \"float centerOffsetY = centerOffset.y;\" : \"\"}\n\n      ${1 === a.screenCenterOffsetUnitsEnabled ? \"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;\" : \"\"}\n\n      // constant part of polygon offset emulation\n      posProj.z -= groundRelative * polygonOffset * posProj.w;\n      return posProj;\n    }\n  `), i.vertex.code.add(t`bool testVisibilityHUD(vec4 posProj) {\nvec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);\nvec4 occlusionPixel = texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);\nif (uRenderTransparentlyOccludedHUD > 0.5) {\nreturn occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * uRenderTransparentlyOccludedHUD < 1.0;\n}\nreturn occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;\n}`);\n}\n\nfunction a(e, t) {\n  e.setUniform1f(\"uRenderTransparentlyOccludedHUD\", 0 === t.renderTransparentlyOccludedHUD ? 1 : 1 === t.renderTransparentlyOccludedHUD ? 0 : .75);\n}\n\nexport { o as HUD, a as bindHUDUniforms };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgis-api-react/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js"],"names":["ScreenSizePerspective","e","glsl","t","o","a","i","include","attributes","add","vertex","uniforms","verticalOffsetEnabled","screenSizePerspectiveEnabled","constants","code","isDraped","screenCenterOffsetUnitsEnabled","setUniform1f","renderTransparentlyOccludedHUD","HUD","bindHUDUniforms"],"mappings":"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","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{ScreenSizePerspective as e}from\"../util/ScreenSizePerspective.glsl.js\";import{glsl as t}from\"../../shaderModules/interfaces.js\";function o(o,a){const i=o;i.include(e),i.attributes.add(\"position\",\"vec3\"),i.attributes.add(\"normal\",\"vec3\"),i.attributes.add(\"auxpos1\",\"vec4\"),i.vertex.uniforms.add(\"proj\",\"mat4\"),i.vertex.uniforms.add(\"view\",\"mat4\"),i.vertex.uniforms.add(\"viewNormal\",\"mat4\"),i.vertex.uniforms.add(\"viewport\",\"vec4\"),i.vertex.uniforms.add(\"camPos\",\"vec3\"),i.vertex.uniforms.add(\"polygonOffset\",\"float\"),i.vertex.uniforms.add(\"cameraGroundRelative\",\"float\"),i.vertex.uniforms.add(\"pixelRatio\",\"float\"),i.vertex.uniforms.add(\"perDistancePixelRatio\",\"float\"),i.vertex.uniforms.add(\"uRenderTransparentlyOccludedHUD\",\"float\"),a.verticalOffsetEnabled&&i.vertex.uniforms.add(\"verticalOffset\",\"vec4\"),a.screenSizePerspectiveEnabled&&i.vertex.uniforms.add(\"screenSizePerspectiveAlignment\",\"vec4\"),i.vertex.uniforms.add(\"hudVisibilityTexture\",\"sampler2D\"),i.vertex.constants.add(\"smallOffsetAngle\",\"float\",.984807753012208),i.vertex.code.add(t`struct ProjectHUDAux {\nvec3 posModel;\nvec3 posView;\nvec3 vnormal;\nfloat distanceToCamera;\nfloat absCosAngle;\n};`),i.vertex.code.add(t`float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\nfloat pointGroundSign = sign(pointGroundDistance);\nif (pointGroundSign == 0.0) {\npointGroundSign = cameraGroundRelative;\n}\nfloat groundRelative = cameraGroundRelative * pointGroundSign;\nif (polygonOffset > .0) {\nfloat cosAlpha = clamp(absCosAngle, 0.01, 1.0);\nfloat tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\nfloat factor = (1.0 - tanAlpha / viewport[2]);\nif (groundRelative > 0.0) {\nposView *= factor;\n}\nelse {\nposView /= factor;\n}\n}\nreturn groundRelative;\n}`),a.isDraped||i.vertex.code.add(t`void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {\nfloat distanceToCamera = length(posView);\nfloat pixelOffset = distanceToCamera * perDistancePixelRatio * 0.5;\nvec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;\nvec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\nposModel += modelOffset;\nposView += viewOffset;\n}`),i.vertex.code.add(t`\n    vec4 projectPositionHUD(out ProjectHUDAux aux) {\n      // centerOffset is in view space and is used to implement world size offsetting\n      // of labels with respect to objects. It also pulls the label towards the viewer\n      // so that the label is visible in front of the object.\n      vec3 centerOffset = auxpos1.xyz;\n\n      // The pointGroundDistance is the distance of the geometry to the ground and is\n      // negative if the point is below the ground, or positive if the point is above\n      // ground.\n      float pointGroundDistance = auxpos1.w;\n\n      aux.posModel = position;\n      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;\n      aux.vnormal = normal;\n      ${a.isDraped?\"\":\"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);\"}\n\n      // Screen sized offset in world space, used for example for line callouts\n      // Note: keep this implementation in sync with the CPU implementation, see\n      //   - MaterialUtil.verticalOffsetAtDistance\n      //   - HUDMaterial.applyVerticalOffsetTransformation\n\n      aux.distanceToCamera = length(aux.posView);\n\n      vec3 viewDirObjSpace = normalize(camPos - aux.posModel);\n      float cosAngle = dot(aux.vnormal, viewDirObjSpace);\n\n      aux.absCosAngle = abs(cosAngle);\n\n      ${a.screenSizePerspectiveEnabled&&(a.verticalOffsetEnabled||1===a.screenCenterOffsetUnitsEnabled)?\"vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);\":\"\"}\n\n      ${a.verticalOffsetEnabled?a.screenSizePerspectiveEnabled?\"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);\":\"float verticalOffsetScreenHeight = verticalOffset.x;\":\"\"}\n\n      ${a.verticalOffsetEnabled?t`\n            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\n            vec3 modelOffset = aux.vnormal * worldOffset;\n            aux.posModel += modelOffset;\n            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n            aux.posView += viewOffset;\n            // Since we elevate the object, we need to take that into account\n            // in the distance to ground\n            pointGroundDistance += worldOffset;`:\"\"}\n\n      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\n\n      ${1!==a.screenCenterOffsetUnitsEnabled?t`\n            // Apply x/y in view space, but z in screen space (i.e. along posView direction)\n            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);\n\n            // Same material all have same z != 0.0 condition so should not lead to\n            // branch fragmentation and will save a normalization if it's not needed\n            if (centerOffset.z != 0.0) {\n              aux.posView -= normalize(aux.posView) * centerOffset.z;\n            }\n          `:\"\"}\n\n      vec4 posProj = proj * vec4(aux.posView, 1.0);\n\n      ${1===a.screenCenterOffsetUnitsEnabled?a.screenSizePerspectiveEnabled?\"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);\":\"float centerOffsetY = centerOffset.y;\":\"\"}\n\n      ${1===a.screenCenterOffsetUnitsEnabled?\"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;\":\"\"}\n\n      // constant part of polygon offset emulation\n      posProj.z -= groundRelative * polygonOffset * posProj.w;\n      return posProj;\n    }\n  `),i.vertex.code.add(t`bool testVisibilityHUD(vec4 posProj) {\nvec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);\nvec4 occlusionPixel = texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);\nif (uRenderTransparentlyOccludedHUD > 0.5) {\nreturn occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * uRenderTransparentlyOccludedHUD < 1.0;\n}\nreturn occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;\n}`)}function a(e,t){e.setUniform1f(\"uRenderTransparentlyOccludedHUD\",0===t.renderTransparentlyOccludedHUD?1:1===t.renderTransparentlyOccludedHUD?0:.75)}export{o as HUD,a as bindHUDUniforms};\n"]},"metadata":{},"sourceType":"module"}