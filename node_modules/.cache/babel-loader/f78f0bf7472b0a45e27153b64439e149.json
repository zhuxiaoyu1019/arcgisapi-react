{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { VertexTextureCoordinates as e } from \"../attributes/VertexTextureCoordinates.glsl.js\";\nimport { glsl as t } from \"../../shaderModules/interfaces.js\";\n\nfunction n(n, a) {\n  const r = n.fragment;\n  a.vertexTangents ? (n.attributes.add(\"tangent\", \"vec4\"), n.varyings.add(\"vTangent\", \"vec4\"), 2 === a.doubleSidedMode ? r.code.add(t`mat3 computeTangentSpace(vec3 normal) {\nfloat tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;\nvec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);\nvec3 bitangent = cross(normal, tangent) * tangentHeadedness;\nreturn mat3(tangent, bitangent, normal);\n}`) : r.code.add(t`mat3 computeTangentSpace(vec3 normal) {\nfloat tangentHeadedness = vTangent.w;\nvec3 tangent = normalize(vTangent.xyz);\nvec3 bitangent = cross(normal, tangent) * tangentHeadedness;\nreturn mat3(tangent, bitangent, normal);\n}`)) : (n.extensions.add(\"GL_OES_standard_derivatives\"), r.code.add(t`mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {\nvec3 Q1 = dFdx(pos);\nvec3 Q2 = dFdy(pos);\nvec2 stx = dFdx(st);\nvec2 sty = dFdy(st);\nfloat det = stx.t * sty.s - sty.t * stx.s;\nvec3 T = stx.t * Q2 - sty.t * Q1;\nT = T - normal * dot(normal, T);\nT *= inversesqrt(max(dot(T,T), 1.e-10));\nvec3 B = sign(det) * cross(normal, T);\nreturn mat3(T, B, normal);\n}`)), 0 !== a.attributeTextureCoordinates && (n.include(e, a), r.uniforms.add(\"normalTexture\", \"sampler2D\"), r.uniforms.add(\"normalTextureSize\", \"vec2\"), r.code.add(t`\n    vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {\n      vtc.uv = uv;\n      ${a.supportsTextureAtlas ? \"vtc.size = normalTextureSize;\" : \"\"}\n      vec3 rawNormal = textureLookup(normalTexture, vtc).rgb * 2.0 - 1.0;\n      return tangentSpace * rawNormal;\n    }\n  `));\n}\n\nexport { n as ComputeNormalTexture };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgis-api-react/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js"],"names":["VertexTextureCoordinates","e","glsl","t","n","a","r","fragment","vertexTangents","attributes","add","varyings","doubleSidedMode","code","extensions","attributeTextureCoordinates","include","uniforms","supportsTextureAtlas","ComputeNormalTexture"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,wBAAwB,IAAIC,CAAnC,QAAyC,gDAAzC;AAA0F,SAAOC,IAAI,IAAIC,CAAf,QAAqB,mCAArB;;AAAyD,SAASC,CAAT,CAAWA,CAAX,EAAaC,CAAb,EAAe;AAAC,QAAMC,CAAC,GAACF,CAAC,CAACG,QAAV;AAAmBF,EAAAA,CAAC,CAACG,cAAF,IAAkBJ,CAAC,CAACK,UAAF,CAAaC,GAAb,CAAiB,SAAjB,EAA2B,MAA3B,GAAmCN,CAAC,CAACO,QAAF,CAAWD,GAAX,CAAe,UAAf,EAA0B,MAA1B,CAAnC,EAAqE,MAAIL,CAAC,CAACO,eAAN,GAAsBN,CAAC,CAACO,IAAF,CAAOH,GAAP,CAAWP,CAAE;AAChT;AACA;AACA;AACA;AACA,EALmS,CAAtB,GAKzQG,CAAC,CAACO,IAAF,CAAOH,GAAP,CAAWP,CAAE;AACjB;AACA;AACA;AACA;AACA,EALI,CALkL,KAUhLC,CAAC,CAACU,UAAF,CAAaJ,GAAb,CAAiB,6BAAjB,GAAgDJ,CAAC,CAACO,IAAF,CAAOH,GAAP,CAAWP,CAAE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAXsD,CAVgI,GAqBjL,MAAIE,CAAC,CAACU,2BAAN,KAAoCX,CAAC,CAACY,OAAF,CAAUf,CAAV,EAAYI,CAAZ,GAAeC,CAAC,CAACW,QAAF,CAAWP,GAAX,CAAe,eAAf,EAA+B,WAA/B,CAAf,EAA2DJ,CAAC,CAACW,QAAF,CAAWP,GAAX,CAAe,mBAAf,EAAmC,MAAnC,CAA3D,EAAsGJ,CAAC,CAACO,IAAF,CAAOH,GAAP,CAAWP,CAAE;AAC5J;AACA;AACA,QAAQE,CAAC,CAACa,oBAAF,GAAuB,+BAAvB,GAAuD,EAAG;AAClE;AACA;AACA;AACA,GAP+I,CAA1I,CArBiL;AA4BhL;;AAAA,SAAOd,CAAC,IAAIe,oBAAZ","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{VertexTextureCoordinates as e}from\"../attributes/VertexTextureCoordinates.glsl.js\";import{glsl as t}from\"../../shaderModules/interfaces.js\";function n(n,a){const r=n.fragment;a.vertexTangents?(n.attributes.add(\"tangent\",\"vec4\"),n.varyings.add(\"vTangent\",\"vec4\"),2===a.doubleSidedMode?r.code.add(t`mat3 computeTangentSpace(vec3 normal) {\nfloat tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;\nvec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);\nvec3 bitangent = cross(normal, tangent) * tangentHeadedness;\nreturn mat3(tangent, bitangent, normal);\n}`):r.code.add(t`mat3 computeTangentSpace(vec3 normal) {\nfloat tangentHeadedness = vTangent.w;\nvec3 tangent = normalize(vTangent.xyz);\nvec3 bitangent = cross(normal, tangent) * tangentHeadedness;\nreturn mat3(tangent, bitangent, normal);\n}`)):(n.extensions.add(\"GL_OES_standard_derivatives\"),r.code.add(t`mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {\nvec3 Q1 = dFdx(pos);\nvec3 Q2 = dFdy(pos);\nvec2 stx = dFdx(st);\nvec2 sty = dFdy(st);\nfloat det = stx.t * sty.s - sty.t * stx.s;\nvec3 T = stx.t * Q2 - sty.t * Q1;\nT = T - normal * dot(normal, T);\nT *= inversesqrt(max(dot(T,T), 1.e-10));\nvec3 B = sign(det) * cross(normal, T);\nreturn mat3(T, B, normal);\n}`)),0!==a.attributeTextureCoordinates&&(n.include(e,a),r.uniforms.add(\"normalTexture\",\"sampler2D\"),r.uniforms.add(\"normalTextureSize\",\"vec2\"),r.code.add(t`\n    vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {\n      vtc.uv = uv;\n      ${a.supportsTextureAtlas?\"vtc.size = normalTextureSize;\":\"\"}\n      vec3 rawNormal = textureLookup(normalTexture, vtc).rgb * 2.0 - 1.0;\n      return tangentSpace * rawNormal;\n    }\n  `))}export{n as ComputeNormalTexture};\n"]},"metadata":{},"sourceType":"module"}