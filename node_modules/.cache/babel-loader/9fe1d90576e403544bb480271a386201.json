{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { ScreenSpacePass as e } from \"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.js\";\nimport { ReadLinearDepth as a } from \"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";\nimport { ReadShadowMap as r } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";\nimport { CameraSpace as o } from \"../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl.js\";\nimport { RgbaFloatEncoding as t } from \"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";\nimport { glsl as s } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as d } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nconst i = 255,\n      l = 1 / i;\n\nfunction n(n) {\n  const m = new d();\n  m.fragment.include(t), m.fragment.include(a), m.include(o), m.include(e);\n  const {\n    pass: p\n  } = n;\n\n  if (1 === p) {\n    const {\n      visualization: e,\n      bandsEnabled: a\n    } = n;\n    m.fragment.constants.add(\"inverseSampleValue\", \"float\", i), m.fragment.uniforms.add(\"shadowAccumulationMap\", \"sampler2D\"), m.fragment.uniforms.add(\"sampleScale\", \"float\"), m.fragment.uniforms.add(\"opacityFromElevation\", \"float\"), 0 === e ? (m.fragment.uniforms.add(\"colorRamp\", \"sampler2D\"), m.fragment.uniforms.add(\"rampSize\", \"float\"), m.fragment.code.add(s`vec4 sampleColorRamp(sampler2D ramp, float rampSize, float u) {\nfloat rampU = (u * (rampSize - 1.0) + 0.5) / rampSize;\nreturn texture2D(ramp, vec2(rampU, 0.5));\n}`), a && m.fragment.uniforms.add(\"bandSize\", \"float\")) : 1 === e && (m.fragment.uniforms.add(\"threshold\", \"float\"), m.fragment.uniforms.add(\"colors\", \"vec4\", 2)), m.fragment.code.add(s`\n      void main(void) {\n        vec4 record = texture2D(shadowAccumulationMap, uv);\n        float pixelSamples = record.r * inverseSampleValue;\n\n        if (pixelSamples < 1.0) {\n          discard;\n        }\n\n        float strength = pixelSamples * sampleScale;\n\n        ${0 === e && a ? s`strength = ceil(strength / bandSize) * bandSize;` : \"\"}\n\n        gl_FragColor = ${0 === e ? s`sampleColorRamp(colorRamp, rampSize, strength)` : s`strength <= threshold ? colors[0] : colors[1]`};\n\n        gl_FragColor.a *= opacityFromElevation;\n      }\n    `);\n  } else 0 !== p && 2 !== p || (m.include(r), m.fragment.uniforms.add(\"depthMap\", \"sampler2D\"), m.fragment.uniforms.add(\"inverseView\", \"mat4\"), m.fragment.uniforms.add(\"nearFar\", \"vec2\"), 0 === p ? m.fragment.constants.add(\"sampleValue\", \"float\", l) : m.fragment.constants.add(\"shadowColor\", \"vec4\", [0, 0, 0, .8]), m.fragment.code.add(s`\n      void main(void) {\n\n        float depth = rgba2float(texture2D(depthMap, uv));\n        // 0.0 is the clear value of depthMap, which means nothing has been drawn there and we should discard\n        if (depth == 0.0) {\n          discard;\n        }\n\n        float currentPixelDepth = linearDepthFromFloat(depth, nearFar);\n\n        if (-currentPixelDepth > nearFar.y || -currentPixelDepth < nearFar.x) {\n          discard;\n        }\n\n        vec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);\n        vec4 worldSpacePos = inverseView * currentPixelPos;\n\n        mat4 shadowMatrix;\n        float linearDepth = -currentPixelDepth;\n        int i = chooseCascade(linearDepth, shadowMatrix);\n\n        if (i >= uShadowMapNum) {\n          discard;\n        }\n\n        vec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);\n\n        // vertex completely outside? -> no shadow\n        if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {\n          discard;\n        }\n\n        vec2 uvShadow = cascadeCoordinates(i, lvpos);\n\n        float depthShadow = readShadowMapDepth(uvShadow, uShadowMapTex);\n        bool shadow = depthShadow < lvpos.z;\n\n        if (!shadow) {\n          discard;\n        }\n\n        gl_FragColor = ${0 === p ? s`vec4(sampleValue)` : s`shadowColor`};\n      }\n    `));\n\n  return m;\n}\n\nvar m = Object.freeze({\n  __proto__: null,\n  shadowAccumulationMaxSamples: i,\n  build: n\n});\nexport { m as S, n as b, i as s };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgis-api-react/node_modules/@arcgis/core/chunks/ShadowAccumulation.glsl.js"],"names":["ScreenSpacePass","e","ReadLinearDepth","a","ReadShadowMap","r","CameraSpace","o","RgbaFloatEncoding","t","glsl","s","ShaderBuilder","d","i","l","n","m","fragment","include","pass","p","visualization","bandsEnabled","constants","add","uniforms","code","Object","freeze","__proto__","shadowAccumulationMaxSamples","build","S","b"],"mappings":"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","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{ScreenSpacePass as e}from\"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.js\";import{ReadLinearDepth as a}from\"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";import{ReadShadowMap as r}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";import{CameraSpace as o}from\"../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl.js\";import{RgbaFloatEncoding as t}from\"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";import{glsl as s}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as d}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";const i=255,l=1/i;function n(n){const m=new d;m.fragment.include(t),m.fragment.include(a),m.include(o),m.include(e);const{pass:p}=n;if(1===p){const{visualization:e,bandsEnabled:a}=n;m.fragment.constants.add(\"inverseSampleValue\",\"float\",i),m.fragment.uniforms.add(\"shadowAccumulationMap\",\"sampler2D\"),m.fragment.uniforms.add(\"sampleScale\",\"float\"),m.fragment.uniforms.add(\"opacityFromElevation\",\"float\"),0===e?(m.fragment.uniforms.add(\"colorRamp\",\"sampler2D\"),m.fragment.uniforms.add(\"rampSize\",\"float\"),m.fragment.code.add(s`vec4 sampleColorRamp(sampler2D ramp, float rampSize, float u) {\nfloat rampU = (u * (rampSize - 1.0) + 0.5) / rampSize;\nreturn texture2D(ramp, vec2(rampU, 0.5));\n}`),a&&m.fragment.uniforms.add(\"bandSize\",\"float\")):1===e&&(m.fragment.uniforms.add(\"threshold\",\"float\"),m.fragment.uniforms.add(\"colors\",\"vec4\",2)),m.fragment.code.add(s`\n      void main(void) {\n        vec4 record = texture2D(shadowAccumulationMap, uv);\n        float pixelSamples = record.r * inverseSampleValue;\n\n        if (pixelSamples < 1.0) {\n          discard;\n        }\n\n        float strength = pixelSamples * sampleScale;\n\n        ${0===e&&a?s`strength = ceil(strength / bandSize) * bandSize;`:\"\"}\n\n        gl_FragColor = ${0===e?s`sampleColorRamp(colorRamp, rampSize, strength)`:s`strength <= threshold ? colors[0] : colors[1]`};\n\n        gl_FragColor.a *= opacityFromElevation;\n      }\n    `)}else 0!==p&&2!==p||(m.include(r),m.fragment.uniforms.add(\"depthMap\",\"sampler2D\"),m.fragment.uniforms.add(\"inverseView\",\"mat4\"),m.fragment.uniforms.add(\"nearFar\",\"vec2\"),0===p?m.fragment.constants.add(\"sampleValue\",\"float\",l):m.fragment.constants.add(\"shadowColor\",\"vec4\",[0,0,0,.8]),m.fragment.code.add(s`\n      void main(void) {\n\n        float depth = rgba2float(texture2D(depthMap, uv));\n        // 0.0 is the clear value of depthMap, which means nothing has been drawn there and we should discard\n        if (depth == 0.0) {\n          discard;\n        }\n\n        float currentPixelDepth = linearDepthFromFloat(depth, nearFar);\n\n        if (-currentPixelDepth > nearFar.y || -currentPixelDepth < nearFar.x) {\n          discard;\n        }\n\n        vec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);\n        vec4 worldSpacePos = inverseView * currentPixelPos;\n\n        mat4 shadowMatrix;\n        float linearDepth = -currentPixelDepth;\n        int i = chooseCascade(linearDepth, shadowMatrix);\n\n        if (i >= uShadowMapNum) {\n          discard;\n        }\n\n        vec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);\n\n        // vertex completely outside? -> no shadow\n        if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {\n          discard;\n        }\n\n        vec2 uvShadow = cascadeCoordinates(i, lvpos);\n\n        float depthShadow = readShadowMapDepth(uvShadow, uShadowMapTex);\n        bool shadow = depthShadow < lvpos.z;\n\n        if (!shadow) {\n          discard;\n        }\n\n        gl_FragColor = ${0===p?s`vec4(sampleValue)`:s`shadowColor`};\n      }\n    `));return m}var m=Object.freeze({__proto__:null,shadowAccumulationMaxSamples:i,build:n});export{m as S,n as b,i as s};\n"]},"metadata":{},"sourceType":"module"}