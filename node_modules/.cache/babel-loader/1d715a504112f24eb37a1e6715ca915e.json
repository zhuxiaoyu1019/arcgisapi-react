{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { ColorConversion as e } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { glsl as a } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as t } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\n\nfunction r(r) {\n  const n = new t();\n  return n.attributes.add(\"position\", \"vec2\"), n.attributes.add(\"uv0\", \"vec2\"), n.varyings.add(\"worldRay\", \"vec3\"), n.varyings.add(\"vtc\", \"vec2\"), r.haze && n.varyings.add(\"eyeDir\", \"vec3\"), n.vertex.uniforms.add(\"projectionInverse\", \"mat4\"), n.vertex.uniforms.add(\"viewInverse\", \"mat4\"), n.vertex.code.add(a`\n    void main(void) {\n      vec3 posViewNear = (projectionInverse * vec4(position, -1, 1)).xyz;\n\n      worldRay = (viewInverse * vec4(posViewNear, 0)).xyz;\n      vtc = uv0;\n\n      ${r.haze ? a`eyeDir = posViewNear;` : \"\"}\n\n      gl_Position = vec4(position, 1, 1);\n    }\n  `), n.fragment.uniforms.add(\"lightingMainDirection\", \"vec3\").add(\"invWavelength\", \"vec3\").add(\"invWavelengthScaled\", \"vec3\").add(\"radii\", \"vec2\").add(\"atmosphereParameters1\", \"vec4\").add(\"atmosphereParameters2\", \"vec4\").add(\"cameraPosition\", \"vec3\").add(\"nearFar\", \"vec2\").add(\"heightParameters\", \"vec4\"), r.haze ? n.fragment.uniforms.add(\"depthTex\", \"sampler2D\") : n.fragment.uniforms.add(\"atmosphereParameters3\", \"vec3\").add(\"innerFadeDistance\", \"float\").add(\"altitudeFade\", \"float\"), n.fragment.include(e), n.fragment.code.add(a`const float krESun = 0.075;\nconst float kmESun = 0.015;\n#define innerRadius radii[0]\n#define outerRadius radii[1]\n#define shellScale atmosphereParameters1.x\n#define shellDepth vec2(atmosphereParameters1.y, atmosphereParameters2.y)\n#define scaleOverScaleDepth vec2(atmosphereParameters1.z, atmosphereParameters2.z)\n#define oneOverScaleDepth vec2(atmosphereParameters1.w, atmosphereParameters2.w)`), r.haze || n.fragment.code.add(a`#define g atmosphereParameters2.x\n#define gSq atmosphereParameters3.x\n#define miePhaseCoefficients atmosphereParameters3.y\n#define lowerAlphaBlendBound atmosphereParameters3.z`), n.fragment.code.add(a`\n  // The camera's current height\n  #define cameraHeight heightParameters[0]\n  // cameraHeight^2\n  #define cameraHeightSq heightParameters[1]\n  // cameraHeightSq - outerRadiusSq; // C = ||o-c||^2 - r^2\n  #define C heightParameters[2]\n  // cameraHeightSq - (innerRadiusSq - 63756370000.0); // C = ||o-c||^2 - r^2\n  #define CSur heightParameters[3]\n\n  ${r.haze ? \"// Camera HDR\\n        const float exposure = 1.5;\\n        const vec3 oneOverGamma = vec3(1.0); //Gamma = 1.0\" : \"const float exposure = 2.0;\\n        const vec3 oneOverGamma = vec3(0.454545); // Gamma = 2.2\\n        vec3 reinhardTM(vec3 inputColor, float _exposure) {\\n          vec3 intermediate = inputColor * _exposure;\\n          intermediate /= ( 1.0 + intermediate );\\n          return pow(intermediate, oneOverGamma);\\n        }\\n        \"}\n    // Loop constants for integral approximation\n    const float samples = 5.0;\n    const int maxSamples = 5;\n\n    // ToneMapping operators\n    vec3 expTM(vec3 inputColor,float _exposure) {\n        return pow(1.0 - exp(inputColor * -_exposure), oneOverGamma);\n    }\n\n    // Approximation for inner integral based on a radii ratio of 10.25:10\n    float scale(float _cos) {\n      float x = 1.0 - _cos;\n      return exp( -0.00287 + x * ( 0.459 + x * ( 3.83 + x * (-6.80 + x * 5.25 ))));\n    }\n\n    void main() {\n      // Obtain ray from Camera\n      vec3 worldSpaceRay = normalize(worldRay);\n\n      // Compute Atmosphere intersection; i.e. ray/sphere intersection\n      float B = 2.0 * dot(cameraPosition, worldSpaceRay); // B = 2(l * (o-c))\n      float det = B * B - 4.0 * C; // det = B^2 - 4.0* C\n\n      // idealized sphere intersection to discard early some pixels\n      float detSur = B * B - 4.0 * CSur; // det = B^2 - 4.0* C\n\n      // the minimal sample start position:\n      // at the camera by default, on the earth radius surface if the camera is underground.\n      float minRayStart = 0.0;\n  `), r.haze || n.fragment.code.add(a`float surfaceBlend = 0.0;\nvec4 surfaceColor = vec4(0.0);\nif (detSur >= 0.0) {\nfloat nearSurface = max(0.0, 0.5 *(-B - sqrt(detSur)));\nfloat farSurface = max(0.0, 0.5 *(-B + sqrt(detSur)));\nif (nearSurface == 0.0) {\nminRayStart = farSurface;\n}\nvec3 vPos = cameraPosition + worldSpaceRay * nearSurface;\nfloat lightAngle = dot(lightingMainDirection, normalize(vPos));\nfloat brightness = max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)));\nsurfaceColor = vec4(brightness, brightness, brightness, 1.0 - altitudeFade);\nfloat relDist = (farSurface - nearSurface) / innerFadeDistance;\nif (relDist > 1.0) {\ngl_FragColor = surfaceColor;\nreturn;\n}\nsurfaceBlend = smoothstep(0.0, 1.0, relDist * relDist);\n}`), n.fragment.code.add(a`\n    if (det >= 0.0) {\n    ${r.haze ? \"\\n          float depthSample = texture2D(depthTex, vtc).r;\\n\\n          float zNear = nearFar[0];\\n          float zFar = nearFar[1];\\n\\n          // http://web.archive.org/web/20130416194336/http://olivers.posterous.com/linear-depth-in-glsl-for-real\\n          float zNorm = 2.0 * depthSample - 1.0;\\n          float linDepth = 2.0 * zNear * zFar /\\n            (zFar + zNear - zNorm * (zFar - zNear));\\n\\n          float rayEnd;\\n          float altitudeAlpha = 1.0;\\n\\n          // find intersections with ground, but only between the near and far\\n          // clipping planes.\\n          if (depthSample < 1.0 && depthSample > 0.0) {\\n            vec3 cameraSpaceRay = normalize(eyeDir);\\n            cameraSpaceRay /= cameraSpaceRay.z;\\n            cameraSpaceRay *= linDepth;\\n\\n            float cameraSpaceRayLength = length(cameraSpaceRay);\\n\\n            vec3 world = cameraPosition + worldSpaceRay * cameraSpaceRayLength;\\n            float worldRadiusSq = dot(world, world);\\n\\n            // Handle tall structures:\\n            // https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/5450\\n            float transitionStart = innerRadius + 20000.0;\\n            float transitionHeight = 25000.0;\\n            float transitionEnd = transitionStart + transitionHeight;\\n\\n            float edge0 = transitionStart * transitionStart;\\n            float edge1 = transitionEnd * transitionEnd;\\n\\n            altitudeAlpha = 1.0 - clamp((worldRadiusSq - edge0) / (edge1 - edge0), 0.0, 1.0);\\n            rayEnd = cameraSpaceRayLength;\\n\\n            if (altitudeAlpha > 0.0 && detSur > 0.0) {\\n              float nearSurface = 0.5 * ( -B - sqrt(detSur) );\\n              float interp = clamp(((cameraHeight - innerRadius) - 2000000.0) / 6000000.0, 0.0, 1.0);\\n              rayEnd = mix(cameraSpaceRayLength, nearSurface, interp);\\n            }\\n          }\" : \"\"}\n    float rayStart = 0.5 *(-B - sqrt(det)); //near intersection with atmosphere\n    ${r.haze ? \"float near = abs(rayStart);\\n        float far = abs(rayEnd);\" : \"float rayEnd = 0.5 *(-B + sqrt(det)); //far intersection with atmosphere\"}\n\n    float scatterDistance; // calculate its scattering offset\n    // Calculate the ray's starting position\n    if (rayStart < minRayStart)\n    { // ray starts from camera or inner radius sphere to far\n      rayStart = minRayStart;\n      ${r.haze ? \"\" : \"// clamp to value at inner radius altitude\\n          scatterDistance = shellScale * min(0.0, innerRadius - cameraHeight);\"}\n    }\n    ${r.haze ? \"\" : \"else { // outside atmosphere\\n          scatterDistance = -1.0;\\n        }\"}\n    // Initialize the scattering loop variables\n    vec3 start = cameraPosition + worldSpaceRay * rayStart;\n  `), r.haze && n.fragment.code.add(a`vec3 end = cameraPosition + worldSpaceRay * rayEnd;\nfloat endLength = length(end);\nvec2 altitudeInterval = vec2(length(start) - innerRadius, endLength - innerRadius);\nif (altitudeInterval.x < 0.0) {\naltitudeInterval = -altitudeInterval;\n}\nfloat lightAngle = dot(lightingMainDirection, end) / endLength;\nif (near > far)\n{\nif (altitudeInterval.x < altitudeInterval.y)\n{\nend = cameraPosition + worldSpaceRay * rayStart;\nstart = cameraPosition + worldSpaceRay * rayEnd;\nworldSpaceRay *= -1.0;\nfloat tmp = altitudeInterval.x;\naltitudeInterval.x = altitudeInterval.y;\naltitudeInterval.y = tmp;\n}\nelse if (altitudeInterval.x == altitudeInterval.y)\n{\naltitudeInterval.x += 1.0;\n}\n}\nif (altitudeInterval.x > outerRadius - innerRadius)\n{\nscatterDistance = innerRadius - outerRadius;\n} else\n{\nscatterDistance = altitudeInterval.y - altitudeInterval.x;\n}`), n.fragment.code.add(a`vec2 opticalStartDepth = exp(scatterDistance * oneOverScaleDepth);\nfloat rayLength = rayEnd - rayStart;\nfloat sampleLength = rayLength / samples;\nfloat scaledLength = sampleLength * shellScale;\nvec3 sampleRay = worldSpaceRay * sampleLength;\nvec3 samplePoint = start + sampleRay * 0.5;`), r.haze ? n.fragment.code.add(a`float cameraAngle = dot(-worldSpaceRay, end) / length(end);\nfloat scaleCameraAngle = scale(cameraAngle);\nvec2 cameraOffset = scaleCameraAngle * opticalStartDepth;\nfloat scaledValues = scale(lightAngle) + scaleCameraAngle;\nvec2 scaledValuesDepth = scaledValues * shellDepth;`) : n.fragment.code.add(a`float cameraAngle = dot(worldSpaceRay, start / length(start));\nfloat angleMultiplier = cameraAngle > 0.0 ? cameraAngle : 0.0;\nfloat scaleCameraAngle = scale(cameraAngle);\nvec2 cameraOffset = scaleCameraAngle * opticalStartDepth * shellDepth;`), n.fragment.code.add(a`vec3 frontColor = vec3(0.0);\nvec3 frontColorBlue = vec3(0.0);\nvec3 attenuate = vec3(0.0);\nvec3 attenuateBlue = vec3(0.0);\nfor(int i=0; i<maxSamples; i++) {\nfloat height = length(samplePoint);\nfloat altitude = abs(height - innerRadius);\nvec2 depth = exp(-altitude * scaleOverScaleDepth);`), r.haze ? n.fragment.code.add(a`vec2 scatter = depth * scaledValuesDepth - cameraOffset;`) : n.fragment.code.add(a`float lightAngle = dot(lightingMainDirection, samplePoint) / height;\nfloat cameraAngle = dot(worldSpaceRay, samplePoint) / height;\nfloat tmpScaledValues = scale(lightAngle) - scale(cameraAngle);\nvec2 scatter = cameraOffset + tmpScaledValues * depth * shellDepth;`), n.fragment.code.add(a`attenuate = exp(-scatter.x * invWavelengthScaled);\nattenuateBlue = exp(-scatter.y * invWavelengthScaled);\nfrontColor += attenuate * depth.x;\nfrontColorBlue += attenuateBlue * depth.y;\nsamplePoint += sampleRay;\n}\nfloat LdotR = clamp(dot(lightingMainDirection, -worldSpaceRay ),-0.9999999,1.0);\nfloat LdotRSq = LdotR * LdotR + 1.0;`), r.haze ? n.fragment.code.add(a`vec3 colorCoefficients = (scaledLength * 0.75 * LdotRSq) * (krESun * invWavelength + kmESun );\nvec3 color = colorCoefficients * frontColor;\nvec3 colorBlue = colorCoefficients * frontColorBlue;`) : n.fragment.code.add(a`vec3 rayleighCoefficients = (scaledLength * 0.75 * LdotRSq * krESun) * invWavelength;\nfloat mieCoefficients = scaledLength * kmESun * miePhaseCoefficients * LdotRSq / pow(1.0 + gSq - 2.0 * g * LdotR, 1.5);\nvec3 color = rayleighCoefficients * frontColor + mieCoefficients * frontColor;\nvec3 colorBlue = rayleighCoefficients * frontColorBlue + mieCoefficients * frontColorBlue;`), n.fragment.code.add(a`vec3 ldrBlue = expTM(colorBlue, 2.0 * exposure);\nvec3 ldrRed = expTM(color, exposure);\nvec3 LDR = mix(ldrBlue, ldrRed, 0.2);`), r.haze ? n.fragment.code.add(a`LDR *= (1.0 - cameraAngle);\nvec3 hsv = rgb2hsv(LDR);\nhsv.y = clamp(hsv.y * 1.5, 0.0, 1.0);\nLDR = hsv2rgb(hsv);\nvec3 finalColor = LDR;`) : n.fragment.code.add(a`vec3 ldrReinhard = reinhardTM(color, exposure);\nLDR += angleMultiplier * ldrReinhard;\nfloat side = (rayEnd + rayStart) * 0.5;\nfloat atmoHeight = sqrt(cameraHeightSq - side * side);\nfloat h2 = clamp(1.0 - ( atmoHeight - lowerAlphaBlendBound ) / ( outerRadius - lowerAlphaBlendBound ), 0.0, 1.0);\nvec3 finalColor = LDR * h2;\nvec3 hsv = rgb2hsv(finalColor);\nhsv.y = clamp(hsv.y * 1.5, 0.0, 1.0);\nfinalColor = hsv2rgb(hsv);`), n.fragment.code.add(a`\n    ${r.haze ? \"gl_FragColor = vec4(finalColor, 1.0) * altitudeAlpha;\" : \"float atmosStrength = clamp((length(ldrRed) - 0.05) * 1.05, 0.0, 1.0);\\n          gl_FragColor = vec4(finalColor, atmosStrength * clamp(1.0 - ( atmoHeight - innerRadius ) / (outerRadius - innerRadius), 0.0, 1.0));\\n          if (surfaceBlend > 0.0) {\\n            gl_FragColor = mix(gl_FragColor, surfaceColor, surfaceBlend);\\n          }\"}\n      } else { // Outside Atmosphere\n        gl_FragColor = vec4(0.0);\n      }\n    }\n  `), n;\n}\n\nvar n = Object.freeze({\n  __proto__: null,\n  build: r\n});\nexport { n as R, r as b };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgisapi-react/node_modules/@arcgis/core/chunks/RealisticAtmosphere.glsl.js"],"names":["ColorConversion","e","glsl","a","ShaderBuilder","t","r","n","attributes","add","varyings","haze","vertex","uniforms","code","fragment","include","Object","freeze","__proto__","build","R","b"],"mappings":"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","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{ColorConversion as e}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{glsl as a}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as t}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";function r(r){const n=new t;return n.attributes.add(\"position\",\"vec2\"),n.attributes.add(\"uv0\",\"vec2\"),n.varyings.add(\"worldRay\",\"vec3\"),n.varyings.add(\"vtc\",\"vec2\"),r.haze&&n.varyings.add(\"eyeDir\",\"vec3\"),n.vertex.uniforms.add(\"projectionInverse\",\"mat4\"),n.vertex.uniforms.add(\"viewInverse\",\"mat4\"),n.vertex.code.add(a`\n    void main(void) {\n      vec3 posViewNear = (projectionInverse * vec4(position, -1, 1)).xyz;\n\n      worldRay = (viewInverse * vec4(posViewNear, 0)).xyz;\n      vtc = uv0;\n\n      ${r.haze?a`eyeDir = posViewNear;`:\"\"}\n\n      gl_Position = vec4(position, 1, 1);\n    }\n  `),n.fragment.uniforms.add(\"lightingMainDirection\",\"vec3\").add(\"invWavelength\",\"vec3\").add(\"invWavelengthScaled\",\"vec3\").add(\"radii\",\"vec2\").add(\"atmosphereParameters1\",\"vec4\").add(\"atmosphereParameters2\",\"vec4\").add(\"cameraPosition\",\"vec3\").add(\"nearFar\",\"vec2\").add(\"heightParameters\",\"vec4\"),r.haze?n.fragment.uniforms.add(\"depthTex\",\"sampler2D\"):n.fragment.uniforms.add(\"atmosphereParameters3\",\"vec3\").add(\"innerFadeDistance\",\"float\").add(\"altitudeFade\",\"float\"),n.fragment.include(e),n.fragment.code.add(a`const float krESun = 0.075;\nconst float kmESun = 0.015;\n#define innerRadius radii[0]\n#define outerRadius radii[1]\n#define shellScale atmosphereParameters1.x\n#define shellDepth vec2(atmosphereParameters1.y, atmosphereParameters2.y)\n#define scaleOverScaleDepth vec2(atmosphereParameters1.z, atmosphereParameters2.z)\n#define oneOverScaleDepth vec2(atmosphereParameters1.w, atmosphereParameters2.w)`),r.haze||n.fragment.code.add(a`#define g atmosphereParameters2.x\n#define gSq atmosphereParameters3.x\n#define miePhaseCoefficients atmosphereParameters3.y\n#define lowerAlphaBlendBound atmosphereParameters3.z`),n.fragment.code.add(a`\n  // The camera's current height\n  #define cameraHeight heightParameters[0]\n  // cameraHeight^2\n  #define cameraHeightSq heightParameters[1]\n  // cameraHeightSq - outerRadiusSq; // C = ||o-c||^2 - r^2\n  #define C heightParameters[2]\n  // cameraHeightSq - (innerRadiusSq - 63756370000.0); // C = ||o-c||^2 - r^2\n  #define CSur heightParameters[3]\n\n  ${r.haze?\"// Camera HDR\\n        const float exposure = 1.5;\\n        const vec3 oneOverGamma = vec3(1.0); //Gamma = 1.0\":\"const float exposure = 2.0;\\n        const vec3 oneOverGamma = vec3(0.454545); // Gamma = 2.2\\n        vec3 reinhardTM(vec3 inputColor, float _exposure) {\\n          vec3 intermediate = inputColor * _exposure;\\n          intermediate /= ( 1.0 + intermediate );\\n          return pow(intermediate, oneOverGamma);\\n        }\\n        \"}\n    // Loop constants for integral approximation\n    const float samples = 5.0;\n    const int maxSamples = 5;\n\n    // ToneMapping operators\n    vec3 expTM(vec3 inputColor,float _exposure) {\n        return pow(1.0 - exp(inputColor * -_exposure), oneOverGamma);\n    }\n\n    // Approximation for inner integral based on a radii ratio of 10.25:10\n    float scale(float _cos) {\n      float x = 1.0 - _cos;\n      return exp( -0.00287 + x * ( 0.459 + x * ( 3.83 + x * (-6.80 + x * 5.25 ))));\n    }\n\n    void main() {\n      // Obtain ray from Camera\n      vec3 worldSpaceRay = normalize(worldRay);\n\n      // Compute Atmosphere intersection; i.e. ray/sphere intersection\n      float B = 2.0 * dot(cameraPosition, worldSpaceRay); // B = 2(l * (o-c))\n      float det = B * B - 4.0 * C; // det = B^2 - 4.0* C\n\n      // idealized sphere intersection to discard early some pixels\n      float detSur = B * B - 4.0 * CSur; // det = B^2 - 4.0* C\n\n      // the minimal sample start position:\n      // at the camera by default, on the earth radius surface if the camera is underground.\n      float minRayStart = 0.0;\n  `),r.haze||n.fragment.code.add(a`float surfaceBlend = 0.0;\nvec4 surfaceColor = vec4(0.0);\nif (detSur >= 0.0) {\nfloat nearSurface = max(0.0, 0.5 *(-B - sqrt(detSur)));\nfloat farSurface = max(0.0, 0.5 *(-B + sqrt(detSur)));\nif (nearSurface == 0.0) {\nminRayStart = farSurface;\n}\nvec3 vPos = cameraPosition + worldSpaceRay * nearSurface;\nfloat lightAngle = dot(lightingMainDirection, normalize(vPos));\nfloat brightness = max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)));\nsurfaceColor = vec4(brightness, brightness, brightness, 1.0 - altitudeFade);\nfloat relDist = (farSurface - nearSurface) / innerFadeDistance;\nif (relDist > 1.0) {\ngl_FragColor = surfaceColor;\nreturn;\n}\nsurfaceBlend = smoothstep(0.0, 1.0, relDist * relDist);\n}`),n.fragment.code.add(a`\n    if (det >= 0.0) {\n    ${r.haze?\"\\n          float depthSample = texture2D(depthTex, vtc).r;\\n\\n          float zNear = nearFar[0];\\n          float zFar = nearFar[1];\\n\\n          // http://web.archive.org/web/20130416194336/http://olivers.posterous.com/linear-depth-in-glsl-for-real\\n          float zNorm = 2.0 * depthSample - 1.0;\\n          float linDepth = 2.0 * zNear * zFar /\\n            (zFar + zNear - zNorm * (zFar - zNear));\\n\\n          float rayEnd;\\n          float altitudeAlpha = 1.0;\\n\\n          // find intersections with ground, but only between the near and far\\n          // clipping planes.\\n          if (depthSample < 1.0 && depthSample > 0.0) {\\n            vec3 cameraSpaceRay = normalize(eyeDir);\\n            cameraSpaceRay /= cameraSpaceRay.z;\\n            cameraSpaceRay *= linDepth;\\n\\n            float cameraSpaceRayLength = length(cameraSpaceRay);\\n\\n            vec3 world = cameraPosition + worldSpaceRay * cameraSpaceRayLength;\\n            float worldRadiusSq = dot(world, world);\\n\\n            // Handle tall structures:\\n            // https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/5450\\n            float transitionStart = innerRadius + 20000.0;\\n            float transitionHeight = 25000.0;\\n            float transitionEnd = transitionStart + transitionHeight;\\n\\n            float edge0 = transitionStart * transitionStart;\\n            float edge1 = transitionEnd * transitionEnd;\\n\\n            altitudeAlpha = 1.0 - clamp((worldRadiusSq - edge0) / (edge1 - edge0), 0.0, 1.0);\\n            rayEnd = cameraSpaceRayLength;\\n\\n            if (altitudeAlpha > 0.0 && detSur > 0.0) {\\n              float nearSurface = 0.5 * ( -B - sqrt(detSur) );\\n              float interp = clamp(((cameraHeight - innerRadius) - 2000000.0) / 6000000.0, 0.0, 1.0);\\n              rayEnd = mix(cameraSpaceRayLength, nearSurface, interp);\\n            }\\n          }\":\"\"}\n    float rayStart = 0.5 *(-B - sqrt(det)); //near intersection with atmosphere\n    ${r.haze?\"float near = abs(rayStart);\\n        float far = abs(rayEnd);\":\"float rayEnd = 0.5 *(-B + sqrt(det)); //far intersection with atmosphere\"}\n\n    float scatterDistance; // calculate its scattering offset\n    // Calculate the ray's starting position\n    if (rayStart < minRayStart)\n    { // ray starts from camera or inner radius sphere to far\n      rayStart = minRayStart;\n      ${r.haze?\"\":\"// clamp to value at inner radius altitude\\n          scatterDistance = shellScale * min(0.0, innerRadius - cameraHeight);\"}\n    }\n    ${r.haze?\"\":\"else { // outside atmosphere\\n          scatterDistance = -1.0;\\n        }\"}\n    // Initialize the scattering loop variables\n    vec3 start = cameraPosition + worldSpaceRay * rayStart;\n  `),r.haze&&n.fragment.code.add(a`vec3 end = cameraPosition + worldSpaceRay * rayEnd;\nfloat endLength = length(end);\nvec2 altitudeInterval = vec2(length(start) - innerRadius, endLength - innerRadius);\nif (altitudeInterval.x < 0.0) {\naltitudeInterval = -altitudeInterval;\n}\nfloat lightAngle = dot(lightingMainDirection, end) / endLength;\nif (near > far)\n{\nif (altitudeInterval.x < altitudeInterval.y)\n{\nend = cameraPosition + worldSpaceRay * rayStart;\nstart = cameraPosition + worldSpaceRay * rayEnd;\nworldSpaceRay *= -1.0;\nfloat tmp = altitudeInterval.x;\naltitudeInterval.x = altitudeInterval.y;\naltitudeInterval.y = tmp;\n}\nelse if (altitudeInterval.x == altitudeInterval.y)\n{\naltitudeInterval.x += 1.0;\n}\n}\nif (altitudeInterval.x > outerRadius - innerRadius)\n{\nscatterDistance = innerRadius - outerRadius;\n} else\n{\nscatterDistance = altitudeInterval.y - altitudeInterval.x;\n}`),n.fragment.code.add(a`vec2 opticalStartDepth = exp(scatterDistance * oneOverScaleDepth);\nfloat rayLength = rayEnd - rayStart;\nfloat sampleLength = rayLength / samples;\nfloat scaledLength = sampleLength * shellScale;\nvec3 sampleRay = worldSpaceRay * sampleLength;\nvec3 samplePoint = start + sampleRay * 0.5;`),r.haze?n.fragment.code.add(a`float cameraAngle = dot(-worldSpaceRay, end) / length(end);\nfloat scaleCameraAngle = scale(cameraAngle);\nvec2 cameraOffset = scaleCameraAngle * opticalStartDepth;\nfloat scaledValues = scale(lightAngle) + scaleCameraAngle;\nvec2 scaledValuesDepth = scaledValues * shellDepth;`):n.fragment.code.add(a`float cameraAngle = dot(worldSpaceRay, start / length(start));\nfloat angleMultiplier = cameraAngle > 0.0 ? cameraAngle : 0.0;\nfloat scaleCameraAngle = scale(cameraAngle);\nvec2 cameraOffset = scaleCameraAngle * opticalStartDepth * shellDepth;`),n.fragment.code.add(a`vec3 frontColor = vec3(0.0);\nvec3 frontColorBlue = vec3(0.0);\nvec3 attenuate = vec3(0.0);\nvec3 attenuateBlue = vec3(0.0);\nfor(int i=0; i<maxSamples; i++) {\nfloat height = length(samplePoint);\nfloat altitude = abs(height - innerRadius);\nvec2 depth = exp(-altitude * scaleOverScaleDepth);`),r.haze?n.fragment.code.add(a`vec2 scatter = depth * scaledValuesDepth - cameraOffset;`):n.fragment.code.add(a`float lightAngle = dot(lightingMainDirection, samplePoint) / height;\nfloat cameraAngle = dot(worldSpaceRay, samplePoint) / height;\nfloat tmpScaledValues = scale(lightAngle) - scale(cameraAngle);\nvec2 scatter = cameraOffset + tmpScaledValues * depth * shellDepth;`),n.fragment.code.add(a`attenuate = exp(-scatter.x * invWavelengthScaled);\nattenuateBlue = exp(-scatter.y * invWavelengthScaled);\nfrontColor += attenuate * depth.x;\nfrontColorBlue += attenuateBlue * depth.y;\nsamplePoint += sampleRay;\n}\nfloat LdotR = clamp(dot(lightingMainDirection, -worldSpaceRay ),-0.9999999,1.0);\nfloat LdotRSq = LdotR * LdotR + 1.0;`),r.haze?n.fragment.code.add(a`vec3 colorCoefficients = (scaledLength * 0.75 * LdotRSq) * (krESun * invWavelength + kmESun );\nvec3 color = colorCoefficients * frontColor;\nvec3 colorBlue = colorCoefficients * frontColorBlue;`):n.fragment.code.add(a`vec3 rayleighCoefficients = (scaledLength * 0.75 * LdotRSq * krESun) * invWavelength;\nfloat mieCoefficients = scaledLength * kmESun * miePhaseCoefficients * LdotRSq / pow(1.0 + gSq - 2.0 * g * LdotR, 1.5);\nvec3 color = rayleighCoefficients * frontColor + mieCoefficients * frontColor;\nvec3 colorBlue = rayleighCoefficients * frontColorBlue + mieCoefficients * frontColorBlue;`),n.fragment.code.add(a`vec3 ldrBlue = expTM(colorBlue, 2.0 * exposure);\nvec3 ldrRed = expTM(color, exposure);\nvec3 LDR = mix(ldrBlue, ldrRed, 0.2);`),r.haze?n.fragment.code.add(a`LDR *= (1.0 - cameraAngle);\nvec3 hsv = rgb2hsv(LDR);\nhsv.y = clamp(hsv.y * 1.5, 0.0, 1.0);\nLDR = hsv2rgb(hsv);\nvec3 finalColor = LDR;`):n.fragment.code.add(a`vec3 ldrReinhard = reinhardTM(color, exposure);\nLDR += angleMultiplier * ldrReinhard;\nfloat side = (rayEnd + rayStart) * 0.5;\nfloat atmoHeight = sqrt(cameraHeightSq - side * side);\nfloat h2 = clamp(1.0 - ( atmoHeight - lowerAlphaBlendBound ) / ( outerRadius - lowerAlphaBlendBound ), 0.0, 1.0);\nvec3 finalColor = LDR * h2;\nvec3 hsv = rgb2hsv(finalColor);\nhsv.y = clamp(hsv.y * 1.5, 0.0, 1.0);\nfinalColor = hsv2rgb(hsv);`),n.fragment.code.add(a`\n    ${r.haze?\"gl_FragColor = vec4(finalColor, 1.0) * altitudeAlpha;\":\"float atmosStrength = clamp((length(ldrRed) - 0.05) * 1.05, 0.0, 1.0);\\n          gl_FragColor = vec4(finalColor, atmosStrength * clamp(1.0 - ( atmoHeight - innerRadius ) / (outerRadius - innerRadius), 0.0, 1.0));\\n          if (surfaceBlend > 0.0) {\\n            gl_FragColor = mix(gl_FragColor, surfaceColor, surfaceBlend);\\n          }\"}\n      } else { // Outside Atmosphere\n        gl_FragColor = vec4(0.0);\n      }\n    }\n  `),n}var n=Object.freeze({__proto__:null,build:r});export{n as R,r as b};\n"]},"metadata":{},"sourceType":"module"}