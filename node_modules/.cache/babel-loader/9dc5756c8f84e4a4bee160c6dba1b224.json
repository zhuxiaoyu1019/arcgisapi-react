{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { EvaluateAmbientLighting as i } from \"./EvaluateAmbientLighting.glsl.js\";\nimport { EvaluateAmbientOcclusion as n } from \"./EvaluateAmbientOcclusion.glsl.js\";\nimport { EvaluateMainLighting as o } from \"./EvaluateMainLighting.glsl.js\";\nimport { PhysicallyBasedRendering as e } from \"./PhysicallyBasedRendering.glsl.js\";\nimport { PiUtils as t } from \"./PiUtils.glsl.js\";\nimport { ReadShadowMap as a } from \"./ReadShadowMap.glsl.js\";\nimport { glsl as r } from \"../../shaderModules/interfaces.js\";\n\nfunction l(l, d) {\n  const c = l.fragment;\n  l.include(o), l.include(n, d), 0 !== d.pbrMode && l.include(e, d), l.include(i, d), d.receiveShadows && l.include(a, d), c.uniforms.add(\"lightingGlobalFactor\", \"float\"), c.uniforms.add(\"ambientBoostFactor\", \"float\"), l.include(t), c.code.add(r`\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;\n    ${0 === d.pbrMode ? \"\" : \"const vec3 GROUND_REFLECTANCE = vec3(0.2);\"}\n  `), c.code.add(r`\n    float additionalDirectedAmbientLight(vec3 vPosWorld) {\n      float vndl = dot(${1 === d.viewingMode ? r`normalize(vPosWorld)` : r`vec3(0.0, 0.0, 1.0)`}, lightingMainDirection);\n      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n    }\n  `), c.code.add(r`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\nfloat additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);\nreturn (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * lightingMainIntensity;\n}`), 0 === d.pbrMode || 4 === d.pbrMode ? c.code.add(r`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight)\n{\nvec3 mainLighting = evaluateMainLighting(normalWorld, shadow);\nvec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);\nvec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\nvec3 totalLight = mainLighting + ambientLighting + additionalLight;\ntotalLight = min(totalLight, vec3(PI));\nvec3 outColor = vec3((albedoLinear / PI) * totalLight);\nreturn pow(outColor, vec3(INV_GAMMA_SRGB));\n}`) : 1 !== d.pbrMode && 2 !== d.pbrMode || (c.code.add(r`const float fillLightIntensity = 0.25;\nconst float horizonLightDiffusion = 0.4;\nconst float additionalAmbientIrradianceFactor = 0.02;\nvec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)\n{\nvec3 viewDirection = -viewDir;\nvec3 mainLightDirection = lightingMainDirection;\nvec3 h = normalize(viewDirection + mainLightDirection);\nPBRShadingInfo inputs;\ninputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\ninputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\ninputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\ninputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\ninputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\nvec3 reflectedView = normalize(reflect(viewDirection, normal));\ninputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\ninputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\ninputs.ssao = ssao;\ninputs.metalness = mrr[0];\ninputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`), c.code.add(r`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\ninputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));\ninputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`), c.code.add(r`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);\nambientDir = ambientDir != vec3(0.0)? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\ninputs.NdotAmbDir = abs(dot(normal, ambientDir));\nvec3 mainLightIrradianceComponent = inputs.NdotL * (1.0 - shadow) * lightingMainIntensity;\nvec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * lightingMainIntensity * fillLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\ninputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\ninputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`), c.code.add(r`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\nvec3 horizonRingH = normalize(viewDirection + horizonRingDir);\ninputs.NdotH_Horizon = dot(normal, horizonRingH);\nvec3 mainLightRadianceComponent = normalDistribution(inputs.NdotH, inputs.roughness) * lightingMainIntensity * (1.0 - shadow);\nvec3 horizonLightRadianceComponent = normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * lightingMainIntensity * fillLightIntensity;\nvec3 ambientLightRadianceComponent = calculateAmbientRadiance(ssao) + additionalLight;\ninputs.skyRadianceToSurface = ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\ninputs.groundRadianceToSurface = GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\ninputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`), c.code.add(r`\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        ${2 === d.pbrMode ? r`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));` : r`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));`}\n        return outColor;\n      }\n    `));\n}\n\nexport { l as EvaluateSceneLighting };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgis-api-react/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js"],"names":["EvaluateAmbientLighting","i","EvaluateAmbientOcclusion","n","EvaluateMainLighting","o","PhysicallyBasedRendering","e","PiUtils","t","ReadShadowMap","a","glsl","r","l","d","c","fragment","include","pbrMode","receiveShadows","uniforms","add","code","viewingMode","EvaluateSceneLighting"],"mappings":"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","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{EvaluateAmbientLighting as i}from\"./EvaluateAmbientLighting.glsl.js\";import{EvaluateAmbientOcclusion as n}from\"./EvaluateAmbientOcclusion.glsl.js\";import{EvaluateMainLighting as o}from\"./EvaluateMainLighting.glsl.js\";import{PhysicallyBasedRendering as e}from\"./PhysicallyBasedRendering.glsl.js\";import{PiUtils as t}from\"./PiUtils.glsl.js\";import{ReadShadowMap as a}from\"./ReadShadowMap.glsl.js\";import{glsl as r}from\"../../shaderModules/interfaces.js\";function l(l,d){const c=l.fragment;l.include(o),l.include(n,d),0!==d.pbrMode&&l.include(e,d),l.include(i,d),d.receiveShadows&&l.include(a,d),c.uniforms.add(\"lightingGlobalFactor\",\"float\"),c.uniforms.add(\"ambientBoostFactor\",\"float\"),l.include(t),c.code.add(r`\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;\n    ${0===d.pbrMode?\"\":\"const vec3 GROUND_REFLECTANCE = vec3(0.2);\"}\n  `),c.code.add(r`\n    float additionalDirectedAmbientLight(vec3 vPosWorld) {\n      float vndl = dot(${1===d.viewingMode?r`normalize(vPosWorld)`:r`vec3(0.0, 0.0, 1.0)`}, lightingMainDirection);\n      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n    }\n  `),c.code.add(r`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\nfloat additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);\nreturn (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * lightingMainIntensity;\n}`),0===d.pbrMode||4===d.pbrMode?c.code.add(r`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight)\n{\nvec3 mainLighting = evaluateMainLighting(normalWorld, shadow);\nvec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);\nvec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\nvec3 totalLight = mainLighting + ambientLighting + additionalLight;\ntotalLight = min(totalLight, vec3(PI));\nvec3 outColor = vec3((albedoLinear / PI) * totalLight);\nreturn pow(outColor, vec3(INV_GAMMA_SRGB));\n}`):1!==d.pbrMode&&2!==d.pbrMode||(c.code.add(r`const float fillLightIntensity = 0.25;\nconst float horizonLightDiffusion = 0.4;\nconst float additionalAmbientIrradianceFactor = 0.02;\nvec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)\n{\nvec3 viewDirection = -viewDir;\nvec3 mainLightDirection = lightingMainDirection;\nvec3 h = normalize(viewDirection + mainLightDirection);\nPBRShadingInfo inputs;\ninputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\ninputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\ninputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\ninputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\ninputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\nvec3 reflectedView = normalize(reflect(viewDirection, normal));\ninputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\ninputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\ninputs.ssao = ssao;\ninputs.metalness = mrr[0];\ninputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`),c.code.add(r`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\ninputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));\ninputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`),c.code.add(r`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);\nambientDir = ambientDir != vec3(0.0)? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\ninputs.NdotAmbDir = abs(dot(normal, ambientDir));\nvec3 mainLightIrradianceComponent = inputs.NdotL * (1.0 - shadow) * lightingMainIntensity;\nvec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * lightingMainIntensity * fillLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\ninputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\ninputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`),c.code.add(r`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\nvec3 horizonRingH = normalize(viewDirection + horizonRingDir);\ninputs.NdotH_Horizon = dot(normal, horizonRingH);\nvec3 mainLightRadianceComponent = normalDistribution(inputs.NdotH, inputs.roughness) * lightingMainIntensity * (1.0 - shadow);\nvec3 horizonLightRadianceComponent = normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * lightingMainIntensity * fillLightIntensity;\nvec3 ambientLightRadianceComponent = calculateAmbientRadiance(ssao) + additionalLight;\ninputs.skyRadianceToSurface = ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\ninputs.groundRadianceToSurface = GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\ninputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`),c.code.add(r`\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        ${2===d.pbrMode?r`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));`:r`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));`}\n        return outColor;\n      }\n    `))}export{l as EvaluateSceneLighting};\n"]},"metadata":{},"sourceType":"module"}