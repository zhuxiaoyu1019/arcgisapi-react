{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { Slice as e } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { Transform as o } from \"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";\nimport { VertexTangent as r } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTangent.glsl.js\";\nimport { OutputDepth as a } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";\nimport { OutputHighlight as i } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";\nimport { EvaluateSceneLighting as l } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js\";\nimport { NormalUtils as t } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js\";\nimport { Overlay as n } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js\";\nimport { Skirts as v } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/Skirts.glsl.js\";\nimport { TerrainTexture as s } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/TerrainTexture.glsl.js\";\nimport { HeaderComment as d } from \"../views/3d/webgl-engine/core/shaderLibrary/util/HeaderComment.glsl.js\";\nimport { glsl as c } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as m } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\n\nfunction g(g) {\n  const p = new m();\n\n  if (p.include(d, {\n    name: \"Terrain Shader\",\n    output: g.output\n  }), p.include(v), p.attributes.add(\"position\", \"vec3\"), p.attributes.add(\"uv0\", \"vec2\"), p.vertex.uniforms.add(\"proj\", \"mat4\").add(\"view\", \"mat4\").add(\"origin\", \"vec3\").add(\"skirtScale\", \"float\"), 0 === g.output) {\n    p.include(o, {\n      linearDepth: !1\n    }), p.include(t, g), p.include(s, g);\n    const a = 0 !== g.overlayMode,\n          i = 2 === g.overlayMode;\n    a && p.include(n, {\n      pbrMode: 3,\n      useCustomDTRExponentForWater: !1,\n      ssrEnabled: g.ssrEnabled,\n      highStepCount: g.highStepCount\n    }), i && p.include(r, g), p.varyings.add(\"vnormal\", \"vec3\"), p.varyings.add(\"vpos\", \"vec3\"), p.vertex.uniforms.add(\"viewNormal\", \"mat4\"), g.receiveShadows && p.varyings.add(\"linearDepth\", \"float\"), g.tileBorders && p.varyings.add(\"vuv\", \"vec2\"), g.atmosphere && (p.vertex.uniforms.add(\"lightingMainDirection\", \"vec3\"), p.varyings.add(\"wnormal\", \"vec3\"), p.varyings.add(\"wlight\", \"vec3\")), g.screenSizePerspective && (p.vertex.uniforms.add(\"screenSizePerspective\", \"vec4\"), p.varyings.add(\"screenSizeDistanceToCamera\", \"float\"), p.varyings.add(\"screenSizeCosAngle\", \"float\")), p.vertex.code.add(c`\n      void main(void) {\n        vpos = position;\n        vnormal = getLocalUp(vpos, origin);\n\n        vec2 uv = uv0;\n        vpos = applySkirts(uv, vpos, vnormal, skirtScale);\n        ${g.atmosphere ? c`\n        wnormal = (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n        wlight = (view  * vec4(lightingMainDirection, 1.0)).xyz;` : \"\"}\n        ${g.tileBorders ? c`vuv = uv;` : \"\"}\n        ${g.screenSizePerspective ? c`\n        vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;\n        screenSizeDistanceToCamera = length(viewPos);\n        vec3 viewSpaceNormal = (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n        screenSizeCosAngle = abs(viewSpaceNormal.z);` : \"\"}\n        gl_Position = transformPosition(proj, view, vpos);\n        ${g.receiveShadows ? c`linearDepth = gl_Position.w;` : \"\"}\n        forwardTextureCoordinates(uv);\n        ${a ? c`setOverlayVTC(uv);` : \"\"}\n        ${i ? c`forwardVertexTangent(vnormal);` : c``}\n      }\n    `), p.extensions.add(\"GL_OES_standard_derivatives\"), p.extensions.add(\"GL_EXT_shader_texture_lod\"), p.include(e, g), p.include(l, g), p.fragment.uniforms.add(\"camPos\", \"vec3\").add(\"viewDirection\", \"vec3\").add(\"ssaoTex\", \"sampler2D\").add(\"viewportPixelSz\", \"vec4\").add(\"opacity\", \"float\"), g.screenSizePerspective && p.fragment.uniforms.add(\"screenSizePerspective\", \"vec4\"), i && (p.fragment.uniforms.add(\"ovWaterTex\", \"sampler2D\"), p.fragment.uniforms.add(\"view\", \"mat4\")), p.fragment.code.add(c`const vec3 ambient = vec3(0.2, 0.2, 0.2);\nconst vec3 diffuse = vec3(0.8, 0.8, 0.8);\nconst float diffuseHardness = 2.5;\nconst float sliceOpacity = 0.2;\nfloat lum(vec3 c) {\nfloat max = max(max(c.r, c.g), c.b);\nfloat min = min(min(c.r, c.g), c.b);\nreturn (min + max) * 0.5;\n}`), g.atmosphere && p.fragment.code.add(c`vec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\nvec3 surfaceColor   = vec3(0.0);\nvec3 fuzzySpecColor = vec3(1.0);\nvec3 subColor       = vec3(0.0);\nfloat rollOff       = 1.0;\nvec3 Ln = normalize(lightPos);\nvec3 Nn = normalize(normal);\nvec3 Hn = normalize(view + Ln);\nfloat ldn = dot(Ln, Nn);\nfloat diffComp = max(0.0, ldn);\nfloat vdn = clamp(1.0 - dot(view, Nn), 0.0, 1.0);\nfloat ndv = dot(view, Ln);\nvec3 diffContrib = surfaceColor * diffComp;\nfloat subLamb = max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\nvec3 subContrib = subLamb * subColor;\nvec3 vecColor = vec3(vdn);\nvec3 diffuseContrib = (subContrib + diffContrib);\nvec3 specularContrib = (vecColor * fuzzySpecColor);\nreturn (diffContrib + specularContrib) * rollOff;\n}`), p.fragment.code.add(c`\n      void main() {\n        ${g.receiveShadows ? c`float shadow = readShadowMap(vpos, linearDepth);` : c`float shadow = 0.0;`}\n        float vndl = dot(normalize(vnormal), lightingMainDirection);\n        float k = smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n        vec3 d = (1.0 - shadow/1.8) * diffuse * k;\n\n        float ssao = viewportPixelSz.w < .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        vec4 tileColor = getTileColor() * opacity;\n        ${a ? c`\n            vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);\n            vec4 overlayColor = overlayOpacity * overlayColorOpaque;\n            vec4 groundColor = tileColor;\n            tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;` : \"\"}\n        if (rejectBySlice(vpos)) {\n          tileColor *= sliceOpacity;\n        }\n        vec3 atm = vec3(0.0);\n        ${g.atmosphere ? c`\n            float ndotl = max(0.0, min(1.0, vndl));\n            atm = atmosphere(wlight, wnormal, -viewDirection);\n            atm *= max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5))); //avoid atmosphere on bright base maps\n            atm *= max(0.0, min(1.0, ndotl*2.0)); // avoid atmosphere on dark side of the globe\n            atm *= tileColor.a; // premultiply with tile alpha` : \"\"}\n        vec3 albedo = atm + tileColor.rgb;\n        vec3 normal = normalize(vnormal);\n\n        // heuristic shading function used in the old terrain, now used to add ambient lighting\n        float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n        gl_FragColor = vec4(evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\n        ${i ? c`\n            vec4 overlayWaterMask = getOverlayColor(ovWaterTex, vtcOverlay);\n            float waterNormalLength = length(overlayWaterMask);\n            if (waterNormalLength > 0.95) {\n              mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);\n              vec4 waterOverlayColor = vec4(overlayColor.w > 0.0 ? overlayColorOpaque.xyz/overlayColor.w : vec3(1.0), overlayColor.w);\n              vec4 viewPosition = view*vec4(vpos, 1.0);\n              vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vpos - camPos), shadow, vnormal, tbnMatrix, viewPosition.xyz);\n              vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));\n              // un-gamma the ground color to mix in linear space\n              gl_FragColor = mix(groundColor, waterColorNonLinear, waterColorLinear.w);\n            }` : \"\"}\n        ${g.screenSizePerspective ? c`\n          float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n          if (perspectiveScale <= 0.25) {\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n          }\n          else if (perspectiveScale <= 0.5) {\n            gl_FragColor = mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n          }\n          else if (perspectiveScale >= 0.99) {\n            gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n          }\n          else {\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n          }` : \"\"}\n        ${g.tileBorders ? c`\n            vec2 dVuv = fwidth(vuv);\n            vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv, 1.0 - vuv));\n            float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);` : \"\"}\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    `);\n  }\n\n  return 1 !== g.output && 3 !== g.output || (p.include(o, {\n    linearDepth: !0\n  }), p.include(a, {\n    output: g.output\n  }), p.include(t, g), p.varyings.add(\"linearDepth\", \"float\"), p.vertex.uniforms.add(\"nearFar\", \"vec2\"), p.vertex.code.add(c`void main(void) {\nvec3 normal = getLocalUp(position, origin);\nvec2 uv = uv0;\nvec3 vpos = applySkirts(uv, position, normal.xyz, skirtScale);\ngl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);\n}`), p.fragment.code.add(c`void main() {\noutputDepth(linearDepth);\n}`)), 2 === g.output && (p.include(o, {\n    linearDepth: !1\n  }), p.include(t, g), p.varyings.add(\"vnormal\", \"vec3\"), p.varyings.add(\"vpos\", \"vec3\"), p.vertex.uniforms.add(\"viewNormal\", \"mat4\"), p.vertex.code.add(c`void main(void) {\nvec3 normal = getLocalUp(position, origin);\nvec2 uv = uv0;\nvpos = applySkirts(uv, position, normal, skirtScale);\ngl_Position = transformPosition(proj, view, vpos);\nvnormal = normalize((viewNormal * vec4(normal, 1.0)).xyz);\n}`), p.fragment.code.add(c`void main() {\nvec3 normal = normalize(vnormal);\nif (gl_FrontFacing == false) {\nnormal = -normal;\n}\ngl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 0.0);\n}`)), 4 === g.output && (p.include(o, {\n    linearDepth: !1\n  }), p.include(t, g), p.include(n, {\n    pbrMode: 0\n  }), p.vertex.code.add(c`void main() {\nvec3 vnormal = getLocalUp(position, origin);\nvec2 uv = uv0;\nvec3 vpos = applySkirts(uv, position, vnormal, skirtScale);\nsetOverlayVTC(uv);\ngl_Position = transformPosition(proj, view, vpos);\n}`), p.include(i), p.fragment.code.add(c`void main() {\nvec4 overlayColor = getCombinedOverlayColor();\nif (overlayColor.a == 0.0) {\ngl_FragColor = vec4(0.0);\nreturn;\n}\noutputHighlight();\n}`)), p;\n}\n\nvar p = Object.freeze({\n  __proto__: null,\n  build: g\n});\nexport { p as T, g as b };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgis-api-react/node_modules/@arcgis/core/chunks/Terrain.glsl.js"],"names":["Slice","e","Transform","o","VertexTangent","r","OutputDepth","a","OutputHighlight","i","EvaluateSceneLighting","l","NormalUtils","t","Overlay","n","Skirts","v","TerrainTexture","s","HeaderComment","d","glsl","c","ShaderBuilder","m","g","p","include","name","output","attributes","add","vertex","uniforms","linearDepth","overlayMode","pbrMode","useCustomDTRExponentForWater","ssrEnabled","highStepCount","varyings","receiveShadows","tileBorders","atmosphere","screenSizePerspective","code","extensions","fragment","Object","freeze","__proto__","build","T","b"],"mappings":"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B,CAAC,KAAGkB,CAAC,CAACqB,QAAF,CAAWd,QAAX,CAAoBF,GAApB,CAAwB,YAAxB,EAAqC,WAArC,GAAkDL,CAAC,CAACqB,QAAF,CAAWd,QAAX,CAAoBF,GAApB,CAAwB,MAAxB,EAA+B,MAA/B,CAArD,CAtB+xC,EAsBlsCL,CAAC,CAACqB,QAAF,CAAWF,IAAX,CAAgBd,GAAhB,CAAoBT,CAAE;AAC7d;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EARuc,CAtBksC,EA8BroDG,CAAC,CAACkB,UAAF,IAAcjB,CAAC,CAACqB,QAAF,CAAWF,IAAX,CAAgBd,GAAhB,CAAoBT,CAAE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAnBkB,CA9BunD,EAiDroDI,CAAC,CAACqB,QAAF,CAAWF,IAAX,CAAgBd,GAAhB,CAAoBT,CAAE;AAC1B;AACA,UAAUG,CAAC,CAACgB,cAAF,GAAiBnB,CAAE,kDAAnB,GAAqEA,CAAE,qBAAqB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,UAAUhB,CAAC,GAACgB,CAAE;AACd;AACA;AACA;AACA,2EAJW,GAIiE,EAAG;AAC/E;AACA;AACA;AACA;AACA,UAAUG,CAAC,CAACkB,UAAF,GAAarB,CAAE;AACzB;AACA;AACA;AACA;AACA,+DALU,GAKsD,EAAG;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAUd,CAAC,GAACc,CAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAXW,GAWI,EAAG;AAClB,UAAUG,CAAC,CAACmB,qBAAF,GAAwBtB,CAAE;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAbU,GAaG,EAAG;AAChB,UAAUG,CAAC,CAACiB,WAAF,GAAcpB,CAAE;AAC1B;AACA;AACA;AACA,oFAJU,GAI2E,EAAG;AACxF;AACA;AACA,KAjEI,CAjDqoD;AAkHloD;;AAAA,SAAO,MAAIG,CAAC,CAACI,MAAN,IAAc,MAAIJ,CAAC,CAACI,MAApB,KAA6BH,CAAC,CAACC,OAAF,CAAUzB,CAAV,EAAY;AAACgC,IAAAA,WAAW,EAAC,CAAC;AAAd,GAAZ,GAA8BR,CAAC,CAACC,OAAF,CAAUrB,CAAV,EAAY;AAACuB,IAAAA,MAAM,EAACJ,CAAC,CAACI;AAAV,GAAZ,CAA9B,EAA6DH,CAAC,CAACC,OAAF,CAAUf,CAAV,EAAYa,CAAZ,CAA7D,EAA4EC,CAAC,CAACc,QAAF,CAAWT,GAAX,CAAe,aAAf,EAA6B,OAA7B,CAA5E,EAAkHL,CAAC,CAACM,MAAF,CAASC,QAAT,CAAkBF,GAAlB,CAAsB,SAAtB,EAAgC,MAAhC,CAAlH,EAA0JL,CAAC,CAACM,MAAF,CAASa,IAAT,CAAcd,GAAd,CAAkBT,CAAE;AACzN;AACA;AACA;AACA;AACA,EALqM,CAA1J,EAKvCI,CAAC,CAACqB,QAAF,CAAWF,IAAX,CAAgBd,GAAhB,CAAoBT,CAAE;AAC1B;AACA,EAFI,CALU,GAOT,MAAIG,CAAC,CAACI,MAAN,KAAeH,CAAC,CAACC,OAAF,CAAUzB,CAAV,EAAY;AAACgC,IAAAA,WAAW,EAAC,CAAC;AAAd,GAAZ,GAA8BR,CAAC,CAACC,OAAF,CAAUf,CAAV,EAAYa,CAAZ,CAA9B,EAA6CC,CAAC,CAACc,QAAF,CAAWT,GAAX,CAAe,SAAf,EAAyB,MAAzB,CAA7C,EAA8EL,CAAC,CAACc,QAAF,CAAWT,GAAX,CAAe,MAAf,EAAsB,MAAtB,CAA9E,EAA4GL,CAAC,CAACM,MAAF,CAASC,QAAT,CAAkBF,GAAlB,CAAsB,YAAtB,EAAmC,MAAnC,CAA5G,EAAuJL,CAAC,CAACM,MAAF,CAASa,IAAT,CAAcd,GAAd,CAAkBT,CAAE;AAC/L;AACA;AACA;AACA;AACA;AACA,EAN2K,CAAvJ,EAMhBI,CAAC,CAACqB,QAAF,CAAWF,IAAX,CAAgBd,GAAhB,CAAoBT,CAAE;AAC1B;AACA;AACA;AACA;AACA;AACA,EANI,CANC,CAPS,EAmBT,MAAIG,CAAC,CAACI,MAAN,KAAeH,CAAC,CAACC,OAAF,CAAUzB,CAAV,EAAY;AAACgC,IAAAA,WAAW,EAAC,CAAC;AAAd,GAAZ,GAA8BR,CAAC,CAACC,OAAF,CAAUf,CAAV,EAAYa,CAAZ,CAA9B,EAA6CC,CAAC,CAACC,OAAF,CAAUb,CAAV,EAAY;AAACsB,IAAAA,OAAO,EAAC;AAAT,GAAZ,CAA7C,EAAsEV,CAAC,CAACM,MAAF,CAASa,IAAT,CAAcd,GAAd,CAAkBT,CAAE;AAC9G;AACA;AACA;AACA;AACA;AACA,EAN0F,CAAtE,EAMhBI,CAAC,CAACC,OAAF,CAAUnB,CAAV,CANgB,EAMHkB,CAAC,CAACqB,QAAF,CAAWF,IAAX,CAAgBd,GAAhB,CAAoBT,CAAE;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,EAPiB,CANZ,CAnBS,EAgCTI,CAhCE;AAgCA;;AAAA,IAAIA,CAAC,GAACsB,MAAM,CAACC,MAAP,CAAc;AAACC,EAAAA,SAAS,EAAC,IAAX;AAAgBC,EAAAA,KAAK,EAAC1B;AAAtB,CAAd,CAAN;AAA8C,SAAOC,CAAC,IAAI0B,CAAZ,EAAc3B,CAAC,IAAI4B,CAAnB","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{Slice as e}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{Transform as o}from\"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";import{VertexTangent as r}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTangent.glsl.js\";import{OutputDepth as a}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{OutputHighlight as i}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";import{EvaluateSceneLighting as l}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js\";import{NormalUtils as t}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js\";import{Overlay as n}from\"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js\";import{Skirts as v}from\"../views/3d/webgl-engine/core/shaderLibrary/terrain/Skirts.glsl.js\";import{TerrainTexture as s}from\"../views/3d/webgl-engine/core/shaderLibrary/terrain/TerrainTexture.glsl.js\";import{HeaderComment as d}from\"../views/3d/webgl-engine/core/shaderLibrary/util/HeaderComment.glsl.js\";import{glsl as c}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as m}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";function g(g){const p=new m;if(p.include(d,{name:\"Terrain Shader\",output:g.output}),p.include(v),p.attributes.add(\"position\",\"vec3\"),p.attributes.add(\"uv0\",\"vec2\"),p.vertex.uniforms.add(\"proj\",\"mat4\").add(\"view\",\"mat4\").add(\"origin\",\"vec3\").add(\"skirtScale\",\"float\"),0===g.output){p.include(o,{linearDepth:!1}),p.include(t,g),p.include(s,g);const a=0!==g.overlayMode,i=2===g.overlayMode;a&&p.include(n,{pbrMode:3,useCustomDTRExponentForWater:!1,ssrEnabled:g.ssrEnabled,highStepCount:g.highStepCount}),i&&p.include(r,g),p.varyings.add(\"vnormal\",\"vec3\"),p.varyings.add(\"vpos\",\"vec3\"),p.vertex.uniforms.add(\"viewNormal\",\"mat4\"),g.receiveShadows&&p.varyings.add(\"linearDepth\",\"float\"),g.tileBorders&&p.varyings.add(\"vuv\",\"vec2\"),g.atmosphere&&(p.vertex.uniforms.add(\"lightingMainDirection\",\"vec3\"),p.varyings.add(\"wnormal\",\"vec3\"),p.varyings.add(\"wlight\",\"vec3\")),g.screenSizePerspective&&(p.vertex.uniforms.add(\"screenSizePerspective\",\"vec4\"),p.varyings.add(\"screenSizeDistanceToCamera\",\"float\"),p.varyings.add(\"screenSizeCosAngle\",\"float\")),p.vertex.code.add(c`\n      void main(void) {\n        vpos = position;\n        vnormal = getLocalUp(vpos, origin);\n\n        vec2 uv = uv0;\n        vpos = applySkirts(uv, vpos, vnormal, skirtScale);\n        ${g.atmosphere?c`\n        wnormal = (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n        wlight = (view  * vec4(lightingMainDirection, 1.0)).xyz;`:\"\"}\n        ${g.tileBorders?c`vuv = uv;`:\"\"}\n        ${g.screenSizePerspective?c`\n        vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;\n        screenSizeDistanceToCamera = length(viewPos);\n        vec3 viewSpaceNormal = (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n        screenSizeCosAngle = abs(viewSpaceNormal.z);`:\"\"}\n        gl_Position = transformPosition(proj, view, vpos);\n        ${g.receiveShadows?c`linearDepth = gl_Position.w;`:\"\"}\n        forwardTextureCoordinates(uv);\n        ${a?c`setOverlayVTC(uv);`:\"\"}\n        ${i?c`forwardVertexTangent(vnormal);`:c``}\n      }\n    `),p.extensions.add(\"GL_OES_standard_derivatives\"),p.extensions.add(\"GL_EXT_shader_texture_lod\"),p.include(e,g),p.include(l,g),p.fragment.uniforms.add(\"camPos\",\"vec3\").add(\"viewDirection\",\"vec3\").add(\"ssaoTex\",\"sampler2D\").add(\"viewportPixelSz\",\"vec4\").add(\"opacity\",\"float\"),g.screenSizePerspective&&p.fragment.uniforms.add(\"screenSizePerspective\",\"vec4\"),i&&(p.fragment.uniforms.add(\"ovWaterTex\",\"sampler2D\"),p.fragment.uniforms.add(\"view\",\"mat4\")),p.fragment.code.add(c`const vec3 ambient = vec3(0.2, 0.2, 0.2);\nconst vec3 diffuse = vec3(0.8, 0.8, 0.8);\nconst float diffuseHardness = 2.5;\nconst float sliceOpacity = 0.2;\nfloat lum(vec3 c) {\nfloat max = max(max(c.r, c.g), c.b);\nfloat min = min(min(c.r, c.g), c.b);\nreturn (min + max) * 0.5;\n}`),g.atmosphere&&p.fragment.code.add(c`vec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\nvec3 surfaceColor   = vec3(0.0);\nvec3 fuzzySpecColor = vec3(1.0);\nvec3 subColor       = vec3(0.0);\nfloat rollOff       = 1.0;\nvec3 Ln = normalize(lightPos);\nvec3 Nn = normalize(normal);\nvec3 Hn = normalize(view + Ln);\nfloat ldn = dot(Ln, Nn);\nfloat diffComp = max(0.0, ldn);\nfloat vdn = clamp(1.0 - dot(view, Nn), 0.0, 1.0);\nfloat ndv = dot(view, Ln);\nvec3 diffContrib = surfaceColor * diffComp;\nfloat subLamb = max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\nvec3 subContrib = subLamb * subColor;\nvec3 vecColor = vec3(vdn);\nvec3 diffuseContrib = (subContrib + diffContrib);\nvec3 specularContrib = (vecColor * fuzzySpecColor);\nreturn (diffContrib + specularContrib) * rollOff;\n}`),p.fragment.code.add(c`\n      void main() {\n        ${g.receiveShadows?c`float shadow = readShadowMap(vpos, linearDepth);`:c`float shadow = 0.0;`}\n        float vndl = dot(normalize(vnormal), lightingMainDirection);\n        float k = smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n        vec3 d = (1.0 - shadow/1.8) * diffuse * k;\n\n        float ssao = viewportPixelSz.w < .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        vec4 tileColor = getTileColor() * opacity;\n        ${a?c`\n            vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);\n            vec4 overlayColor = overlayOpacity * overlayColorOpaque;\n            vec4 groundColor = tileColor;\n            tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;`:\"\"}\n        if (rejectBySlice(vpos)) {\n          tileColor *= sliceOpacity;\n        }\n        vec3 atm = vec3(0.0);\n        ${g.atmosphere?c`\n            float ndotl = max(0.0, min(1.0, vndl));\n            atm = atmosphere(wlight, wnormal, -viewDirection);\n            atm *= max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5))); //avoid atmosphere on bright base maps\n            atm *= max(0.0, min(1.0, ndotl*2.0)); // avoid atmosphere on dark side of the globe\n            atm *= tileColor.a; // premultiply with tile alpha`:\"\"}\n        vec3 albedo = atm + tileColor.rgb;\n        vec3 normal = normalize(vnormal);\n\n        // heuristic shading function used in the old terrain, now used to add ambient lighting\n        float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n        gl_FragColor = vec4(evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\n        ${i?c`\n            vec4 overlayWaterMask = getOverlayColor(ovWaterTex, vtcOverlay);\n            float waterNormalLength = length(overlayWaterMask);\n            if (waterNormalLength > 0.95) {\n              mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);\n              vec4 waterOverlayColor = vec4(overlayColor.w > 0.0 ? overlayColorOpaque.xyz/overlayColor.w : vec3(1.0), overlayColor.w);\n              vec4 viewPosition = view*vec4(vpos, 1.0);\n              vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vpos - camPos), shadow, vnormal, tbnMatrix, viewPosition.xyz);\n              vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));\n              // un-gamma the ground color to mix in linear space\n              gl_FragColor = mix(groundColor, waterColorNonLinear, waterColorLinear.w);\n            }`:\"\"}\n        ${g.screenSizePerspective?c`\n          float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n          if (perspectiveScale <= 0.25) {\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n          }\n          else if (perspectiveScale <= 0.5) {\n            gl_FragColor = mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n          }\n          else if (perspectiveScale >= 0.99) {\n            gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n          }\n          else {\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n          }`:\"\"}\n        ${g.tileBorders?c`\n            vec2 dVuv = fwidth(vuv);\n            vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv, 1.0 - vuv));\n            float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);`:\"\"}\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    `)}return 1!==g.output&&3!==g.output||(p.include(o,{linearDepth:!0}),p.include(a,{output:g.output}),p.include(t,g),p.varyings.add(\"linearDepth\",\"float\"),p.vertex.uniforms.add(\"nearFar\",\"vec2\"),p.vertex.code.add(c`void main(void) {\nvec3 normal = getLocalUp(position, origin);\nvec2 uv = uv0;\nvec3 vpos = applySkirts(uv, position, normal.xyz, skirtScale);\ngl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);\n}`),p.fragment.code.add(c`void main() {\noutputDepth(linearDepth);\n}`)),2===g.output&&(p.include(o,{linearDepth:!1}),p.include(t,g),p.varyings.add(\"vnormal\",\"vec3\"),p.varyings.add(\"vpos\",\"vec3\"),p.vertex.uniforms.add(\"viewNormal\",\"mat4\"),p.vertex.code.add(c`void main(void) {\nvec3 normal = getLocalUp(position, origin);\nvec2 uv = uv0;\nvpos = applySkirts(uv, position, normal, skirtScale);\ngl_Position = transformPosition(proj, view, vpos);\nvnormal = normalize((viewNormal * vec4(normal, 1.0)).xyz);\n}`),p.fragment.code.add(c`void main() {\nvec3 normal = normalize(vnormal);\nif (gl_FrontFacing == false) {\nnormal = -normal;\n}\ngl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 0.0);\n}`)),4===g.output&&(p.include(o,{linearDepth:!1}),p.include(t,g),p.include(n,{pbrMode:0}),p.vertex.code.add(c`void main() {\nvec3 vnormal = getLocalUp(position, origin);\nvec2 uv = uv0;\nvec3 vpos = applySkirts(uv, position, vnormal, skirtScale);\nsetOverlayVTC(uv);\ngl_Position = transformPosition(proj, view, vpos);\n}`),p.include(i),p.fragment.code.add(c`void main() {\nvec4 overlayColor = getCombinedOverlayColor();\nif (overlayColor.a == 0.0) {\ngl_FragColor = vec4(0.0);\nreturn;\n}\noutputHighlight();\n}`)),p}var p=Object.freeze({__proto__:null,build:g});export{p as T,g as b};\n"]},"metadata":{},"sourceType":"module"}