{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { BasicGrid as a } from \"../views/3d/webgl-engine/core/shaderLibrary/raster/BasicGrid.glsl.js\";\nimport { Colormap as e } from \"../views/3d/webgl-engine/core/shaderLibrary/raster/Colormap.glsl.js\";\nimport { Common as t } from \"../views/3d/webgl-engine/core/shaderLibrary/raster/Common.glsl.js\";\nimport { ColorConversion as o } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { glsl as l } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as i } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\n\nfunction r(o) {\n  const l = new i();\n  return l.include(a), l.include(t), l.include(e), 0 === o.output ? n(l, o.applyColormap) : 1 === o.output ? u(l) : 2 === o.output && f(l, o.applyColormap), l;\n}\n\nfunction u(a) {\n  a.fragment.code.add(l`void main() {\nvec2 pixelLocation = getPixelLocation(v_texcoord);\nif (isOutside(pixelLocation)) {\ngl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\nreturn;\n}\nvec4 currentPixel = getPixel(pixelLocation);\ngl_FragColor = colormap(currentPixel, true);\n}`);\n}\n\nfunction n(a, e) {\n  a.fragment.uniforms.add(\"u_bandCount\", \"int\"), a.fragment.uniforms.add(\"u_minCutOff\", \"float\", 3), a.fragment.uniforms.add(\"u_maxCutOff\", \"float\", 3), a.fragment.uniforms.add(\"u_factor\", \"float\", 3), a.fragment.uniforms.add(\"u_minOutput\", \"float\"), a.fragment.uniforms.add(\"u_maxOutput\", \"float\"), a.fragment.uniforms.add(\"u_useGamma\", \"bool\"), a.fragment.uniforms.add(\"u_gamma\", \"float\", 3), a.fragment.uniforms.add(\"u_gammaCorrection\", \"float\", 3), a.fragment.code.add(l`float stretchOneValue(float val, float minCutOff, float maxCutOff, float minOutput, float maxOutput, float factor, bool useGamma, float gamma, float gammaCorrection) {\nif (val >= maxCutOff) {\nreturn maxOutput;\n} else if (val <= minCutOff) {\nreturn minOutput;\n}\nfloat stretchedVal;\nif (useGamma) {\nfloat tempf = 1.0;\nfloat outRange = maxOutput - minOutput;\nfloat relativeVal = (val - minCutOff) / (maxCutOff - minCutOff);\nif (gamma > 1.0) {\ntempf -= pow(1.0 / outRange, relativeVal * gammaCorrection);\n}\nstretchedVal = (tempf * outRange * pow(relativeVal, 1.0 / gamma) + minOutput) / 255.0;\n} else {\nstretchedVal = minOutput + (val - minCutOff) * factor;\n}\nreturn stretchedVal;\n}`);\n  const t = e ? l`gl_FragColor = colormap(vec4(grayVal, grayVal, grayVal, currentPixel.a), !u_useGamma);` : l`gl_FragColor = vec4(grayVal, grayVal, grayVal, 1.0) * currentPixel.a * u_opacity;`;\n  a.fragment.code.add(l`\n      void main() {\n        vec2 pixelLocation = getPixelLocation(v_texcoord);\n        if (isOutside(pixelLocation)) {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n          return;\n        }\n\n        vec4 currentPixel = getPixel(pixelLocation);\n        if (currentPixel.a == 0.0) {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n          return;\n        }\n\n        if (u_bandCount == 1) {\n          float grayVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          ${t}\n        } else {\n          float redVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          float greenVal = stretchOneValue(currentPixel.g, u_minCutOff[1], u_maxCutOff[1], u_minOutput, u_maxOutput, u_factor[1], u_useGamma, u_gamma[1], u_gammaCorrection[1]);\n          float blueVal = stretchOneValue(currentPixel.b, u_minCutOff[2], u_maxCutOff[2], u_minOutput, u_maxOutput, u_factor[2], u_useGamma, u_gamma[2], u_gammaCorrection[2]);\n          gl_FragColor = vec4(redVal, greenVal, blueVal, 1.0) * currentPixel.a * u_opacity;\n        }\n      }\n    `);\n}\n\nfunction f(a, e) {\n  a.fragment.uniforms.add(\"u_hillshadeType\", \"int\"), a.fragment.uniforms.add(\"u_sinZcosAs\", \"float\", 6), a.fragment.uniforms.add(\"u_sinZsinAs\", \"float\", 6), a.fragment.uniforms.add(\"u_cosZs\", \"float\", 6), a.fragment.uniforms.add(\"u_weights\", \"float\", 6), a.fragment.uniforms.add(\"u_factor\", \"vec2\"), a.fragment.uniforms.add(\"u_applyColormap\", \"bool\"), a.fragment.uniforms.add(\"u_minValue\", \"float\"), a.fragment.uniforms.add(\"u_maxValue\", \"float\"), a.fragment.uniforms.add(\"u_srcImageSize\", \"vec2\"), a.fragment.include(o), a.fragment.code.add(l`vec4 overlay(float val, float minValue, float maxValue, float hillshade, float alpha) {\nval = clamp((val - minValue) / (maxValue - minValue), 0.0, 1.0);\nvec4 rgb = colormap(vec4(val, val, val, 1.0), false);\nvec3 hsv = rgb2hsv(rgb.xyz);\nhsv.z = hillshade;\nreturn vec4(hsv2rgb(hsv) * alpha, alpha);\n}`), a.fragment.code.add(l`float getNeighborHoodAlpha(float a, float b, float c, float d, float e, float f, float g, float h, float i){\nif (a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0) {\nreturn 0.0;\n}  else {\nreturn e;\n}\n}`);\n  const t = e ? l`gl_FragColor = overlay(ve.r, u_minValue, u_maxValue, hillshade, alpha);` : l`hillshade *= alpha;\ngl_FragColor = vec4(hillshade, hillshade, hillshade, alpha);`;\n  a.fragment.code.add(l`\n    void main() {\n      vec2 pixelLocation = getPixelLocation(v_texcoord);\n      if (isOutside(pixelLocation)) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n      }\n\n      vec4 currentPixel = getPixel(pixelLocation);\n      if (currentPixel.a == 0.0) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n      }\n\n      //mirror edge pixels\n      vec2 axy = vec2(-1.0, -1.0);\n      vec2 bxy = vec2(0.0, -1.0);\n      vec2 cxy = vec2(1.0, -1.0);\n      vec2 dxy = vec2(-1.0, 0.0);\n      vec2 fxy = vec2(1.0, 0.0);\n      vec2 gxy = vec2(-1.0, 1.0);\n      vec2 hxy = vec2(0.0, 1.0);\n      vec2 ixy = vec2(1.0, 1.0);\n      vec2 onePixel = 1.0 / u_srcImageSize;\n      if (pixelLocation.s < onePixel.s) {\n        axy[0] = 1.0;\n        dxy[0] = 1.0;\n        gxy[0] = 1.0;\n      }\n      if (pixelLocation.t < onePixel.t) {\n        axy[1] = 1.0;\n        bxy[1] = 1.0;\n        cxy[1] = 1.0;\n      }\n      if (pixelLocation.s > 1.0 - onePixel.s) {\n        cxy[0] = -1.0;\n        fxy[0] = -1.0;\n        ixy[0] = -1.0;\n      }\n      if (pixelLocation.t > 1.0 - onePixel.t) {\n        gxy[1] = -1.0;\n        hxy[1] = -1.0;\n        ixy[1] = -1.0;\n      }\n\n      // calculate hillshade\n      vec4 va = texture2D(u_image, pixelLocation + onePixel * axy);\n      vec4 vb = texture2D(u_image, pixelLocation + onePixel * bxy);\n      vec4 vc = texture2D(u_image, pixelLocation + onePixel * cxy);\n      vec4 vd = texture2D(u_image, pixelLocation + onePixel * dxy);\n      vec4 ve = texture2D(u_image, pixelLocation);\n      vec4 vf = texture2D(u_image, pixelLocation + onePixel * fxy);\n      vec4 vg = texture2D(u_image, pixelLocation + onePixel * gxy);\n      vec4 vh = texture2D(u_image, pixelLocation + onePixel * hxy);\n      vec4 vi = texture2D(u_image, pixelLocation + onePixel * ixy);\n\n      // calculate the rate of z change along the x, y, and diagonal direction\n      float dzx = (vc + 2.0 * vf + vi - va - 2.0 * vd - vg).r * u_factor.s;\n      float dzy = (vg + 2.0 * vh + vi - va - 2.0 * vb - vc).r * u_factor.t;\n      float dzd = sqrt(1.0 + dzx * dzx + dzy * dzy);\n      float hillshade = 0.0;\n\n      // traditional single light source\n      if (u_hillshadeType == 0){\n        float cosDelta = u_sinZsinAs[0] * dzy - u_sinZcosAs[0] * dzx;\n        float z = (u_cosZs[0] + cosDelta) / dzd;\n        if (z < 0.0)  z = 0.0;\n        hillshade = z;\n      } else {\n        // multi-directional with 6 light sources\n        for (int k = 0; k < 6; k++) {\n        float cosDelta = u_sinZsinAs[k] * dzy - u_sinZcosAs[k] * dzx;\n        float z = (u_cosZs[k] + cosDelta) / dzd;\n        if (z < 0.0) z = 0.0;\n        hillshade = hillshade + z * u_weights[k];\n        if (k == 5) break;\n        }\n      }\n\n      // set color\n      float alpha = getNeighborHoodAlpha(va.a, vb.a, vc.a, vd.a, ve.a, vf.a, vg.a, vh.a, vi.a);\n      alpha *= u_opacity;\n      ${t}\n    }\n  `);\n}\n\nvar c = Object.freeze({\n  __proto__: null,\n  build: r\n});\nexport { c as R, r as b };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgis-api-react/node_modules/@arcgis/core/chunks/RasterColorizer.glsl.js"],"names":["BasicGrid","a","Colormap","e","Common","t","ColorConversion","o","glsl","l","ShaderBuilder","i","r","include","output","n","applyColormap","u","f","fragment","code","add","uniforms","c","Object","freeze","__proto__","build","R","b"],"mappings":"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","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{BasicGrid as a}from\"../views/3d/webgl-engine/core/shaderLibrary/raster/BasicGrid.glsl.js\";import{Colormap as e}from\"../views/3d/webgl-engine/core/shaderLibrary/raster/Colormap.glsl.js\";import{Common as t}from\"../views/3d/webgl-engine/core/shaderLibrary/raster/Common.glsl.js\";import{ColorConversion as o}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{glsl as l}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as i}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";function r(o){const l=new i;return l.include(a),l.include(t),l.include(e),0===o.output?n(l,o.applyColormap):1===o.output?u(l):2===o.output&&f(l,o.applyColormap),l}function u(a){a.fragment.code.add(l`void main() {\nvec2 pixelLocation = getPixelLocation(v_texcoord);\nif (isOutside(pixelLocation)) {\ngl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\nreturn;\n}\nvec4 currentPixel = getPixel(pixelLocation);\ngl_FragColor = colormap(currentPixel, true);\n}`)}function n(a,e){a.fragment.uniforms.add(\"u_bandCount\",\"int\"),a.fragment.uniforms.add(\"u_minCutOff\",\"float\",3),a.fragment.uniforms.add(\"u_maxCutOff\",\"float\",3),a.fragment.uniforms.add(\"u_factor\",\"float\",3),a.fragment.uniforms.add(\"u_minOutput\",\"float\"),a.fragment.uniforms.add(\"u_maxOutput\",\"float\"),a.fragment.uniforms.add(\"u_useGamma\",\"bool\"),a.fragment.uniforms.add(\"u_gamma\",\"float\",3),a.fragment.uniforms.add(\"u_gammaCorrection\",\"float\",3),a.fragment.code.add(l`float stretchOneValue(float val, float minCutOff, float maxCutOff, float minOutput, float maxOutput, float factor, bool useGamma, float gamma, float gammaCorrection) {\nif (val >= maxCutOff) {\nreturn maxOutput;\n} else if (val <= minCutOff) {\nreturn minOutput;\n}\nfloat stretchedVal;\nif (useGamma) {\nfloat tempf = 1.0;\nfloat outRange = maxOutput - minOutput;\nfloat relativeVal = (val - minCutOff) / (maxCutOff - minCutOff);\nif (gamma > 1.0) {\ntempf -= pow(1.0 / outRange, relativeVal * gammaCorrection);\n}\nstretchedVal = (tempf * outRange * pow(relativeVal, 1.0 / gamma) + minOutput) / 255.0;\n} else {\nstretchedVal = minOutput + (val - minCutOff) * factor;\n}\nreturn stretchedVal;\n}`);const t=e?l`gl_FragColor = colormap(vec4(grayVal, grayVal, grayVal, currentPixel.a), !u_useGamma);`:l`gl_FragColor = vec4(grayVal, grayVal, grayVal, 1.0) * currentPixel.a * u_opacity;`;a.fragment.code.add(l`\n      void main() {\n        vec2 pixelLocation = getPixelLocation(v_texcoord);\n        if (isOutside(pixelLocation)) {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n          return;\n        }\n\n        vec4 currentPixel = getPixel(pixelLocation);\n        if (currentPixel.a == 0.0) {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n          return;\n        }\n\n        if (u_bandCount == 1) {\n          float grayVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          ${t}\n        } else {\n          float redVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          float greenVal = stretchOneValue(currentPixel.g, u_minCutOff[1], u_maxCutOff[1], u_minOutput, u_maxOutput, u_factor[1], u_useGamma, u_gamma[1], u_gammaCorrection[1]);\n          float blueVal = stretchOneValue(currentPixel.b, u_minCutOff[2], u_maxCutOff[2], u_minOutput, u_maxOutput, u_factor[2], u_useGamma, u_gamma[2], u_gammaCorrection[2]);\n          gl_FragColor = vec4(redVal, greenVal, blueVal, 1.0) * currentPixel.a * u_opacity;\n        }\n      }\n    `)}function f(a,e){a.fragment.uniforms.add(\"u_hillshadeType\",\"int\"),a.fragment.uniforms.add(\"u_sinZcosAs\",\"float\",6),a.fragment.uniforms.add(\"u_sinZsinAs\",\"float\",6),a.fragment.uniforms.add(\"u_cosZs\",\"float\",6),a.fragment.uniforms.add(\"u_weights\",\"float\",6),a.fragment.uniforms.add(\"u_factor\",\"vec2\"),a.fragment.uniforms.add(\"u_applyColormap\",\"bool\"),a.fragment.uniforms.add(\"u_minValue\",\"float\"),a.fragment.uniforms.add(\"u_maxValue\",\"float\"),a.fragment.uniforms.add(\"u_srcImageSize\",\"vec2\"),a.fragment.include(o),a.fragment.code.add(l`vec4 overlay(float val, float minValue, float maxValue, float hillshade, float alpha) {\nval = clamp((val - minValue) / (maxValue - minValue), 0.0, 1.0);\nvec4 rgb = colormap(vec4(val, val, val, 1.0), false);\nvec3 hsv = rgb2hsv(rgb.xyz);\nhsv.z = hillshade;\nreturn vec4(hsv2rgb(hsv) * alpha, alpha);\n}`),a.fragment.code.add(l`float getNeighborHoodAlpha(float a, float b, float c, float d, float e, float f, float g, float h, float i){\nif (a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0) {\nreturn 0.0;\n}  else {\nreturn e;\n}\n}`);const t=e?l`gl_FragColor = overlay(ve.r, u_minValue, u_maxValue, hillshade, alpha);`:l`hillshade *= alpha;\ngl_FragColor = vec4(hillshade, hillshade, hillshade, alpha);`;a.fragment.code.add(l`\n    void main() {\n      vec2 pixelLocation = getPixelLocation(v_texcoord);\n      if (isOutside(pixelLocation)) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n      }\n\n      vec4 currentPixel = getPixel(pixelLocation);\n      if (currentPixel.a == 0.0) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n      }\n\n      //mirror edge pixels\n      vec2 axy = vec2(-1.0, -1.0);\n      vec2 bxy = vec2(0.0, -1.0);\n      vec2 cxy = vec2(1.0, -1.0);\n      vec2 dxy = vec2(-1.0, 0.0);\n      vec2 fxy = vec2(1.0, 0.0);\n      vec2 gxy = vec2(-1.0, 1.0);\n      vec2 hxy = vec2(0.0, 1.0);\n      vec2 ixy = vec2(1.0, 1.0);\n      vec2 onePixel = 1.0 / u_srcImageSize;\n      if (pixelLocation.s < onePixel.s) {\n        axy[0] = 1.0;\n        dxy[0] = 1.0;\n        gxy[0] = 1.0;\n      }\n      if (pixelLocation.t < onePixel.t) {\n        axy[1] = 1.0;\n        bxy[1] = 1.0;\n        cxy[1] = 1.0;\n      }\n      if (pixelLocation.s > 1.0 - onePixel.s) {\n        cxy[0] = -1.0;\n        fxy[0] = -1.0;\n        ixy[0] = -1.0;\n      }\n      if (pixelLocation.t > 1.0 - onePixel.t) {\n        gxy[1] = -1.0;\n        hxy[1] = -1.0;\n        ixy[1] = -1.0;\n      }\n\n      // calculate hillshade\n      vec4 va = texture2D(u_image, pixelLocation + onePixel * axy);\n      vec4 vb = texture2D(u_image, pixelLocation + onePixel * bxy);\n      vec4 vc = texture2D(u_image, pixelLocation + onePixel * cxy);\n      vec4 vd = texture2D(u_image, pixelLocation + onePixel * dxy);\n      vec4 ve = texture2D(u_image, pixelLocation);\n      vec4 vf = texture2D(u_image, pixelLocation + onePixel * fxy);\n      vec4 vg = texture2D(u_image, pixelLocation + onePixel * gxy);\n      vec4 vh = texture2D(u_image, pixelLocation + onePixel * hxy);\n      vec4 vi = texture2D(u_image, pixelLocation + onePixel * ixy);\n\n      // calculate the rate of z change along the x, y, and diagonal direction\n      float dzx = (vc + 2.0 * vf + vi - va - 2.0 * vd - vg).r * u_factor.s;\n      float dzy = (vg + 2.0 * vh + vi - va - 2.0 * vb - vc).r * u_factor.t;\n      float dzd = sqrt(1.0 + dzx * dzx + dzy * dzy);\n      float hillshade = 0.0;\n\n      // traditional single light source\n      if (u_hillshadeType == 0){\n        float cosDelta = u_sinZsinAs[0] * dzy - u_sinZcosAs[0] * dzx;\n        float z = (u_cosZs[0] + cosDelta) / dzd;\n        if (z < 0.0)  z = 0.0;\n        hillshade = z;\n      } else {\n        // multi-directional with 6 light sources\n        for (int k = 0; k < 6; k++) {\n        float cosDelta = u_sinZsinAs[k] * dzy - u_sinZcosAs[k] * dzx;\n        float z = (u_cosZs[k] + cosDelta) / dzd;\n        if (z < 0.0) z = 0.0;\n        hillshade = hillshade + z * u_weights[k];\n        if (k == 5) break;\n        }\n      }\n\n      // set color\n      float alpha = getNeighborHoodAlpha(va.a, vb.a, vc.a, vd.a, ve.a, vf.a, vg.a, vh.a, vi.a);\n      alpha *= u_opacity;\n      ${t}\n    }\n  `)}var c=Object.freeze({__proto__:null,build:r});export{c as R,r as b};\n"]},"metadata":{},"sourceType":"module"}