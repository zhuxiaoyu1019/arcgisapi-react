{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { ScreenSizePerspective as e } from \"../util/ScreenSizePerspective.glsl.js\";\nimport { glsl as r } from \"../../shaderModules/interfaces.js\";\n\nfunction t(t, l) {\n  const c = t.vertex.code;\n  l.verticalOffsetEnabled ? (t.vertex.uniforms.add(\"verticalOffset\", \"vec4\"), l.screenSizePerspectiveEnabled && (t.include(e), t.vertex.uniforms.add(\"screenSizePerspectiveAlignment\", \"vec4\")), c.add(r`\n    vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);\n      ${1 === l.viewingMode ? r`vec3 worldNormal = normalize(worldPos + localOrigin);` : r`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}\n      ${l.screenSizePerspectiveEnabled ? r`\n          float cosAngle = dot(worldNormal, normalize(worldPos - camPos));\n          float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);` : r`\n          float verticalOffsetScreenHeight = verticalOffset.x;`}\n      // Screen sized offset in world space, used for example for line callouts\n      float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\n      return worldNormal * worldOffset;\n    }\n\n    vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      return worldPos + calculateVerticalOffset(worldPos, localOrigin);\n    }\n    `)) : c.add(r`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`);\n}\n\nfunction l(e, r, t) {\n  if (!r.verticalOffset) return;\n  const l = c(r.verticalOffset, t.camera.fovY, t.camera.fullViewport[3]),\n        i = t.camera.pixelRatio || 1;\n  e.setUniform4f(\"verticalOffset\", l.screenLength * i, l.perDistance, l.minWorldLength, l.maxWorldLength);\n}\n\nfunction c(e, r, t, l = i) {\n  return l.screenLength = e.screenLength, l.perDistance = Math.tan(.5 * r) / (.5 * t), l.minWorldLength = e.minWorldLength, l.maxWorldLength = e.maxWorldLength, l;\n}\n\nconst i = {\n  screenLength: 0,\n  perDistance: 0,\n  minWorldLength: 0,\n  maxWorldLength: 0\n};\nexport { t as VerticalOffset, l as bindVerticalOffsetUniforms, c as calculateVerticalOffsetFactors };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgisapi-react/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl.js"],"names":["ScreenSizePerspective","e","glsl","r","t","l","c","vertex","code","verticalOffsetEnabled","uniforms","add","screenSizePerspectiveEnabled","include","viewingMode","verticalOffset","camera","fovY","fullViewport","i","pixelRatio","setUniform4f","screenLength","perDistance","minWorldLength","maxWorldLength","Math","tan","VerticalOffset","bindVerticalOffsetUniforms","calculateVerticalOffsetFactors"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,qBAAqB,IAAIC,CAAhC,QAAsC,uCAAtC;AAA8E,SAAOC,IAAI,IAAIC,CAAf,QAAqB,mCAArB;;AAAyD,SAASC,CAAT,CAAWA,CAAX,EAAaC,CAAb,EAAe;AAAC,QAAMC,CAAC,GAACF,CAAC,CAACG,MAAF,CAASC,IAAjB;AAAsBH,EAAAA,CAAC,CAACI,qBAAF,IAAyBL,CAAC,CAACG,MAAF,CAASG,QAAT,CAAkBC,GAAlB,CAAsB,gBAAtB,EAAuC,MAAvC,GAA+CN,CAAC,CAACO,4BAAF,KAAiCR,CAAC,CAACS,OAAF,CAAUZ,CAAV,GAAaG,CAAC,CAACG,MAAF,CAASG,QAAT,CAAkBC,GAAlB,CAAsB,gCAAtB,EAAuD,MAAvD,CAA9C,CAA/C,EAA6JL,CAAC,CAACK,GAAF,CAAMR,CAAE;AAC3W;AACA;AACA,QAAQ,MAAIE,CAAC,CAACS,WAAN,GAAkBX,CAAE,uDAApB,GAA2EA,CAAE,yCAAyC;AAC9H,QAAQE,CAAC,CAACO,4BAAF,GAA+BT,CAAE;AACzC;AACA,6JAFQ,GAEsJA,CAAE;AAChK,+DAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAhBmW,CAAtL,IAgBrKG,CAAC,CAACK,GAAF,CAAMR,CAAE,8EAAR,CAhBqK;AAgB9E;;AAAA,SAASE,CAAT,CAAWJ,CAAX,EAAaE,CAAb,EAAeC,CAAf,EAAiB;AAAC,MAAG,CAACD,CAAC,CAACY,cAAN,EAAqB;AAAO,QAAMV,CAAC,GAACC,CAAC,CAACH,CAAC,CAACY,cAAH,EAAkBX,CAAC,CAACY,MAAF,CAASC,IAA3B,EAAgCb,CAAC,CAACY,MAAF,CAASE,YAAT,CAAsB,CAAtB,CAAhC,CAAT;AAAA,QAAmEC,CAAC,GAACf,CAAC,CAACY,MAAF,CAASI,UAAT,IAAqB,CAA1F;AAA4FnB,EAAAA,CAAC,CAACoB,YAAF,CAAe,gBAAf,EAAgChB,CAAC,CAACiB,YAAF,GAAeH,CAA/C,EAAiDd,CAAC,CAACkB,WAAnD,EAA+DlB,CAAC,CAACmB,cAAjE,EAAgFnB,CAAC,CAACoB,cAAlF;AAAkG;;AAAA,SAASnB,CAAT,CAAWL,CAAX,EAAaE,CAAb,EAAeC,CAAf,EAAiBC,CAAC,GAACc,CAAnB,EAAqB;AAAC,SAAOd,CAAC,CAACiB,YAAF,GAAerB,CAAC,CAACqB,YAAjB,EAA8BjB,CAAC,CAACkB,WAAF,GAAcG,IAAI,CAACC,GAAL,CAAS,KAAGxB,CAAZ,KAAgB,KAAGC,CAAnB,CAA5C,EAAkEC,CAAC,CAACmB,cAAF,GAAiBvB,CAAC,CAACuB,cAArF,EAAoGnB,CAAC,CAACoB,cAAF,GAAiBxB,CAAC,CAACwB,cAAvH,EAAsIpB,CAA7I;AAA+I;;AAAA,MAAMc,CAAC,GAAC;AAACG,EAAAA,YAAY,EAAC,CAAd;AAAgBC,EAAAA,WAAW,EAAC,CAA5B;AAA8BC,EAAAA,cAAc,EAAC,CAA7C;AAA+CC,EAAAA,cAAc,EAAC;AAA9D,CAAR;AAAyE,SAAOrB,CAAC,IAAIwB,cAAZ,EAA2BvB,CAAC,IAAIwB,0BAAhC,EAA2DvB,CAAC,IAAIwB,8BAAhE","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{ScreenSizePerspective as e}from\"../util/ScreenSizePerspective.glsl.js\";import{glsl as r}from\"../../shaderModules/interfaces.js\";function t(t,l){const c=t.vertex.code;l.verticalOffsetEnabled?(t.vertex.uniforms.add(\"verticalOffset\",\"vec4\"),l.screenSizePerspectiveEnabled&&(t.include(e),t.vertex.uniforms.add(\"screenSizePerspectiveAlignment\",\"vec4\")),c.add(r`\n    vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);\n      ${1===l.viewingMode?r`vec3 worldNormal = normalize(worldPos + localOrigin);`:r`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}\n      ${l.screenSizePerspectiveEnabled?r`\n          float cosAngle = dot(worldNormal, normalize(worldPos - camPos));\n          float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);`:r`\n          float verticalOffsetScreenHeight = verticalOffset.x;`}\n      // Screen sized offset in world space, used for example for line callouts\n      float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\n      return worldNormal * worldOffset;\n    }\n\n    vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      return worldPos + calculateVerticalOffset(worldPos, localOrigin);\n    }\n    `)):c.add(r`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`)}function l(e,r,t){if(!r.verticalOffset)return;const l=c(r.verticalOffset,t.camera.fovY,t.camera.fullViewport[3]),i=t.camera.pixelRatio||1;e.setUniform4f(\"verticalOffset\",l.screenLength*i,l.perDistance,l.minWorldLength,l.maxWorldLength)}function c(e,r,t,l=i){return l.screenLength=e.screenLength,l.perDistance=Math.tan(.5*r)/(.5*t),l.minWorldLength=e.minWorldLength,l.maxWorldLength=e.maxWorldLength,l}const i={screenLength:0,perDistance:0,minWorldLength:0,maxWorldLength:0};export{t as VerticalOffset,l as bindVerticalOffsetUniforms,c as calculateVerticalOffsetFactors};\n"]},"metadata":{},"sourceType":"module"}