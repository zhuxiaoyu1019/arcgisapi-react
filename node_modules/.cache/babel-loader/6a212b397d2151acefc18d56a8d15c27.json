{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { Slice as e } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { AlignPixel as i } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js\";\nimport { HUD as o } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js\";\nimport { multipassGeometryTest as r } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js\";\nimport { glsl as t } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as n } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\n\nfunction l(l) {\n  const a = new n();\n  return a.include(i), a.include(o, l), a.include(e, l), a.attributes.add(\"uv0\", \"vec2\"), a.vertex.uniforms.add(\"lineSize\", \"float\").add(\"pixelToNDC\", \"vec2\").add(\"borderSize\", \"float\").add(\"screenOffset\", \"vec2\"), a.varyings.add(\"coverageSampling\", \"vec4\"), a.varyings.add(\"lineSizes\", \"vec2\"), l.multipassGeometryEnabled && a.varyings.add(\"depth\", \"float\"), a.vertex.code.add(t`\n    void main(void) {\n      ProjectHUDAux projectAux;\n      vec4 endPoint = projectPositionHUD(projectAux);\n\n      vec3 vpos = projectAux.posModel;\n      if (rejectBySlice(vpos)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n    ${l.occlusionTestEnabled ? t`\n      if (!testVisibilityHUD(endPoint)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }` : \"\"}\n\n    ${l.screenSizePerspectiveEnabled ? t`\n      vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n      vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);\n        ` : t`\n      vec2 screenOffsetScaled = screenOffset;\n        `}\n      // Add view dependent polygon offset to get exact same original starting point. This is mostly\n      // used to get the correct depth value\n      vec3 posView = (view * vec4(position, 1.0)).xyz;\n      ${l.multipassGeometryEnabled ? \"depth = posView.z;\" : \"\"}\n\n      applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);\n      vec4 startPoint = proj * vec4(posView, 1.0);\n      // Apply screen offset to both start and end point\n      vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n      startPoint.xy += screenOffsetNorm * startPoint.w;\n      endPoint.xy += screenOffsetNorm * endPoint.w;\n      // Align start and end to pixel origin\n      vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n      vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n    ${l.depthHudEnabled ? l.depthHudAlignStartEnabled ? t`endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);` : t`startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);` : \"\"}\n      vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n      // The direction of the line in screen space\n      vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n    ${l.screenSizePerspectiveEnabled ? t`\n      float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n      float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\n        ` : t`\n      float lineSizeScaled = lineSize;\n      float borderSizeScaled = borderSize;\n        `}\n      float halfPixelSize = lineSizeScaled * 0.5;\n      // Calculate a pixel offset from the edge of the pixel, s.t. we keep the line aligned\n      // to pixels if it has a full pixel size. Since pixel aligned biases to the bottom-left,\n      // we bias the size to the right (for odd sizes) to balance out the bias. Grow sub-pixel\n      // sizes towards the left or right s.t. there is a smooth transition (e.g. from 2 to 3 px).\n      float halfWholePixelSize = floor(lineSizeScaled) * 0.5;\n      float halfPixelSizeInt = floor(halfWholePixelSize);\n\n      // Sub-pixel offset if we need to grow sub-pixels to the left\n      float subpixelOffset = -fract(lineSizeScaled) * float(halfWholePixelSize > 0.0);\n\n      // Pixel offset aligning to whole pixels and adding subpixel offset if needed\n      float pixelOffset = -halfPixelSizeInt + subpixelOffset;\n\n      // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\n      float padding = 1.0 + borderSizeScaled;\n      vec2 ndcOffset = (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n\n      // Offset x/y from the center of the line in screen space\n      projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n\n      // Compute a coverage varying which we can use in the fragment shader to determine\n      // how much a pixel is actually covered by the line (i.e. to anti alias the line).\n      // This works by computing two coordinates that can be linearly interpolated and then\n      // subtracted to find out how far away from the line edge we are.\n      float edgeDirection = (uv0.x * 2.0 - 1.0);\n\n      float halfBorderSize = 0.5 * borderSizeScaled;\n      float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n      float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n\n      float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n\n      coverageSampling = vec4(\n        // Edge coordinate\n        outerEdgeCoverageSampler,\n\n        // Border edge coordinate\n        outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n\n        // Line offset\n        halfPixelSize - 0.5,\n\n        // Border offset\n        halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n      );\n\n      lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n\n      gl_Position = projectedPosition;\n    }\n  `), a.fragment.uniforms.add(\"color\", \"vec4\"), a.fragment.uniforms.add(\"borderColor\", \"vec4\"), l.multipassGeometryEnabled && (a.fragment.include(r, l), a.fragment.uniforms.add(\"inverseViewport\", \"vec2\")), a.fragment.code.add(t`\n    void main() {\n      ${l.multipassGeometryEnabled ? \"if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }\" : \"\"}\n\n      // Mix between line and border coverage offsets depending on whether we need\n      // a border (based on the sidedness).\n      vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n\n      // Mix between border and line color based on the line coverage (conceptually the line\n      // blends on top of the border background).\n      //\n      // Anti-alias by blending final result using the full (including optional border) coverage\n      // and the color alpha\n      float borderAlpha = color.a * borderColor.a * coverage.y;\n      float colorAlpha = color.a * coverage.x;\n\n      float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n\n    ${l.depthHudEnabled ? t`\n      if (finalAlpha < 0.01) {\n        discard;\n      }\n      ` : t`\n      // Compute the finalRgb, but keep it pre-multiplied (for unpre-multiplied you\n      // need to divide by finalAlpha). We avoid the division here by setting the\n      // appropriate blending function in the material.\n      vec3 finalRgb = mix(borderColor.rgb * borderAlpha, color.rgb, colorAlpha);\n      gl_FragColor = vec4(finalRgb, finalAlpha);\n      `}\n  }\n  `), a;\n}\n\nvar a;\n\nfunction d(e, i, o) {\n  3 === o.length ? e.setUniform4f(i, o[0], o[1], o[2], 1) : e.setUniform4fv(i, o);\n}\n\n!function (e) {\n  function i(e, i, o) {\n    d(e, \"color\", i.color), e.setUniform1f(\"pixelRatio\", o), e.setUniform2f(\"screenOffset\", i.screenOffset[0] * o, i.screenOffset[1] * o), null !== i.borderColor ? (d(e, \"borderColor\", i.borderColor), e.setUniform1f(\"borderSize\", o)) : (e.setUniform4f(\"borderColor\", 0, 0, 0, 0), e.setUniform1f(\"borderSize\", 0));\n  }\n\n  e.bindUniforms = i;\n}(a || (a = {}));\nvar s = Object.freeze({\n  __proto__: null,\n  build: l,\n\n  get LineCallout() {\n    return a;\n  }\n\n});\nexport { a as L, s as a, l as b };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgis-api-react/node_modules/@arcgis/core/chunks/LineCallout.glsl.js"],"names":["Slice","e","AlignPixel","i","HUD","o","multipassGeometryTest","r","glsl","t","ShaderBuilder","n","l","a","include","attributes","add","vertex","uniforms","varyings","multipassGeometryEnabled","code","occlusionTestEnabled","screenSizePerspectiveEnabled","depthHudEnabled","depthHudAlignStartEnabled","fragment","d","length","setUniform4f","setUniform4fv","color","setUniform1f","setUniform2f","screenOffset","borderColor","bindUniforms","s","Object","freeze","__proto__","build","LineCallout","L","b"],"mappings":"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","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{Slice as e}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{AlignPixel as i}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js\";import{HUD as o}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js\";import{multipassGeometryTest as r}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js\";import{glsl as t}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as n}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";function l(l){const a=new n;return a.include(i),a.include(o,l),a.include(e,l),a.attributes.add(\"uv0\",\"vec2\"),a.vertex.uniforms.add(\"lineSize\",\"float\").add(\"pixelToNDC\",\"vec2\").add(\"borderSize\",\"float\").add(\"screenOffset\",\"vec2\"),a.varyings.add(\"coverageSampling\",\"vec4\"),a.varyings.add(\"lineSizes\",\"vec2\"),l.multipassGeometryEnabled&&a.varyings.add(\"depth\",\"float\"),a.vertex.code.add(t`\n    void main(void) {\n      ProjectHUDAux projectAux;\n      vec4 endPoint = projectPositionHUD(projectAux);\n\n      vec3 vpos = projectAux.posModel;\n      if (rejectBySlice(vpos)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n    ${l.occlusionTestEnabled?t`\n      if (!testVisibilityHUD(endPoint)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }`:\"\"}\n\n    ${l.screenSizePerspectiveEnabled?t`\n      vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n      vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);\n        `:t`\n      vec2 screenOffsetScaled = screenOffset;\n        `}\n      // Add view dependent polygon offset to get exact same original starting point. This is mostly\n      // used to get the correct depth value\n      vec3 posView = (view * vec4(position, 1.0)).xyz;\n      ${l.multipassGeometryEnabled?\"depth = posView.z;\":\"\"}\n\n      applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);\n      vec4 startPoint = proj * vec4(posView, 1.0);\n      // Apply screen offset to both start and end point\n      vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n      startPoint.xy += screenOffsetNorm * startPoint.w;\n      endPoint.xy += screenOffsetNorm * endPoint.w;\n      // Align start and end to pixel origin\n      vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n      vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n    ${l.depthHudEnabled?l.depthHudAlignStartEnabled?t`endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);`:t`startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);`:\"\"}\n      vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n      // The direction of the line in screen space\n      vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n    ${l.screenSizePerspectiveEnabled?t`\n      float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n      float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\n        `:t`\n      float lineSizeScaled = lineSize;\n      float borderSizeScaled = borderSize;\n        `}\n      float halfPixelSize = lineSizeScaled * 0.5;\n      // Calculate a pixel offset from the edge of the pixel, s.t. we keep the line aligned\n      // to pixels if it has a full pixel size. Since pixel aligned biases to the bottom-left,\n      // we bias the size to the right (for odd sizes) to balance out the bias. Grow sub-pixel\n      // sizes towards the left or right s.t. there is a smooth transition (e.g. from 2 to 3 px).\n      float halfWholePixelSize = floor(lineSizeScaled) * 0.5;\n      float halfPixelSizeInt = floor(halfWholePixelSize);\n\n      // Sub-pixel offset if we need to grow sub-pixels to the left\n      float subpixelOffset = -fract(lineSizeScaled) * float(halfWholePixelSize > 0.0);\n\n      // Pixel offset aligning to whole pixels and adding subpixel offset if needed\n      float pixelOffset = -halfPixelSizeInt + subpixelOffset;\n\n      // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\n      float padding = 1.0 + borderSizeScaled;\n      vec2 ndcOffset = (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n\n      // Offset x/y from the center of the line in screen space\n      projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n\n      // Compute a coverage varying which we can use in the fragment shader to determine\n      // how much a pixel is actually covered by the line (i.e. to anti alias the line).\n      // This works by computing two coordinates that can be linearly interpolated and then\n      // subtracted to find out how far away from the line edge we are.\n      float edgeDirection = (uv0.x * 2.0 - 1.0);\n\n      float halfBorderSize = 0.5 * borderSizeScaled;\n      float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n      float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n\n      float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n\n      coverageSampling = vec4(\n        // Edge coordinate\n        outerEdgeCoverageSampler,\n\n        // Border edge coordinate\n        outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n\n        // Line offset\n        halfPixelSize - 0.5,\n\n        // Border offset\n        halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n      );\n\n      lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n\n      gl_Position = projectedPosition;\n    }\n  `),a.fragment.uniforms.add(\"color\",\"vec4\"),a.fragment.uniforms.add(\"borderColor\",\"vec4\"),l.multipassGeometryEnabled&&(a.fragment.include(r,l),a.fragment.uniforms.add(\"inverseViewport\",\"vec2\")),a.fragment.code.add(t`\n    void main() {\n      ${l.multipassGeometryEnabled?\"if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }\":\"\"}\n\n      // Mix between line and border coverage offsets depending on whether we need\n      // a border (based on the sidedness).\n      vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n\n      // Mix between border and line color based on the line coverage (conceptually the line\n      // blends on top of the border background).\n      //\n      // Anti-alias by blending final result using the full (including optional border) coverage\n      // and the color alpha\n      float borderAlpha = color.a * borderColor.a * coverage.y;\n      float colorAlpha = color.a * coverage.x;\n\n      float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n\n    ${l.depthHudEnabled?t`\n      if (finalAlpha < 0.01) {\n        discard;\n      }\n      `:t`\n      // Compute the finalRgb, but keep it pre-multiplied (for unpre-multiplied you\n      // need to divide by finalAlpha). We avoid the division here by setting the\n      // appropriate blending function in the material.\n      vec3 finalRgb = mix(borderColor.rgb * borderAlpha, color.rgb, colorAlpha);\n      gl_FragColor = vec4(finalRgb, finalAlpha);\n      `}\n  }\n  `),a}var a;function d(e,i,o){3===o.length?e.setUniform4f(i,o[0],o[1],o[2],1):e.setUniform4fv(i,o)}!function(e){function i(e,i,o){d(e,\"color\",i.color),e.setUniform1f(\"pixelRatio\",o),e.setUniform2f(\"screenOffset\",i.screenOffset[0]*o,i.screenOffset[1]*o),null!==i.borderColor?(d(e,\"borderColor\",i.borderColor),e.setUniform1f(\"borderSize\",o)):(e.setUniform4f(\"borderColor\",0,0,0,0),e.setUniform1f(\"borderSize\",0))}e.bindUniforms=i}(a||(a={}));var s=Object.freeze({__proto__:null,build:l,get LineCallout(){return a}});export{a as L,s as a,l as b};\n"]},"metadata":{},"sourceType":"module"}