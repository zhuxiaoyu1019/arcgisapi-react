{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { earth as e, mars as o, moon as r } from \"../geometry/support/Ellipsoid.js\";\nimport { ComponentData as a } from \"../views/3d/webgl-engine/collections/Component/Material/shader/ComponentData.glsl.js\";\nimport { VertexDiscardByOpacity as l } from \"../views/3d/webgl-engine/collections/Component/Material/shader/VertexDiscardByOpacity.glsl.js\";\nimport { ForwardLinearDepth as i } from \"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";\nimport { Slice as t } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { TextureCoordinateAttribute as n } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";\nimport { VertexColor as d } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";\nimport { VertexNormal as s } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js\";\nimport { VertexPosition as c } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js\";\nimport { OutputDepth as g } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";\nimport { OutputHighlight as v } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";\nimport { ReadLinearDepth as m } from \"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";\nimport { ComputeMaterialColor as u } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeMaterialColor.glsl.js\";\nimport { ComputeNormalTexture as p } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js\";\nimport { ComputeShadingNormal as h } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeShadingNormal.glsl.js\";\nimport { EvaluateSceneLighting as C } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js\";\nimport { multipassTerrainTest as w } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";\nimport { PhysicallyBasedRenderingParameters as b } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js\";\nimport { ReadBaseColorTexture as y } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadBaseColorTexture.glsl.js\";\nimport { ReadShadowMap as f } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";\nimport { Overlay as x } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js\";\nimport { DiscardOrAdjustAlpha as M, symbolAlphaCutoff as L } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js\";\nimport { glsl as O } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as T } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nconst S = new Map([[\"position\", 0], [\"normal\", 1], [\"normalCompressed\", 1], [\"color\", 2], [\"uv0\", 3], [\"uvRegion\", 4], [\"componentIndex\", 5]]);\n\nfunction j(S) {\n  const j = new T();\n  j.include(c, S), j.include(s, S), j.include(d, S), j.include(n, S), j.include(i, S), j.include(a, S), j.include(M, S), j.include(t, S), j.include(y, S), j.include(l, S), j.fragment.uniforms.add(\"view\", \"mat4\"), 1 !== S.pbrMode && 2 !== S.pbrMode || (j.include(b, S), S.hasNormalTexture && j.include(p, S)), 3 === S.output && 1 === S.componentData ? j.vertex.code.add(O`#define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`) : j.vertex.code.add(O`#define discardShadows(castShadows) {}`);\n  const N = S.overlayEnabled && 0 === S.output && 4 === S.pbrMode;\n  return S.overlayEnabled && (j.include(x, S), 1 === S.viewingMode ? j.vertex.code.add(O`\n      const float invEllipsoidRadius = ${O.float(1 / (1 === S.ellipsoidMode ? e.radius : 2 === S.ellipsoidMode ? o.radius : r.radius))};\n      vec2 projectOverlay(vec3 pos) {\n        return pos.xy / (1.0 + invEllipsoidRadius * pos.z);\n      }\n      `) : j.vertex.code.add(O`vec2 projectOverlay(vec3 pos) { return pos.xy; }`)), N && (j.varyings.add(\"tbnTangent\", \"vec3\"), j.varyings.add(\"tbnBiTangent\", \"vec3\"), j.varyings.add(\"groundNormal\", \"vec3\"), j.varyings.add(\"positionView\", \"vec3\")), j.vertex.code.add(O`\n    void main() {\n      bool castShadows;\n      vec4 externalColor = forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      if (externalColor.a < ${O.float(L)}) {\n        // Discard this vertex\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n      forwardPosition();\n      forwardNormal();\n      ${N ? O`\n        positionView = position_view();\n        ${1 === S.viewingMode ? O`\n        groundNormal = normalize(positionWorld());\n        tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));\n        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));` : O`\n        groundNormal = vec3(0.0, 0.0, 1.0);\n        tbnTangent = vec3(1.0, 0.0, 0.0);\n        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));`}\n        ` : \"\"}\n\n      ${S.overlayEnabled ? O`setOverlayVTC(projectOverlay(position));` : \"\"}\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth(); // depends on forwardPosition()\n    }\n  `), 7 === S.output && (j.fragment.include(m), S.multipassTerrainEnabled && j.include(w, S), j.include(u, S), j.fragment.code.add(O`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n        ${S.multipassTerrainEnabled ? O`terrainDepthTest(gl_FragCoord, vPosition_view.z);` : \"\"}\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor = computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ${S.overlayEnabled ? O`\n        vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);\n        vec4 overlayColor = overlayOpacity * overlayColorOpaque;\n        materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;` : \"\"}\n\n        gl_FragColor = vec4(materialColor.a);\n      }\n    `)), 0 === S.output && (j.fragment.include(m), S.multipassTerrainEnabled && j.include(w, S), j.include(u, S), j.include(h, S), j.include(C, S), N && j.fragment.uniforms.add(\"ovNormalTex\", \"sampler2D\"), S.receiveShadows ? (j.include(f, S), j.fragment.code.add(O`float evaluateShadow() {\nreturn readShadowMap(vPositionWorldCameraRelative, linearDepth);\n}`)) : j.fragment.code.add(O`float evaluateShadow() { return 0.0; }`), j.fragment.code.add(O`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n        ${S.multipassTerrainEnabled ? O`terrainDepthTest(gl_FragCoord, vPosition_view.z);` : \"\"}\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor = computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ${S.overlayEnabled ? O`\n        vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);\n        vec4 overlayColor = overlayOpacity * overlayColorOpaque;\n        materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;` : \"\"}\n    `), 1 === S.pbrMode || 2 === S.pbrMode ? (j.fragment.code.add(O`\n        ${1 === S.pbrMode ? O`\n        applyPBRFactors();\n        if (int(externalColorMixMode) == 3) {\n          mrr = vec3(0.0, 0.6, 0.2);\n        }` : \"\"}\n        vec3 normalVertex = shadingNormalWorld();\n        float additionalIrradiance = 0.02 * lightingMainIntensity[2];\n      `), S.hasNormalTexture ? j.fragment.code.add(O`mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\nvec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);`) : j.fragment.code.add(O`vec3 shadingNormal = normalVertex;`), j.fragment.code.add(O`${1 === S.viewingMode ? O`vec3 normalGround = normalize(positionWorld());` : O`vec3 normalGround = vec3(0.0, 0.0, 1.0);`}\n      `), j.fragment.code.add(O`vec3 viewDir = normalize(vPositionWorldCameraRelative);\nfloat ssao = 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\nvec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());\nvec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);`)) : (S.receiveShadows ? j.fragment.code.add(O`float shadow = evaluateShadow();`) : 1 === S.viewingMode ? j.fragment.code.add(O`float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());\nfloat shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);`) : j.fragment.code.add(O`float shadow = 0.0;`), j.fragment.code.add(O`\n      float ambientOcclusion = evaluateAmbientOcclusion();\n      // At global scale we create some additional ambient light based on the main light to simulate global illumination\n      vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n      vec4 shadedColor = vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);\n      ${N ? O`\n          vec4 overlayWaterMask = getOverlayColor(ovNormalTex, vtcOverlay);\n          float waterNormalLength = length(overlayWaterMask);\n          if (waterNormalLength > 0.95) {\n            mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);\n            vec4 waterOverlayColor = vec4(overlayColorOpaque.xyz, overlayColor.w);\n            vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, positionView);\n            vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));\n            // un-gamma the ground color to mix in linear space\n            shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);\n          }` : \"\"}\n      `)), j.fragment.code.add(O`\n        gl_FragColor = highlightSlice(shadedColor, vPositionWorldCameraRelative);\n        ${S.OITEnabled ? \"gl_FragColor = premultiplyAlpha(gl_FragColor);\" : \"\"}\n      }\n    `)), 1 !== S.output && 3 !== S.output || (j.include(g, S), j.fragment.code.add(O`void main() {\ndiscardBySlice(vPositionWorldCameraRelative);\nvec4 textureColor = readBaseColorTexture();\ndiscardOrAdjustAlpha(textureColor);\noutputDepth(linearDepth);\n}`)), 2 === S.output && (j.include(h, S), j.fragment.code.add(O`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        float alpha = ${2 === S.normalType ? \"0.0\" : \"1.0\"};\n        gl_FragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);\n      }\n    `)), 4 === S.output && (j.include(v), j.fragment.code.add(O`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        ${S.overlayEnabled ? O`\n        vec4 overlayColor = getCombinedOverlayColor();\n\n        if (overlayColor.a == 0.0) {\n          gl_FragColor = vec4(0.0);\n          return;\n        }` : \"\"}\n\n        outputHighlight();\n      }\n    `)), j;\n}\n\nvar N = Object.freeze({\n  __proto__: null,\n  attributeLocations: S,\n  build: j\n});\nexport { N as C, S as a, j as b };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgisapi-react/node_modules/@arcgis/core/chunks/ComponentShader.glsl.js"],"names":["earth","e","mars","o","moon","r","ComponentData","a","VertexDiscardByOpacity","l","ForwardLinearDepth","i","Slice","t","TextureCoordinateAttribute","n","VertexColor","d","VertexNormal","s","VertexPosition","c","OutputDepth","g","OutputHighlight","v","ReadLinearDepth","m","ComputeMaterialColor","u","ComputeNormalTexture","p","ComputeShadingNormal","h","EvaluateSceneLighting","C","multipassTerrainTest","w","PhysicallyBasedRenderingParameters","b","ReadBaseColorTexture","y","ReadShadowMap","f","Overlay","x","DiscardOrAdjustAlpha","M","symbolAlphaCutoff","L","glsl","O","ShaderBuilder","T","S","Map","j","include","fragment","uniforms","add","pbrMode","hasNormalTexture","output","componentData","vertex","code","N","overlayEnabled","viewingMode","float","ellipsoidMode","radius","varyings","multipassTerrainEnabled","receiveShadows","OITEnabled","normalType","Object","freeze","__proto__","attributeLocations","build"],"mappings":"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","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{earth as e,mars as o,moon as r}from\"../geometry/support/Ellipsoid.js\";import{ComponentData as a}from\"../views/3d/webgl-engine/collections/Component/Material/shader/ComponentData.glsl.js\";import{VertexDiscardByOpacity as l}from\"../views/3d/webgl-engine/collections/Component/Material/shader/VertexDiscardByOpacity.glsl.js\";import{ForwardLinearDepth as i}from\"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";import{Slice as t}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{TextureCoordinateAttribute as n}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";import{VertexColor as d}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";import{VertexNormal as s}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js\";import{VertexPosition as c}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js\";import{OutputDepth as g}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{OutputHighlight as v}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";import{ReadLinearDepth as m}from\"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";import{ComputeMaterialColor as u}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeMaterialColor.glsl.js\";import{ComputeNormalTexture as p}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js\";import{ComputeShadingNormal as h}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeShadingNormal.glsl.js\";import{EvaluateSceneLighting as C}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js\";import{multipassTerrainTest as w}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";import{PhysicallyBasedRenderingParameters as b}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js\";import{ReadBaseColorTexture as y}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadBaseColorTexture.glsl.js\";import{ReadShadowMap as f}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";import{Overlay as x}from\"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js\";import{DiscardOrAdjustAlpha as M,symbolAlphaCutoff as L}from\"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js\";import{glsl as O}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as T}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";const S=new Map([[\"position\",0],[\"normal\",1],[\"normalCompressed\",1],[\"color\",2],[\"uv0\",3],[\"uvRegion\",4],[\"componentIndex\",5]]);function j(S){const j=new T;j.include(c,S),j.include(s,S),j.include(d,S),j.include(n,S),j.include(i,S),j.include(a,S),j.include(M,S),j.include(t,S),j.include(y,S),j.include(l,S),j.fragment.uniforms.add(\"view\",\"mat4\"),1!==S.pbrMode&&2!==S.pbrMode||(j.include(b,S),S.hasNormalTexture&&j.include(p,S)),3===S.output&&1===S.componentData?j.vertex.code.add(O`#define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`):j.vertex.code.add(O`#define discardShadows(castShadows) {}`);const N=S.overlayEnabled&&0===S.output&&4===S.pbrMode;return S.overlayEnabled&&(j.include(x,S),1===S.viewingMode?j.vertex.code.add(O`\n      const float invEllipsoidRadius = ${O.float(1/(1===S.ellipsoidMode?e.radius:2===S.ellipsoidMode?o.radius:r.radius))};\n      vec2 projectOverlay(vec3 pos) {\n        return pos.xy / (1.0 + invEllipsoidRadius * pos.z);\n      }\n      `):j.vertex.code.add(O`vec2 projectOverlay(vec3 pos) { return pos.xy; }`)),N&&(j.varyings.add(\"tbnTangent\",\"vec3\"),j.varyings.add(\"tbnBiTangent\",\"vec3\"),j.varyings.add(\"groundNormal\",\"vec3\"),j.varyings.add(\"positionView\",\"vec3\")),j.vertex.code.add(O`\n    void main() {\n      bool castShadows;\n      vec4 externalColor = forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      if (externalColor.a < ${O.float(L)}) {\n        // Discard this vertex\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n      forwardPosition();\n      forwardNormal();\n      ${N?O`\n        positionView = position_view();\n        ${1===S.viewingMode?O`\n        groundNormal = normalize(positionWorld());\n        tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));\n        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));`:O`\n        groundNormal = vec3(0.0, 0.0, 1.0);\n        tbnTangent = vec3(1.0, 0.0, 0.0);\n        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));`}\n        `:\"\"}\n\n      ${S.overlayEnabled?O`setOverlayVTC(projectOverlay(position));`:\"\"}\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth(); // depends on forwardPosition()\n    }\n  `),7===S.output&&(j.fragment.include(m),S.multipassTerrainEnabled&&j.include(w,S),j.include(u,S),j.fragment.code.add(O`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n        ${S.multipassTerrainEnabled?O`terrainDepthTest(gl_FragCoord, vPosition_view.z);`:\"\"}\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor = computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ${S.overlayEnabled?O`\n        vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);\n        vec4 overlayColor = overlayOpacity * overlayColorOpaque;\n        materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`:\"\"}\n\n        gl_FragColor = vec4(materialColor.a);\n      }\n    `)),0===S.output&&(j.fragment.include(m),S.multipassTerrainEnabled&&j.include(w,S),j.include(u,S),j.include(h,S),j.include(C,S),N&&j.fragment.uniforms.add(\"ovNormalTex\",\"sampler2D\"),S.receiveShadows?(j.include(f,S),j.fragment.code.add(O`float evaluateShadow() {\nreturn readShadowMap(vPositionWorldCameraRelative, linearDepth);\n}`)):j.fragment.code.add(O`float evaluateShadow() { return 0.0; }`),j.fragment.code.add(O`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n        ${S.multipassTerrainEnabled?O`terrainDepthTest(gl_FragCoord, vPosition_view.z);`:\"\"}\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor = computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ${S.overlayEnabled?O`\n        vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);\n        vec4 overlayColor = overlayOpacity * overlayColorOpaque;\n        materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`:\"\"}\n    `),1===S.pbrMode||2===S.pbrMode?(j.fragment.code.add(O`\n        ${1===S.pbrMode?O`\n        applyPBRFactors();\n        if (int(externalColorMixMode) == 3) {\n          mrr = vec3(0.0, 0.6, 0.2);\n        }`:\"\"}\n        vec3 normalVertex = shadingNormalWorld();\n        float additionalIrradiance = 0.02 * lightingMainIntensity[2];\n      `),S.hasNormalTexture?j.fragment.code.add(O`mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\nvec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);`):j.fragment.code.add(O`vec3 shadingNormal = normalVertex;`),j.fragment.code.add(O`${1===S.viewingMode?O`vec3 normalGround = normalize(positionWorld());`:O`vec3 normalGround = vec3(0.0, 0.0, 1.0);`}\n      `),j.fragment.code.add(O`vec3 viewDir = normalize(vPositionWorldCameraRelative);\nfloat ssao = 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\nvec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());\nvec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);`)):(S.receiveShadows?j.fragment.code.add(O`float shadow = evaluateShadow();`):1===S.viewingMode?j.fragment.code.add(O`float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());\nfloat shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);`):j.fragment.code.add(O`float shadow = 0.0;`),j.fragment.code.add(O`\n      float ambientOcclusion = evaluateAmbientOcclusion();\n      // At global scale we create some additional ambient light based on the main light to simulate global illumination\n      vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n      vec4 shadedColor = vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);\n      ${N?O`\n          vec4 overlayWaterMask = getOverlayColor(ovNormalTex, vtcOverlay);\n          float waterNormalLength = length(overlayWaterMask);\n          if (waterNormalLength > 0.95) {\n            mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);\n            vec4 waterOverlayColor = vec4(overlayColorOpaque.xyz, overlayColor.w);\n            vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, positionView);\n            vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));\n            // un-gamma the ground color to mix in linear space\n            shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);\n          }`:\"\"}\n      `)),j.fragment.code.add(O`\n        gl_FragColor = highlightSlice(shadedColor, vPositionWorldCameraRelative);\n        ${S.OITEnabled?\"gl_FragColor = premultiplyAlpha(gl_FragColor);\":\"\"}\n      }\n    `)),1!==S.output&&3!==S.output||(j.include(g,S),j.fragment.code.add(O`void main() {\ndiscardBySlice(vPositionWorldCameraRelative);\nvec4 textureColor = readBaseColorTexture();\ndiscardOrAdjustAlpha(textureColor);\noutputDepth(linearDepth);\n}`)),2===S.output&&(j.include(h,S),j.fragment.code.add(O`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        float alpha = ${2===S.normalType?\"0.0\":\"1.0\"};\n        gl_FragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);\n      }\n    `)),4===S.output&&(j.include(v),j.fragment.code.add(O`\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        ${S.overlayEnabled?O`\n        vec4 overlayColor = getCombinedOverlayColor();\n\n        if (overlayColor.a == 0.0) {\n          gl_FragColor = vec4(0.0);\n          return;\n        }`:\"\"}\n\n        outputHighlight();\n      }\n    `)),j}var N=Object.freeze({__proto__:null,attributeLocations:S,build:j});export{N as C,S as a,j as b};\n"]},"metadata":{},"sourceType":"module"}