{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { Slice as e } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { RibbonVertexPosition as i } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";\nimport { OutputDepth as t } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";\nimport { ReadLinearDepth as r } from \"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";\nimport { LineStipple as n } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js\";\nimport { multipassTerrainTest as a } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";\nimport { PiUtils as o } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js\";\nimport { symbolAlphaCutoff as l } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js\";\nimport { ColorConversion as s } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { glsl as p } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as d } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\n\nfunction c(c) {\n  const v = new d();\n  v.extensions.add(\"GL_OES_standard_derivatives\"), v.include(o), v.include(i, c), v.include(n, c), 1 === c.output && v.include(t, c), v.vertex.uniforms.add(\"proj\", \"mat4\").add(\"view\", \"mat4\").add(\"cameraNearFar\", \"vec2\").add(\"pixelRatio\", \"float\").add(\"miterLimit\", \"float\").add(\"screenSize\", \"vec2\"), v.attributes.add(\"position\", \"vec3\"), v.attributes.add(\"subdivisionFactor\", \"float\"), v.attributes.add(\"uv0\", \"vec2\"), v.attributes.add(\"auxpos1\", \"vec3\"), v.attributes.add(\"auxpos2\", \"vec3\"), v.varyings.add(\"vColor\", \"vec4\"), v.varyings.add(\"vpos\", \"vec3\"), v.varyings.add(\"linearDepth\", \"float\"), c.multipassTerrainEnabled && v.varyings.add(\"depth\", \"float\");\n  const f = c.falloffEnabled,\n        m = c.innerColorEnabled;\n  return m && v.varyings.add(\"vLineDistance\", \"float\"), f && v.varyings.add(\"vLineDistanceNorm\", \"float\"), c.falloffEnabled && v.fragment.uniforms.add(\"falloff\", \"float\"), c.innerColorEnabled && (v.fragment.uniforms.add(\"innerColor\", \"vec4\"), v.fragment.uniforms.add(\"innerWidth\", \"float\")), v.vertex.code.add(p`#define PERPENDICULAR(v) vec2(v.y, -v.x);\n#define ISOUTSIDE (left.x * right.y - left.y * right.x)*uv0.y > 0.0\nfloat interp(float ncp, vec4 a, vec4 b) {\nreturn (-ncp - a.z) / (b.z - a.z);\n}\nvec2 rotate(vec2 v, float a) {\nfloat s = sin(a);\nfloat c = cos(a);\nmat2 m = mat2(c, -s, s, c);\nreturn m * v;\n}`), v.vertex.code.add(p`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= screenSize / posNdc.w;\nreturn posNdc;\n}`), v.vertex.code.add(p`\n    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\n      float vnp = cameraNearFar[0] * 0.99;\n\n      //current pos behind ncp --> we need to clip\n      if(pos.z > -cameraNearFar[0]) {\n        if (!isStartVertex) {\n          //previous in front of ncp\n          if(prev.z < -cameraNearFar[0]) {\n            pos = mix(prev, pos, interp(vnp, prev, pos));\n            next = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n        //next in front of ncp\n        if(isStartVertex) {\n          if(next.z < -cameraNearFar[0]) {\n            pos = mix(pos, next, interp(vnp, pos, next));\n            prev = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n      } else {\n        //current position visible\n        //previous behind ncp\n        if (prev.z > -cameraNearFar[0]) {\n          prev = mix(pos, prev, interp(vnp, pos, prev));\n        }\n        //next behind ncp\n        if (next.z > -cameraNearFar[0]) {\n          next = mix(next, pos, interp(vnp, next, pos));\n        }\n      }\n\n      ${c.multipassTerrainEnabled ? \"depth = pos.z;\" : \"\"}\n      linearDepth = (-pos.z - cameraNearFar[0]) / (cameraNearFar[1] - cameraNearFar[0]);\n\n      pos = projectAndScale(pos);\n      next = projectAndScale(next);\n      prev = projectAndScale(prev);\n    }\n`), v.vertex.code.add(p`void main(void) {\nfloat coverage = 1.0;\nvpos = position;\nif (uv0.y == 0.0) {\ngl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n}\nelse {\nbool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\nbool isJoin = abs(uv0.y)-3.0 < 0.0;\nfloat lineWidth = getSize() * pixelRatio;\nif (lineWidth < 1.0) {\ncoverage = lineWidth;\nlineWidth = 1.0;\n}else{\nlineWidth = floor(lineWidth + 0.5);\n}\nvec4 pos  = view * vec4(position.xyz, 1.0);\nvec4 prev = view * vec4(auxpos1.xyz, 1.0);\nvec4 next = view * vec4(auxpos2.xyz, 1.0);\nclipAndTransform(pos, prev, next, isStartVertex);\nvec2 left = (pos.xy - prev.xy);\nvec2 right = (next.xy - pos.xy);\nfloat leftLen = length(left);\nfloat rightLen = length(right);`), c.stippleEnabled && v.vertex.code.add(p`vec4 stippleSegmentInfo = mix(vec4(pos.xy, right), vec4(prev.xy, left), uv0.x);\nvec2 stippleSegmentOrigin = stippleSegmentInfo.xy;\nvec2 stippleSegmentDirection = stippleSegmentInfo.zw;`), v.vertex.code.add(p`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\nright = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\nvec2 capDisplacementDir = vec2(0, 0);\nvec2 joinDisplacementDir = vec2(0, 0);\nfloat displacementLen = lineWidth;\nif (isJoin) {\nbool isOutside = ISOUTSIDE;\njoinDisplacementDir = normalize(left + right);\njoinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\nif (leftLen > 0.001 && rightLen > 0.001) {\nfloat nDotSeg = dot(joinDisplacementDir, left);\ndisplacementLen /= length(nDotSeg * left - joinDisplacementDir);\nif (!isOutside) {\ndisplacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n}\n}\nif (isOutside && (displacementLen > miterLimit * lineWidth)) {`), c.roundJoins ? v.vertex.code.add(p`vec2 startDir;\nvec2 endDir;\nif (leftLen < 0.001) {\nstartDir = right;\n}\nelse{\nstartDir = left;\n}\nstartDir = normalize(startDir);\nstartDir = PERPENDICULAR(startDir);\nif (rightLen < 0.001) {\nendDir = left;\n}\nelse{\nendDir = right;\n}\nendDir = normalize(endDir);\nendDir = PERPENDICULAR(endDir);\nfloat rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\njoinDisplacementDir = rotate(startDir, -sign(uv0.y) * subdivisionFactor * rotationAngle);`) : v.vertex.code.add(p`if (leftLen < 0.001) {\njoinDisplacementDir = right;\n}\nelse if (rightLen < 0.001) {\njoinDisplacementDir = left;\n}\nelse {\njoinDisplacementDir = isStartVertex ? right : left;\n}\njoinDisplacementDir = normalize(joinDisplacementDir);\njoinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`), v.vertex.code.add(p`displacementLen = lineWidth;\n}\n} else {\nif (leftLen < 0.001) {\njoinDisplacementDir = right;\n}\nelse if (rightLen < 0.001) {\njoinDisplacementDir = left;\n}\nelse {\njoinDisplacementDir = isStartVertex ? right : left;\n}\njoinDisplacementDir = normalize(joinDisplacementDir);\njoinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\ndisplacementLen = lineWidth;\ncapDisplacementDir = isStartVertex ? -right : left;`), c.roundCaps ? v.vertex.code.add(p`float angle = subdivisionFactor*PI*0.5;\njoinDisplacementDir *= cos(angle);\ncapDisplacementDir *= sin(angle);`) : v.vertex.code.add(p`capDisplacementDir *= subdivisionFactor;`), v.vertex.code.add(p`\n  }\n\n  // Displacement (in pixels) caused by join/or cap\n  vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;\n\n  ${f || m ? p`float lineDist = lineWidth * sign(uv0.y) * pos.w;` : \"\"}\n\n  ${m ? p`vLineDistance = lineDist;` : \"\"}\n  ${f ? p`vLineDistanceNorm = lineDist / lineWidth;` : \"\"}\n\n  pos.xy += dpos;\n  `), c.stippleEnabled && (v.vertex.code.add(p`{\nvec2 posVec = pos.xy - stippleSegmentOrigin;\nfloat stippleSegmentDirectionLength = length(stippleSegmentDirection);`), c.stippleIntegerRepeatsEnabled && v.vertex.code.add(p`float numberOfPatternRepeats = stippleSegmentDirectionLength * 0.5 * stipplePatternPixelSizeInv;\nfloat roundedNumberOfPatternRepeats = floor(numberOfPatternRepeats);\nstipplePatternUvMax = roundedNumberOfPatternRepeats;`), v.vertex.code.add(p`\n      if (stippleSegmentDirectionLength >= 0.001) {\n        // Project the vertex position onto the line segment.\n        float projectedLength = dot(stippleSegmentDirection, posVec) / stippleSegmentDirectionLength * 0.5;\n     ${c.stippleIntegerRepeatsEnabled ? \"float wholeNumberOfRepeatsScale = roundedNumberOfPatternRepeats / numberOfPatternRepeats;\" : \"float wholeNumberOfRepeatsScale = 1.0;\"}\n        stipplePatternUv = projectedLength * wholeNumberOfRepeatsScale * stipplePatternPixelSizeInv * pos.w;\n        } else {\n          stipplePatternUv = 1.0;\n        }\n      }\n    `)), v.vertex.code.add(p`pos.xy = pos.xy / screenSize * pos.w;\nvColor = getColor();\nvColor.a *= coverage;\ngl_Position = pos;\n}\n}`), c.multipassTerrainEnabled && (v.fragment.include(r), v.include(a, c)), v.include(e, c), v.fragment.uniforms.add(\"intrinsicColor\", \"vec4\"), v.fragment.include(s), v.fragment.code.add(p`\n  void main() {\n    discardBySlice(vpos);\n    ${c.multipassTerrainEnabled ? \"terrainDepthTest(gl_FragCoord, depth);\" : \"\"}\n    float stippleAlpha = getStippleAlpha();\n    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);\n\n    vec4 color = intrinsicColor * vColor;\n  `), c.innerColorEnabled && (v.fragment.uniforms.add(\"pixelRatio\", \"float\"), v.fragment.code.add(p`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;\nfloat innerAA = clamp(0.5 - distToInner, 0.0, 1.0);\nfloat innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);\ncolor = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)), v.fragment.code.add(p`vec4 finalColor = blendStipple(color, stippleAlpha);`), c.falloffEnabled && v.fragment.code.add(p`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`), v.fragment.code.add(p`\n    if (finalColor.a < ${p.float(l)}) {\n      discard;\n    }\n\n    ${7 === c.output ? p`gl_FragColor = vec4(finalColor.a);` : \"\"}\n    ${0 === c.output ? p`gl_FragColor = highlightSlice(finalColor, vpos);` : \"\"}\n    ${0 === c.output && c.OITEnabled ? \"gl_FragColor = premultiplyAlpha(gl_FragColor);\" : \"\"}\n    ${4 === c.output ? p`gl_FragColor = vec4(1.0);` : \"\"}\n    ${1 === c.output ? p`outputDepth(linearDepth);` : \"\"}\n  }\n  `), v;\n}\n\nvar v = Object.freeze({\n  __proto__: null,\n  build: c\n});\nexport { v as R, c as b };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgisapi-react/node_modules/@arcgis/core/chunks/RibbonLine.glsl.js"],"names":["Slice","e","RibbonVertexPosition","i","OutputDepth","t","ReadLinearDepth","r","LineStipple","n","multipassTerrainTest","a","PiUtils","o","symbolAlphaCutoff","l","ColorConversion","s","glsl","p","ShaderBuilder","d","c","v","extensions","add","include","output","vertex","uniforms","attributes","varyings","multipassTerrainEnabled","f","falloffEnabled","m","innerColorEnabled","fragment","code","stippleEnabled","roundJoins","roundCaps","stippleIntegerRepeatsEnabled","float","OITEnabled","Object","freeze","__proto__","build","R","b"],"mappings":"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ACA,EAJI,CAV2xD,EAc3xDI,CAAC,CAACK,MAAF,CAASU,IAAT,CAAcb,GAAd,CAAkBN,CAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQG,CAAC,CAACU,uBAAF,GAA0B,gBAA1B,GAA2C,EAAG;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,CA3CI,CAd2xD,EAyD5xDT,CAAC,CAACK,MAAF,CAASU,IAAT,CAAcb,GAAd,CAAkBN,CAAE;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAvBG,CAzD4xD,EAgF7vDG,CAAC,CAACiB,cAAF,IAAkBhB,CAAC,CAACK,MAAF,CAASU,IAAT,CAAcb,GAAd,CAAkBN,CAAE;AACxE;AACA,sDAFoD,CAhF2uD,EAkFvuDI,CAAC,CAACK,MAAF,CAASU,IAAT,CAAcb,GAAd,CAAkBN,CAAE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAhBwD,CAlFuuD,EAkG9tDG,CAAC,CAACkB,UAAF,GAAajB,CAAC,CAACK,MAAF,CAASU,IAAT,CAAcb,GAAd,CAAkBN,CAAE;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAnB8E,CAAb,GAmB2BI,CAAC,CAACK,MAAF,CAASU,IAAT,CAAcb,GAAd,CAAkBN,CAAE;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAV4F,CArHmsD,EA+HnuDI,CAAC,CAACK,MAAF,CAASU,IAAT,CAAcb,GAAd,CAAkBN,CAAE;AAChF;AACA;AACA;AA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","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{Slice as e}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{RibbonVertexPosition as i}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";import{OutputDepth as t}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{ReadLinearDepth as r}from\"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";import{LineStipple as n}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js\";import{multipassTerrainTest as a}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";import{PiUtils as o}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js\";import{symbolAlphaCutoff as l}from\"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js\";import{ColorConversion as s}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{glsl as p}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as d}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";function c(c){const v=new d;v.extensions.add(\"GL_OES_standard_derivatives\"),v.include(o),v.include(i,c),v.include(n,c),1===c.output&&v.include(t,c),v.vertex.uniforms.add(\"proj\",\"mat4\").add(\"view\",\"mat4\").add(\"cameraNearFar\",\"vec2\").add(\"pixelRatio\",\"float\").add(\"miterLimit\",\"float\").add(\"screenSize\",\"vec2\"),v.attributes.add(\"position\",\"vec3\"),v.attributes.add(\"subdivisionFactor\",\"float\"),v.attributes.add(\"uv0\",\"vec2\"),v.attributes.add(\"auxpos1\",\"vec3\"),v.attributes.add(\"auxpos2\",\"vec3\"),v.varyings.add(\"vColor\",\"vec4\"),v.varyings.add(\"vpos\",\"vec3\"),v.varyings.add(\"linearDepth\",\"float\"),c.multipassTerrainEnabled&&v.varyings.add(\"depth\",\"float\");const f=c.falloffEnabled,m=c.innerColorEnabled;return m&&v.varyings.add(\"vLineDistance\",\"float\"),f&&v.varyings.add(\"vLineDistanceNorm\",\"float\"),c.falloffEnabled&&v.fragment.uniforms.add(\"falloff\",\"float\"),c.innerColorEnabled&&(v.fragment.uniforms.add(\"innerColor\",\"vec4\"),v.fragment.uniforms.add(\"innerWidth\",\"float\")),v.vertex.code.add(p`#define PERPENDICULAR(v) vec2(v.y, -v.x);\n#define ISOUTSIDE (left.x * right.y - left.y * right.x)*uv0.y > 0.0\nfloat interp(float ncp, vec4 a, vec4 b) {\nreturn (-ncp - a.z) / (b.z - a.z);\n}\nvec2 rotate(vec2 v, float a) {\nfloat s = sin(a);\nfloat c = cos(a);\nmat2 m = mat2(c, -s, s, c);\nreturn m * v;\n}`),v.vertex.code.add(p`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= screenSize / posNdc.w;\nreturn posNdc;\n}`),v.vertex.code.add(p`\n    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\n      float vnp = cameraNearFar[0] * 0.99;\n\n      //current pos behind ncp --> we need to clip\n      if(pos.z > -cameraNearFar[0]) {\n        if (!isStartVertex) {\n          //previous in front of ncp\n          if(prev.z < -cameraNearFar[0]) {\n            pos = mix(prev, pos, interp(vnp, prev, pos));\n            next = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n        //next in front of ncp\n        if(isStartVertex) {\n          if(next.z < -cameraNearFar[0]) {\n            pos = mix(pos, next, interp(vnp, pos, next));\n            prev = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n      } else {\n        //current position visible\n        //previous behind ncp\n        if (prev.z > -cameraNearFar[0]) {\n          prev = mix(pos, prev, interp(vnp, pos, prev));\n        }\n        //next behind ncp\n        if (next.z > -cameraNearFar[0]) {\n          next = mix(next, pos, interp(vnp, next, pos));\n        }\n      }\n\n      ${c.multipassTerrainEnabled?\"depth = pos.z;\":\"\"}\n      linearDepth = (-pos.z - cameraNearFar[0]) / (cameraNearFar[1] - cameraNearFar[0]);\n\n      pos = projectAndScale(pos);\n      next = projectAndScale(next);\n      prev = projectAndScale(prev);\n    }\n`),v.vertex.code.add(p`void main(void) {\nfloat coverage = 1.0;\nvpos = position;\nif (uv0.y == 0.0) {\ngl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n}\nelse {\nbool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\nbool isJoin = abs(uv0.y)-3.0 < 0.0;\nfloat lineWidth = getSize() * pixelRatio;\nif (lineWidth < 1.0) {\ncoverage = lineWidth;\nlineWidth = 1.0;\n}else{\nlineWidth = floor(lineWidth + 0.5);\n}\nvec4 pos  = view * vec4(position.xyz, 1.0);\nvec4 prev = view * vec4(auxpos1.xyz, 1.0);\nvec4 next = view * vec4(auxpos2.xyz, 1.0);\nclipAndTransform(pos, prev, next, isStartVertex);\nvec2 left = (pos.xy - prev.xy);\nvec2 right = (next.xy - pos.xy);\nfloat leftLen = length(left);\nfloat rightLen = length(right);`),c.stippleEnabled&&v.vertex.code.add(p`vec4 stippleSegmentInfo = mix(vec4(pos.xy, right), vec4(prev.xy, left), uv0.x);\nvec2 stippleSegmentOrigin = stippleSegmentInfo.xy;\nvec2 stippleSegmentDirection = stippleSegmentInfo.zw;`),v.vertex.code.add(p`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\nright = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\nvec2 capDisplacementDir = vec2(0, 0);\nvec2 joinDisplacementDir = vec2(0, 0);\nfloat displacementLen = lineWidth;\nif (isJoin) {\nbool isOutside = ISOUTSIDE;\njoinDisplacementDir = normalize(left + right);\njoinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\nif (leftLen > 0.001 && rightLen > 0.001) {\nfloat nDotSeg = dot(joinDisplacementDir, left);\ndisplacementLen /= length(nDotSeg * left - joinDisplacementDir);\nif (!isOutside) {\ndisplacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n}\n}\nif (isOutside && (displacementLen > miterLimit * lineWidth)) {`),c.roundJoins?v.vertex.code.add(p`vec2 startDir;\nvec2 endDir;\nif (leftLen < 0.001) {\nstartDir = right;\n}\nelse{\nstartDir = left;\n}\nstartDir = normalize(startDir);\nstartDir = PERPENDICULAR(startDir);\nif (rightLen < 0.001) {\nendDir = left;\n}\nelse{\nendDir = right;\n}\nendDir = normalize(endDir);\nendDir = PERPENDICULAR(endDir);\nfloat rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\njoinDisplacementDir = rotate(startDir, -sign(uv0.y) * subdivisionFactor * rotationAngle);`):v.vertex.code.add(p`if (leftLen < 0.001) {\njoinDisplacementDir = right;\n}\nelse if (rightLen < 0.001) {\njoinDisplacementDir = left;\n}\nelse {\njoinDisplacementDir = isStartVertex ? right : left;\n}\njoinDisplacementDir = normalize(joinDisplacementDir);\njoinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`),v.vertex.code.add(p`displacementLen = lineWidth;\n}\n} else {\nif (leftLen < 0.001) {\njoinDisplacementDir = right;\n}\nelse if (rightLen < 0.001) {\njoinDisplacementDir = left;\n}\nelse {\njoinDisplacementDir = isStartVertex ? right : left;\n}\njoinDisplacementDir = normalize(joinDisplacementDir);\njoinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\ndisplacementLen = lineWidth;\ncapDisplacementDir = isStartVertex ? -right : left;`),c.roundCaps?v.vertex.code.add(p`float angle = subdivisionFactor*PI*0.5;\njoinDisplacementDir *= cos(angle);\ncapDisplacementDir *= sin(angle);`):v.vertex.code.add(p`capDisplacementDir *= subdivisionFactor;`),v.vertex.code.add(p`\n  }\n\n  // Displacement (in pixels) caused by join/or cap\n  vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;\n\n  ${f||m?p`float lineDist = lineWidth * sign(uv0.y) * pos.w;`:\"\"}\n\n  ${m?p`vLineDistance = lineDist;`:\"\"}\n  ${f?p`vLineDistanceNorm = lineDist / lineWidth;`:\"\"}\n\n  pos.xy += dpos;\n  `),c.stippleEnabled&&(v.vertex.code.add(p`{\nvec2 posVec = pos.xy - stippleSegmentOrigin;\nfloat stippleSegmentDirectionLength = length(stippleSegmentDirection);`),c.stippleIntegerRepeatsEnabled&&v.vertex.code.add(p`float numberOfPatternRepeats = stippleSegmentDirectionLength * 0.5 * stipplePatternPixelSizeInv;\nfloat roundedNumberOfPatternRepeats = floor(numberOfPatternRepeats);\nstipplePatternUvMax = roundedNumberOfPatternRepeats;`),v.vertex.code.add(p`\n      if (stippleSegmentDirectionLength >= 0.001) {\n        // Project the vertex position onto the line segment.\n        float projectedLength = dot(stippleSegmentDirection, posVec) / stippleSegmentDirectionLength * 0.5;\n     ${c.stippleIntegerRepeatsEnabled?\"float wholeNumberOfRepeatsScale = roundedNumberOfPatternRepeats / numberOfPatternRepeats;\":\"float wholeNumberOfRepeatsScale = 1.0;\"}\n        stipplePatternUv = projectedLength * wholeNumberOfRepeatsScale * stipplePatternPixelSizeInv * pos.w;\n        } else {\n          stipplePatternUv = 1.0;\n        }\n      }\n    `)),v.vertex.code.add(p`pos.xy = pos.xy / screenSize * pos.w;\nvColor = getColor();\nvColor.a *= coverage;\ngl_Position = pos;\n}\n}`),c.multipassTerrainEnabled&&(v.fragment.include(r),v.include(a,c)),v.include(e,c),v.fragment.uniforms.add(\"intrinsicColor\",\"vec4\"),v.fragment.include(s),v.fragment.code.add(p`\n  void main() {\n    discardBySlice(vpos);\n    ${c.multipassTerrainEnabled?\"terrainDepthTest(gl_FragCoord, depth);\":\"\"}\n    float stippleAlpha = getStippleAlpha();\n    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);\n\n    vec4 color = intrinsicColor * vColor;\n  `),c.innerColorEnabled&&(v.fragment.uniforms.add(\"pixelRatio\",\"float\"),v.fragment.code.add(p`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;\nfloat innerAA = clamp(0.5 - distToInner, 0.0, 1.0);\nfloat innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);\ncolor = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)),v.fragment.code.add(p`vec4 finalColor = blendStipple(color, stippleAlpha);`),c.falloffEnabled&&v.fragment.code.add(p`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`),v.fragment.code.add(p`\n    if (finalColor.a < ${p.float(l)}) {\n      discard;\n    }\n\n    ${7===c.output?p`gl_FragColor = vec4(finalColor.a);`:\"\"}\n    ${0===c.output?p`gl_FragColor = highlightSlice(finalColor, vpos);`:\"\"}\n    ${0===c.output&&c.OITEnabled?\"gl_FragColor = premultiplyAlpha(gl_FragColor);\":\"\"}\n    ${4===c.output?p`gl_FragColor = vec4(1.0);`:\"\"}\n    ${1===c.output?p`outputDepth(linearDepth);`:\"\"}\n  }\n  `),v}var v=Object.freeze({__proto__:null,build:c});export{v as R,c as b};\n"]},"metadata":{},"sourceType":"module"}