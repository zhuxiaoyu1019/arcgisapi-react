{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { isNone as e, isSome as n } from \"../../../../core/maybe.js\";\nimport { f as t } from \"../../../../chunks/vec3f64.js\";\nimport o from \"../../../webgl/BufferObject.js\";\nimport i from \"../../../webgl/FramebufferObject.js\";\nimport { Program as r } from \"../../../webgl/Program.js\";\nimport \"../../../webgl/enums.js\";\nimport \"../../../webgl/RenderingContext.js\";\nimport \"../../../webgl/Texture.js\";\nimport s from \"../../../webgl/VertexArrayObject.js\";\nimport { encodeDoubleArray as c } from \"./doublePrecisionUtils.js\";\nimport { unpackFloatRGBA as a } from \"./Util.js\";\nimport { testSVGPremultipliedAlpha as l } from \"../../../webgl/testSVGPremultipliedAlpha.js\";\n\nclass u {\n  constructor(e) {\n    this.context = e, this.svgAlwaysPremultipliesAlpha = !1, this._doublePrecisionRequiresObfuscation = null, l(e).then(e => this.svgAlwaysPremultipliesAlpha = !e);\n  }\n\n  get doublePrecisionRequiresObfuscation() {\n    if (e(this._doublePrecisionRequiresObfuscation)) {\n      const e = h(this.context, !1),\n            n = h(this.context, !0);\n      this._doublePrecisionRequiresObfuscation = 0 !== e && (0 === n || e / n > 5);\n    }\n\n    return this._doublePrecisionRequiresObfuscation;\n  }\n\n}\n\nlet p = null;\n\nfunction f(n) {\n  return (e(p) || p.context !== n) && (p = new u(n)), p;\n}\n\nfunction v(e) {\n  n(p) && p.context === e && (p = null);\n}\n\nfunction h(e, n) {\n  const l = new i(e, {\n    colorTarget: 0,\n    depthStencilTarget: 0\n  }, {\n    target: 3553,\n    wrapMode: 33071,\n    pixelFormat: 6408,\n    dataType: 5121,\n    samplingMode: 9728,\n    width: 1,\n    height: 1\n  });\n\n  function u(t, o) {\n    const i = new r(e, `\\n\\n  precision highp float;\\n\\n  attribute vec2 position;\\n\\n  uniform vec3 u_highA;\\n  uniform vec3 u_lowA;\\n  uniform vec3 u_highB;\\n  uniform vec3 u_lowB;\\n\\n  varying vec4 v_color;\\n\\n  ${n ? \"#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION\" : \"\"}\\n\\n  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION\\n\\n  vec3 dpPlusFrc(vec3 a, vec3 b) {\\n    return mix(a, a + b, vec3(notEqual(b, vec3(0))));\\n  }\\n\\n  vec3 dpMinusFrc(vec3 a, vec3 b) {\\n    return mix(vec3(0), a - b, vec3(notEqual(a, b)));\\n  }\\n\\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\\n    vec3 t1 = dpPlusFrc(hiA, hiB);\\n    vec3 e = dpMinusFrc(t1, hiA);\\n    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\\n    return t1 + t2;\\n  }\\n\\n  #else\\n\\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\\n    vec3 t1 = hiA + hiB;\\n    vec3 e = t1 - hiA;\\n    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\\n    return t1 + t2;\\n  }\\n\\n  #endif\\n\\n  const float MAX_RGBA_FLOAT =\\n    255.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 / 256.0 / 256.0;\\n\\n  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\\n\\n  vec4 float2rgba(const float value) {\\n    // Make sure value is in the domain we can represent\\n    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\\n\\n    // Decompose value in 32bit fixed point parts represented as\\n    // uint8 rgba components. Decomposition uses the fractional part after multiplying\\n    // by a power of 256 (this removes the bits that are represented in the previous\\n    // component) and then converts the fractional part to 8bits.\\n    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\\n\\n    // Convert uint8 values (from 0 to 255) to floating point representation for\\n    // the shader\\n    const float toU8AsFloat = 1.0 / 255.0;\\n\\n    return fixedPointU8 * toU8AsFloat;\\n  }\\n\\n  void main() {\\n    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);\\n\\n    v_color = float2rgba(val.z / 25.0);\\n\\n    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);\\n  }\\n  `, \"\\n  precision highp float;\\n\\n  varying vec4 v_color;\\n\\n  void main() {\\n    gl_FragColor = v_color;\\n  }\\n  \", new Map([[\"position\", 0]])),\n          s = new Float32Array(6);\n    c(t, s, 3);\n    const a = new Float32Array(6);\n    return c(o, a, 3), e.useProgram(i), i.setUniform3f(\"u_highA\", s[0], s[2], s[4]), i.setUniform3f(\"u_lowA\", s[1], s[3], s[5]), i.setUniform3f(\"u_highB\", a[0], a[2], a[4]), i.setUniform3f(\"u_lowB\", a[1], a[3], a[5]), i;\n  }\n\n  const p = o.createVertex(e, 35044, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])),\n        f = new s(e, new Map([[\"position\", 0]]), {\n    geometry: [{\n      name: \"position\",\n      count: 2,\n      type: 5123,\n      offset: 0,\n      stride: 4,\n      normalized: !1\n    }]\n  }, {\n    geometry: p\n  }),\n        v = t(5633261.287538229, 2626832.878767164, 1434988.0495278358),\n        h = t(5633271.46742708, 2626873.6381334523, 1434963.231608387),\n        m = u(v, h),\n        d = e.getBoundFramebufferObject(),\n        {\n    x: b,\n    y: A,\n    width: g,\n    height: _\n  } = e.getViewport();\n  e.bindFramebuffer(l), e.setViewport(0, 0, 1, 1), e.bindVAO(f), e.drawArrays(5, 0, 4);\n  const w = new Uint8Array(4);\n  l.readPixels(0, 0, 1, 1, 6408, 5121, w), m.dispose(), f.dispose(!1), p.dispose(), l.dispose(), e.setViewport(b, A, g, _), e.bindFramebuffer(d);\n  const F = (v[2] - h[2]) / 25,\n        B = a(w);\n  return Math.abs(F - B);\n}\n\nexport { v as clearTestWebGLDriver, f as testWebGLDriver };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgisapi-react/node_modules/@arcgis/core/views/3d/webgl-engine/lib/WebGLDriverTest.js"],"names":["isNone","e","isSome","n","f","t","o","i","Program","r","s","encodeDoubleArray","c","unpackFloatRGBA","a","testSVGPremultipliedAlpha","l","u","constructor","context","svgAlwaysPremultipliesAlpha","_doublePrecisionRequiresObfuscation","then","doublePrecisionRequiresObfuscation","h","p","v","colorTarget","depthStencilTarget","target","wrapMode","pixelFormat","dataType","samplingMode","width","height","Map","Float32Array","useProgram","setUniform3f","createVertex","Uint16Array","geometry","name","count","type","offset","stride","normalized","m","d","getBoundFramebufferObject","x","b","y","A","g","_","getViewport","bindFramebuffer","setViewport","bindVAO","drawArrays","w","Uint8Array","readPixels","dispose","F","B","Math","abs","clearTestWebGLDriver","testWebGLDriver"],"mappings":"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","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{isNone as e,isSome as n}from\"../../../../core/maybe.js\";import{f as t}from\"../../../../chunks/vec3f64.js\";import o from\"../../../webgl/BufferObject.js\";import i from\"../../../webgl/FramebufferObject.js\";import{Program as r}from\"../../../webgl/Program.js\";import\"../../../webgl/enums.js\";import\"../../../webgl/RenderingContext.js\";import\"../../../webgl/Texture.js\";import s from\"../../../webgl/VertexArrayObject.js\";import{encodeDoubleArray as c}from\"./doublePrecisionUtils.js\";import{unpackFloatRGBA as a}from\"./Util.js\";import{testSVGPremultipliedAlpha as l}from\"../../../webgl/testSVGPremultipliedAlpha.js\";class u{constructor(e){this.context=e,this.svgAlwaysPremultipliesAlpha=!1,this._doublePrecisionRequiresObfuscation=null,l(e).then((e=>this.svgAlwaysPremultipliesAlpha=!e))}get doublePrecisionRequiresObfuscation(){if(e(this._doublePrecisionRequiresObfuscation)){const e=h(this.context,!1),n=h(this.context,!0);this._doublePrecisionRequiresObfuscation=0!==e&&(0===n||e/n>5)}return this._doublePrecisionRequiresObfuscation}}let p=null;function f(n){return(e(p)||p.context!==n)&&(p=new u(n)),p}function v(e){n(p)&&p.context===e&&(p=null)}function h(e,n){const l=new i(e,{colorTarget:0,depthStencilTarget:0},{target:3553,wrapMode:33071,pixelFormat:6408,dataType:5121,samplingMode:9728,width:1,height:1});function u(t,o){const i=new r(e,`\\n\\n  precision highp float;\\n\\n  attribute vec2 position;\\n\\n  uniform vec3 u_highA;\\n  uniform vec3 u_lowA;\\n  uniform vec3 u_highB;\\n  uniform vec3 u_lowB;\\n\\n  varying vec4 v_color;\\n\\n  ${n?\"#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION\":\"\"}\\n\\n  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION\\n\\n  vec3 dpPlusFrc(vec3 a, vec3 b) {\\n    return mix(a, a + b, vec3(notEqual(b, vec3(0))));\\n  }\\n\\n  vec3 dpMinusFrc(vec3 a, vec3 b) {\\n    return mix(vec3(0), a - b, vec3(notEqual(a, b)));\\n  }\\n\\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\\n    vec3 t1 = dpPlusFrc(hiA, hiB);\\n    vec3 e = dpMinusFrc(t1, hiA);\\n    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\\n    return t1 + t2;\\n  }\\n\\n  #else\\n\\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\\n    vec3 t1 = hiA + hiB;\\n    vec3 e = t1 - hiA;\\n    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\\n    return t1 + t2;\\n  }\\n\\n  #endif\\n\\n  const float MAX_RGBA_FLOAT =\\n    255.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 / 256.0 / 256.0;\\n\\n  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\\n\\n  vec4 float2rgba(const float value) {\\n    // Make sure value is in the domain we can represent\\n    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\\n\\n    // Decompose value in 32bit fixed point parts represented as\\n    // uint8 rgba components. Decomposition uses the fractional part after multiplying\\n    // by a power of 256 (this removes the bits that are represented in the previous\\n    // component) and then converts the fractional part to 8bits.\\n    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\\n\\n    // Convert uint8 values (from 0 to 255) to floating point representation for\\n    // the shader\\n    const float toU8AsFloat = 1.0 / 255.0;\\n\\n    return fixedPointU8 * toU8AsFloat;\\n  }\\n\\n  void main() {\\n    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);\\n\\n    v_color = float2rgba(val.z / 25.0);\\n\\n    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);\\n  }\\n  `,\"\\n  precision highp float;\\n\\n  varying vec4 v_color;\\n\\n  void main() {\\n    gl_FragColor = v_color;\\n  }\\n  \",new Map([[\"position\",0]])),s=new Float32Array(6);c(t,s,3);const a=new Float32Array(6);return c(o,a,3),e.useProgram(i),i.setUniform3f(\"u_highA\",s[0],s[2],s[4]),i.setUniform3f(\"u_lowA\",s[1],s[3],s[5]),i.setUniform3f(\"u_highB\",a[0],a[2],a[4]),i.setUniform3f(\"u_lowB\",a[1],a[3],a[5]),i}const p=o.createVertex(e,35044,new Uint16Array([0,0,1,0,0,1,1,1])),f=new s(e,new Map([[\"position\",0]]),{geometry:[{name:\"position\",count:2,type:5123,offset:0,stride:4,normalized:!1}]},{geometry:p}),v=t(5633261.287538229,2626832.878767164,1434988.0495278358),h=t(5633271.46742708,2626873.6381334523,1434963.231608387),m=u(v,h),d=e.getBoundFramebufferObject(),{x:b,y:A,width:g,height:_}=e.getViewport();e.bindFramebuffer(l),e.setViewport(0,0,1,1),e.bindVAO(f),e.drawArrays(5,0,4);const w=new Uint8Array(4);l.readPixels(0,0,1,1,6408,5121,w),m.dispose(),f.dispose(!1),p.dispose(),l.dispose(),e.setViewport(b,A,g,_),e.bindFramebuffer(d);const F=(v[2]-h[2])/25,B=a(w);return Math.abs(F-B)}export{v as clearTestWebGLDriver,f as testWebGLDriver};\n"]},"metadata":{},"sourceType":"module"}