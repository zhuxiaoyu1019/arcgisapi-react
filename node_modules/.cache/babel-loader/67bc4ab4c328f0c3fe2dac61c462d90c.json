{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { ScreenSpacePass as e } from \"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.js\";\nimport { ReadLinearDepth as r } from \"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";\nimport { CameraSpace as a } from \"../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl.js\";\nimport { glsl as t } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as o } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\n\nfunction n(n) {\n  const l = new o();\n  return l.include(e), 1 === n.output && (l.fragment.include(r), l.fragment.uniforms.add(\"normalMap\", \"sampler2D\").add(\"depthMap\", \"sampler2D\").add(\"tex\", \"sampler2D\").add(\"blurSize\", \"vec2\").add(\"g_BlurFalloff\", \"float\").add(\"projScale\", \"float\").add(\"nearFar\", \"vec2\").add(\"zScale\", \"vec2\"), l.fragment.code.add(t`\n      float blurFunction(vec2 uv, float r, float center_d, inout float w_total, float sharpness) {\n        float c = texture2D(tex, uv).r;\n        float d = linearDepthFromTexture(depthMap, uv, nearFar);\n\n        float ddiff = d - center_d;\n\n        float w = exp(-r*r*g_BlurFalloff - ddiff*ddiff*sharpness);\n\n        w_total += w;\n\n        return w*c;\n      }\n\n      void main(void) {\n        float b = 0.0;\n        float w_total = 0.0;\n\n        float center_d = linearDepthFromTexture(depthMap, uv, nearFar);\n\n        float sharpness = -0.05 * projScale/(center_d*zScale.x+zScale.y);\n        for (int r = -${t.int(n.radius)}; r <= ${t.int(n.radius)}; ++r) {\n          float rf = float(r);\n          vec2 uvOffset = uv + rf*blurSize;\n          b += blurFunction(uvOffset, rf, center_d, w_total, sharpness);\n        }\n\n        gl_FragColor = vec4(b/w_total);\n      }\n    `)), 0 === n.output && (l.fragment.include(r), l.include(a), l.fragment.uniforms.add(\"projMatrixInv\", \"mat4\").add(\"normalMap\", \"sampler2D\").add(\"depthMap\", \"sampler2D\").add(\"intensity\", \"float\").add(\"projScale\", \"float\").add(\"radius\", \"float\").add(\"nearFar\", \"vec2\").add(\"screenDimensions\", \"vec2\").add(\"rnmScale\", \"vec2\").add(\"rnm\", \"sampler2D\"), l.fragment.code.add(t`\n    uniform vec3 pSphere[${t.int(n.samples)}];\n\n    float fallOffFunction(float vv, float vn, float bias) {\n      float radius2 = radius * radius;\n      float f = max(radius2 - vv, 0.0);\n      return f * f * f * max(vn-bias, 0.0);\n    }\n    `), l.fragment.code.add(t`float aoValueFromPositionsAndNormal(vec3 C, vec3 n_C, vec3 Q) {\nvec3 v = Q - C;\nfloat vv = dot(v, v);\nfloat vn = dot(normalize(v), n_C);\nreturn fallOffFunction(vv, vn, 0.1);\n}`), l.fragment.code.add(t`\n      void main(void) {\n        vec3 fres = normalize((texture2D(rnm, uv * rnmScale).xyz * 2.0) - vec3(1.0));\n        float currentPixelDepth = linearDepthFromTexture(depthMap, uv, nearFar);\n\n        if (-currentPixelDepth>nearFar.y || -currentPixelDepth<nearFar.x) {\n          gl_FragColor = vec4(0.0);\n          return;\n        }\n\n        vec3 currentPixelPos = reconstructPosition(gl_FragCoord.xy,currentPixelDepth);\n\n        // get the normal of current fragment\n        vec4 norm4 = texture2D(normalMap, uv);\n        vec3 norm = vec3(-1.0) + 2.0 * norm4.xyz;\n        bool isTerrain = norm4.w<0.5;\n\n        float sum = .0;\n\n        vec4 occluderFragment;\n        vec3 ray;\n\n        vec3 tapPixelPos;\n\n        // note: the factor 2.0 should not be necessary, but makes ssao much nicer.\n        // bug or deviation from CE somewhere else?\n        float ps = projScale/(2.0*currentPixelPos.z*zScale.x+zScale.y);\n\n        for(int i = 0; i < ${t.int(n.samples)}; ++i) {\n          // get a vector (randomized inside of a sphere with radius 1.0) from a texture and reflect it\n          //float ssR;\n          //vec2 unitOffset = tapLocation(i, randomPatternRotationAngle, ssR);\n          // get the depth of the occluder fragment\n          //vec2 offset = vec2(-unitOffset*radius*ssR*ps);\n\n          vec2 unitOffset = reflect(pSphere[i], fres).xy;\n          vec2 offset = vec2(-unitOffset*radius*ps);\n\n          //don't use current or very nearby samples\n          if ( abs(offset.x)<2.0 || abs(offset.y)<2.0) continue;\n\n          vec2 tc = vec2(gl_FragCoord.xy + offset);\n          if (tc.x < 0.0 || tc.y < 0.0 || tc.x > screenDimensions.x || tc.y > screenDimensions.y) continue;\n          vec2 tcTap = tc/screenDimensions;\n          float occluderFragmentDepth = linearDepthFromTexture(depthMap, tcTap, nearFar);\n\n          if (isTerrain) {\n            bool isTerrainTap = texture2D(normalMap, tcTap).w<0.5;\n            if (isTerrainTap) {\n              continue;\n            }\n          }\n\n          tapPixelPos = reconstructPosition(tc, occluderFragmentDepth);\n\n          sum+= aoValueFromPositionsAndNormal(currentPixelPos, norm, tapPixelPos);\n        }\n\n        // output the result\n\n        float A = max(1.0-sum*intensity/float(${t.int(n.samples)}),0.0);\n\n        // Anti-tone map to reduce contrast and drag dark region farther\n        // (x^0.2 + 1.2 * x^4)/2.2\n        A = (pow(A, 0.2) + 1.2 * A*A*A*A) / 2.2;\n\n        //gl_FragColor = vec4(norm/2.0+0.5, 1.0);\n        //gl_FragColor = vec4(-currentPixelDepth/1000.0);\n        //gl_FragColor = vec4(tapPixelPos.x/100.0);\n        gl_FragColor = vec4(A);\n      }\n    `)), l;\n}\n\nvar l = Object.freeze({\n  __proto__: null,\n  build: n\n});\nexport { l as S, n as b };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgis-api-react/node_modules/@arcgis/core/chunks/SSAO.glsl.js"],"names":["ScreenSpacePass","e","ReadLinearDepth","r","CameraSpace","a","glsl","t","ShaderBuilder","o","n","l","include","output","fragment","uniforms","add","code","int","radius","samples","Object","freeze","__proto__","build","S","b"],"mappings":"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","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{ScreenSpacePass as e}from\"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.js\";import{ReadLinearDepth as r}from\"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";import{CameraSpace as a}from\"../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl.js\";import{glsl as t}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as o}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";function n(n){const l=new o;return l.include(e),1===n.output&&(l.fragment.include(r),l.fragment.uniforms.add(\"normalMap\",\"sampler2D\").add(\"depthMap\",\"sampler2D\").add(\"tex\",\"sampler2D\").add(\"blurSize\",\"vec2\").add(\"g_BlurFalloff\",\"float\").add(\"projScale\",\"float\").add(\"nearFar\",\"vec2\").add(\"zScale\",\"vec2\"),l.fragment.code.add(t`\n      float blurFunction(vec2 uv, float r, float center_d, inout float w_total, float sharpness) {\n        float c = texture2D(tex, uv).r;\n        float d = linearDepthFromTexture(depthMap, uv, nearFar);\n\n        float ddiff = d - center_d;\n\n        float w = exp(-r*r*g_BlurFalloff - ddiff*ddiff*sharpness);\n\n        w_total += w;\n\n        return w*c;\n      }\n\n      void main(void) {\n        float b = 0.0;\n        float w_total = 0.0;\n\n        float center_d = linearDepthFromTexture(depthMap, uv, nearFar);\n\n        float sharpness = -0.05 * projScale/(center_d*zScale.x+zScale.y);\n        for (int r = -${t.int(n.radius)}; r <= ${t.int(n.radius)}; ++r) {\n          float rf = float(r);\n          vec2 uvOffset = uv + rf*blurSize;\n          b += blurFunction(uvOffset, rf, center_d, w_total, sharpness);\n        }\n\n        gl_FragColor = vec4(b/w_total);\n      }\n    `)),0===n.output&&(l.fragment.include(r),l.include(a),l.fragment.uniforms.add(\"projMatrixInv\",\"mat4\").add(\"normalMap\",\"sampler2D\").add(\"depthMap\",\"sampler2D\").add(\"intensity\",\"float\").add(\"projScale\",\"float\").add(\"radius\",\"float\").add(\"nearFar\",\"vec2\").add(\"screenDimensions\",\"vec2\").add(\"rnmScale\",\"vec2\").add(\"rnm\",\"sampler2D\"),l.fragment.code.add(t`\n    uniform vec3 pSphere[${t.int(n.samples)}];\n\n    float fallOffFunction(float vv, float vn, float bias) {\n      float radius2 = radius * radius;\n      float f = max(radius2 - vv, 0.0);\n      return f * f * f * max(vn-bias, 0.0);\n    }\n    `),l.fragment.code.add(t`float aoValueFromPositionsAndNormal(vec3 C, vec3 n_C, vec3 Q) {\nvec3 v = Q - C;\nfloat vv = dot(v, v);\nfloat vn = dot(normalize(v), n_C);\nreturn fallOffFunction(vv, vn, 0.1);\n}`),l.fragment.code.add(t`\n      void main(void) {\n        vec3 fres = normalize((texture2D(rnm, uv * rnmScale).xyz * 2.0) - vec3(1.0));\n        float currentPixelDepth = linearDepthFromTexture(depthMap, uv, nearFar);\n\n        if (-currentPixelDepth>nearFar.y || -currentPixelDepth<nearFar.x) {\n          gl_FragColor = vec4(0.0);\n          return;\n        }\n\n        vec3 currentPixelPos = reconstructPosition(gl_FragCoord.xy,currentPixelDepth);\n\n        // get the normal of current fragment\n        vec4 norm4 = texture2D(normalMap, uv);\n        vec3 norm = vec3(-1.0) + 2.0 * norm4.xyz;\n        bool isTerrain = norm4.w<0.5;\n\n        float sum = .0;\n\n        vec4 occluderFragment;\n        vec3 ray;\n\n        vec3 tapPixelPos;\n\n        // note: the factor 2.0 should not be necessary, but makes ssao much nicer.\n        // bug or deviation from CE somewhere else?\n        float ps = projScale/(2.0*currentPixelPos.z*zScale.x+zScale.y);\n\n        for(int i = 0; i < ${t.int(n.samples)}; ++i) {\n          // get a vector (randomized inside of a sphere with radius 1.0) from a texture and reflect it\n          //float ssR;\n          //vec2 unitOffset = tapLocation(i, randomPatternRotationAngle, ssR);\n          // get the depth of the occluder fragment\n          //vec2 offset = vec2(-unitOffset*radius*ssR*ps);\n\n          vec2 unitOffset = reflect(pSphere[i], fres).xy;\n          vec2 offset = vec2(-unitOffset*radius*ps);\n\n          //don't use current or very nearby samples\n          if ( abs(offset.x)<2.0 || abs(offset.y)<2.0) continue;\n\n          vec2 tc = vec2(gl_FragCoord.xy + offset);\n          if (tc.x < 0.0 || tc.y < 0.0 || tc.x > screenDimensions.x || tc.y > screenDimensions.y) continue;\n          vec2 tcTap = tc/screenDimensions;\n          float occluderFragmentDepth = linearDepthFromTexture(depthMap, tcTap, nearFar);\n\n          if (isTerrain) {\n            bool isTerrainTap = texture2D(normalMap, tcTap).w<0.5;\n            if (isTerrainTap) {\n              continue;\n            }\n          }\n\n          tapPixelPos = reconstructPosition(tc, occluderFragmentDepth);\n\n          sum+= aoValueFromPositionsAndNormal(currentPixelPos, norm, tapPixelPos);\n        }\n\n        // output the result\n\n        float A = max(1.0-sum*intensity/float(${t.int(n.samples)}),0.0);\n\n        // Anti-tone map to reduce contrast and drag dark region farther\n        // (x^0.2 + 1.2 * x^4)/2.2\n        A = (pow(A, 0.2) + 1.2 * A*A*A*A) / 2.2;\n\n        //gl_FragColor = vec4(norm/2.0+0.5, 1.0);\n        //gl_FragColor = vec4(-currentPixelDepth/1000.0);\n        //gl_FragColor = vec4(tapPixelPos.x/100.0);\n        gl_FragColor = vec4(A);\n      }\n    `)),l}var l=Object.freeze({__proto__:null,build:n});export{l as S,n as b};\n"]},"metadata":{},"sourceType":"module"}