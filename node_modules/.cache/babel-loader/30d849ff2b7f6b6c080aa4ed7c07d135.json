{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport { ReadLinearDepth as e } from \"../output/ReadLinearDepth.glsl.js\";\nimport { multipassGeometryTest as r } from \"../shading/MultipassGeometryTest.glsl.js\";\nimport { RgbaFloatEncoding as t } from \"../util/RgbaFloatEncoding.glsl.js\";\nimport { glsl as o } from \"../../shaderModules/interfaces.js\";\n\nfunction a(a, i) {\n  i.multipassGeometryEnabled && a.vertex.include(r), i.multipassTerrainEnabled && a.varyings.add(\"depth\", \"float\"), a.vertex.code.add(o`\n  void main(void) {\n    vec4 posProjCenter;\n    if (dot(position, position) > 0.0) {\n      // Render single point to center of the pixel to avoid subpixel\n      // filtering to affect the marker color\n      ProjectHUDAux projectAux;\n      vec4 posProj = projectPositionHUD(projectAux);\n      posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n\n      ${i.multipassGeometryEnabled ? o`\n        // Don't draw vertices behind geometry\n        if(geometryDepthTest(.5 + .5 * posProjCenter.xy / posProjCenter.w, projectAux.posView.z)){\n          posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n        }` : \"\"}\n\n      ${i.multipassTerrainEnabled ? \"depth = projectAux.posView.z;\" : \"\"}\n      vec3 vpos = projectAux.posModel;\n      if (rejectBySlice(vpos)) {\n        // Project out of clip space\n        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n      }\n\n    } else {\n      // Project out of clip space\n      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n\n    gl_Position = posProjCenter;\n    gl_PointSize = 1.0;\n  }\n  `), i.multipassTerrainEnabled && a.fragment.include(e), a.fragment.uniforms.add(\"terrainDepthTexture\", \"sampler2D\"), a.fragment.uniforms.add(\"cameraNearFar\", \"vec2\"), a.fragment.uniforms.add(\"inverseViewport\", \"vec2\"), a.fragment.include(t), a.fragment.code.add(o`\n  void main() {\n    gl_FragColor = vec4(1, 1, 1, 1);\n    ${i.multipassTerrainEnabled ? o`\n\n          vec2 uv = gl_FragCoord.xy * inverseViewport;\n\n          //Read the rgba data from the texture linear depth\n          vec4 terrainDepthData = texture2D(terrainDepthTexture, uv);\n\n          float terrainDepth = linearDepthFromFloat(rgba2float(terrainDepthData), cameraNearFar);\n\n          //If HUD vertex is behind terrain and the terrain depth is not the initialize value (e.g. we are not looking at the sky)\n          //Mark the HUD vertex as occluded by transparent terrain\n          if(depth < terrainDepth && terrainDepthData != vec4(0,0,0,1)){\n            gl_FragColor.g = 0.5;\n          }` : \"\"}\n  }\n  `);\n}\n\nexport { a as HUDOcclusionPass };","map":{"version":3,"sources":["/Users/xiaoyuzhu/Desktop/arcgis-api-react/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/hud/HUDOcclusionPass.glsl.js"],"names":["ReadLinearDepth","e","multipassGeometryTest","r","RgbaFloatEncoding","t","glsl","o","a","i","multipassGeometryEnabled","vertex","include","multipassTerrainEnabled","varyings","add","code","fragment","uniforms","HUDOcclusionPass"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,eAAe,IAAIC,CAA1B,QAAgC,mCAAhC;AAAoE,SAAOC,qBAAqB,IAAIC,CAAhC,QAAsC,0CAAtC;AAAiF,SAAOC,iBAAiB,IAAIC,CAA5B,QAAkC,mCAAlC;AAAsE,SAAOC,IAAI,IAAIC,CAAf,QAAqB,mCAArB;;AAAyD,SAASC,CAAT,CAAWA,CAAX,EAAaC,CAAb,EAAe;AAACA,EAAAA,CAAC,CAACC,wBAAF,IAA4BF,CAAC,CAACG,MAAF,CAASC,OAAT,CAAiBT,CAAjB,CAA5B,EAAgDM,CAAC,CAACI,uBAAF,IAA2BL,CAAC,CAACM,QAAF,CAAWC,GAAX,CAAe,OAAf,EAAuB,OAAvB,CAA3E,EAA2GP,CAAC,CAACG,MAAF,CAASK,IAAT,CAAcD,GAAd,CAAkBR,CAAE;AACna;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQE,CAAC,CAACC,wBAAF,GAA2BH,CAAE;AACrC;AACA;AACA;AACA,UAJQ,GAIG,EAAG;AACd;AACA,QAAQE,CAAC,CAACI,uBAAF,GAA0B,+BAA1B,GAA0D,EAAG;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GA/B+Y,CAA3G,EA+B/RJ,CAAC,CAACI,uBAAF,IAA2BL,CAAC,CAACS,QAAF,CAAWL,OAAX,CAAmBX,CAAnB,CA/BoQ,EA+B9OO,CAAC,CAACS,QAAF,CAAWC,QAAX,CAAoBH,GAApB,CAAwB,qBAAxB,EAA8C,WAA9C,CA/B8O,EA+BnLP,CAAC,CAACS,QAAF,CAAWC,QAAX,CAAoBH,GAApB,CAAwB,eAAxB,EAAwC,MAAxC,CA/BmL,EA+BnIP,CAAC,CAACS,QAAF,CAAWC,QAAX,CAAoBH,GAApB,CAAwB,iBAAxB,EAA0C,MAA1C,CA/BmI,EA+BjFP,CAAC,CAACS,QAAF,CAAWL,OAAX,CAAmBP,CAAnB,CA/BiF,EA+B3DG,CAAC,CAACS,QAAF,CAAWD,IAAX,CAAgBD,GAAhB,CAAoBR,CAAE;AAC/P;AACA;AACA,MAAME,CAAC,CAACI,uBAAF,GAA0BN,CAAE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAbM,GAaO,EAAG;AAChB;AACA,GAlByO,CA/B2D;AAiD/R;;AAAA,SAAOC,CAAC,IAAIW,gBAAZ","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.20/esri/copyright.txt for details.\n*/\nimport{ReadLinearDepth as e}from\"../output/ReadLinearDepth.glsl.js\";import{multipassGeometryTest as r}from\"../shading/MultipassGeometryTest.glsl.js\";import{RgbaFloatEncoding as t}from\"../util/RgbaFloatEncoding.glsl.js\";import{glsl as o}from\"../../shaderModules/interfaces.js\";function a(a,i){i.multipassGeometryEnabled&&a.vertex.include(r),i.multipassTerrainEnabled&&a.varyings.add(\"depth\",\"float\"),a.vertex.code.add(o`\n  void main(void) {\n    vec4 posProjCenter;\n    if (dot(position, position) > 0.0) {\n      // Render single point to center of the pixel to avoid subpixel\n      // filtering to affect the marker color\n      ProjectHUDAux projectAux;\n      vec4 posProj = projectPositionHUD(projectAux);\n      posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n\n      ${i.multipassGeometryEnabled?o`\n        // Don't draw vertices behind geometry\n        if(geometryDepthTest(.5 + .5 * posProjCenter.xy / posProjCenter.w, projectAux.posView.z)){\n          posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n        }`:\"\"}\n\n      ${i.multipassTerrainEnabled?\"depth = projectAux.posView.z;\":\"\"}\n      vec3 vpos = projectAux.posModel;\n      if (rejectBySlice(vpos)) {\n        // Project out of clip space\n        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n      }\n\n    } else {\n      // Project out of clip space\n      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n\n    gl_Position = posProjCenter;\n    gl_PointSize = 1.0;\n  }\n  `),i.multipassTerrainEnabled&&a.fragment.include(e),a.fragment.uniforms.add(\"terrainDepthTexture\",\"sampler2D\"),a.fragment.uniforms.add(\"cameraNearFar\",\"vec2\"),a.fragment.uniforms.add(\"inverseViewport\",\"vec2\"),a.fragment.include(t),a.fragment.code.add(o`\n  void main() {\n    gl_FragColor = vec4(1, 1, 1, 1);\n    ${i.multipassTerrainEnabled?o`\n\n          vec2 uv = gl_FragCoord.xy * inverseViewport;\n\n          //Read the rgba data from the texture linear depth\n          vec4 terrainDepthData = texture2D(terrainDepthTexture, uv);\n\n          float terrainDepth = linearDepthFromFloat(rgba2float(terrainDepthData), cameraNearFar);\n\n          //If HUD vertex is behind terrain and the terrain depth is not the initialize value (e.g. we are not looking at the sky)\n          //Mark the HUD vertex as occluded by transparent terrain\n          if(depth < terrainDepth && terrainDepthData != vec4(0,0,0,1)){\n            gl_FragColor.g = 0.5;\n          }`:\"\"}\n  }\n  `)}export{a as HUDOcclusionPass};\n"]},"metadata":{},"sourceType":"module"}